---
phase: 43-calendar-display-advanced
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/calendar/src/gesture-handler.ts
  - packages/calendar/src/animation-controller.ts
autonomous: true

must_haves:
  truths:
    - "GestureHandler detects horizontal swipe gestures via Pointer Events"
    - "GestureHandler distinguishes swipe from scroll (horizontal > 1.5x vertical)"
    - "AnimationController manages slide/fade transitions with isAnimating guard"
    - "AnimationController respects prefers-reduced-motion (fade instead of slide)"
  artifacts:
    - path: "packages/calendar/src/gesture-handler.ts"
      provides: "Swipe gesture detection via Pointer Events API"
      exports: ["GestureHandler", "SwipeResult"]
    - path: "packages/calendar/src/animation-controller.ts"
      provides: "Month transition animation with reduced-motion support"
      exports: ["AnimationController"]
  key_links:
    - from: "packages/calendar/src/gesture-handler.ts"
      to: "packages/calendar/src/calendar.ts"
      via: "constructor injection"
      pattern: "new GestureHandler"
    - from: "packages/calendar/src/animation-controller.ts"
      to: "packages/calendar/src/calendar.ts"
      via: "constructor injection"
      pattern: "new AnimationController"
---

<objective>
Create standalone gesture handler and animation controller modules.

Purpose: Touch swipe navigation (CAL-28) and month transition animations (CAL-24, CAL-25) require dedicated handlers. Building them as standalone modules enables unit testing and clean integration into Calendar.
Output: Two new utility files: gesture-handler.ts and animation-controller.ts.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-calendar-display-advanced/43-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GestureHandler for swipe detection</name>
  <files>packages/calendar/src/gesture-handler.ts</files>
  <action>
Create `gesture-handler.ts` with the following:

1. Export `SwipeResult` interface: `{ direction: 'left' | 'right'; distance: number; duration: number }`
2. Export `GestureHandler` class with:
   - Constructor: `(element: HTMLElement, onSwipe: (result: SwipeResult) => void)`
   - Private fields: `startX`, `startY`, `startTime`, `element`, `onSwipe`
   - Constants: `threshold = 50` (min swipe distance px), `maxDuration = 500` (max swipe time ms)
   - `handlePointerDown`: Record start position/time, call `element.setPointerCapture(e.pointerId)`
   - `handlePointerUp`: Calculate dx/dy/dt. If `absDx > threshold && absDx > absDy * 1.5 && dt < maxDuration`, invoke `onSwipe` callback
   - `handlePointerCancel`: Reset state (set `_swipeStart = null`)
   - `destroy()`: Remove all event listeners for cleanup
   - Bind all handlers in constructor using arrow function properties
3. Add isServer guard - constructor should no-op on server
4. Use `touch-action: pan-y` CSS hint in documentation comment (Calendar will apply it)

Follow the exact pattern from research (Pattern 4).
  </action>
  <verify>
`npx tsc --noEmit -p packages/calendar/tsconfig.json` compiles without errors.
  </verify>
  <done>
GestureHandler class detects horizontal swipe gestures using Pointer Events API with 50px threshold and 1.5x horizontal ratio.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AnimationController for month transitions</name>
  <files>packages/calendar/src/animation-controller.ts</files>
  <action>
Create `animation-controller.ts` with the following:

1. Export `AnimationController` class with:
   - Constructor: `(getGridElement: () => HTMLElement | null | undefined)`
   - Private fields: `isAnimating: boolean = false`, `getGridElement` callback
   - `get prefersReducedMotion(): boolean` - checks `window.matchMedia('(prefers-reduced-motion: reduce)').matches` with isServer guard
   - `async animateTransition(direction: 'next' | 'prev', updateFn: () => void): Promise<void>`:
     a. If `isAnimating`, call `updateFn()` immediately (skip animation) and return
     b. Set `isAnimating = true`
     c. Get grid element via callback
     d. If reduced motion: add 'fade-out' class, wait for transitionend, call `updateFn()`, remove 'fade-out', wait for transitionend
     e. If full motion: add slide-out class (left for next, right for prev), wait for transitionend, call `updateFn()`, replace with slide-in class, force reflow (`void element.offsetHeight`), remove slide-in class, wait for transitionend
     f. Set `isAnimating = false` in finally block
   - Private `waitForTransition(element: Element): Promise<void>` using `transitionend` event with `{ once: true }` and 300ms timeout fallback
   - `destroy()`: cleanup method (cancel pending animations)
2. Add isServer guard - methods should no-op on server (updateFn still called)
3. CSS class names used: `fade-out`, `slide-out-left`, `slide-out-right`, `slide-in-left`, `slide-in-right`

The animation CSS will be added to Calendar in plan 43-05.
  </action>
  <verify>
`npx tsc --noEmit -p packages/calendar/tsconfig.json` compiles without errors.
  </verify>
  <done>
AnimationController manages slide/fade transitions with isAnimating guard and prefers-reduced-motion support. Rapid navigation skips animation and updates instantly.
  </done>
</task>

</tasks>

<verification>
- Both files compile: `npx tsc --noEmit -p packages/calendar/tsconfig.json`
- GestureHandler uses Pointer Events API (not Touch Events)
- AnimationController respects prefers-reduced-motion
- AnimationController handles rapid navigation (isAnimating guard)
- Both classes have destroy() for cleanup
</verification>

<success_criteria>
Two standalone utility modules ready for Calendar integration: GestureHandler for swipe detection and AnimationController for month transition animations.
</success_criteria>

<output>
After completion, create `.planning/phases/43-calendar-display-advanced/43-02-SUMMARY.md`
</output>
