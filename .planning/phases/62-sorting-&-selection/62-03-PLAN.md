---
phase: 62-sorting-selection
plan: 03
type: execute
wave: 3
depends_on: ["62-02"]
files_modified:
  - packages/data-table/src/data-table.ts
  - packages/data-table/src/selection-column.ts
autonomous: true

must_haves:
  truths:
    - "User can Shift+click two rows to select entire range between them"
    - "User sees 'Select all X items' link after page select-all to select entire dataset"
    - "User's selection clears when filters change (configurable to preserve)"
  artifacts:
    - path: "packages/data-table/src/data-table.ts"
      provides: "Shift+click range selection and filter clearing logic"
      contains: "lastSelectedRowId"
    - path: "packages/data-table/src/data-table.ts"
      provides: "Selection banner rendering"
      contains: "renderSelectionBanner"
  key_links:
    - from: "packages/data-table/src/data-table.ts"
      to: "TanStack row model"
      via: "getRowModel().rows for range calculation"
      pattern: "getRowModel\\(\\)\\.rows"
    - from: "packages/data-table/src/selection-column.ts"
      to: "shift+click handler"
      via: "event.shiftKey check"
      pattern: "shiftKey"
---

<objective>
Add advanced selection features: shift+click range selection, select-all-across-pages banner, and filter-change clearing.

Purpose: Users need efficient bulk selection (range select) and clear feedback when selections span pages or when filters change.

Output:
- Shift+click to select range of rows between two clicks
- "Select all X items" banner when page is fully selected
- Selection auto-clears on filter change (configurable)
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/62-sorting-&-selection/62-RESEARCH.md
@.planning/phases/62-sorting-&-selection/62-02-SUMMARY.md
@packages/data-table/src/data-table.ts
@packages/data-table/src/selection-column.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement shift+click range selection</name>
  <files>
    packages/data-table/src/data-table.ts
    packages/data-table/src/selection-column.ts
  </files>
  <action>
1. In data-table.ts, add state for tracking last selected row:
```typescript
/**
 * Track last selected row ID for shift+click range selection.
 */
@state()
private lastSelectedRowId: string | null = null;
```

2. Add getRowRange helper method:
```typescript
/**
 * Get all rows between two row IDs (inclusive).
 * Used for shift+click range selection.
 */
private getRowRange(rows: Row<TData>[], idA: string, idB: string): Row<TData>[] {
  const range: Row<TData>[] = [];
  let foundStart = false;
  let foundEnd = false;

  for (const row of rows) {
    if (row.id === idA || row.id === idB) {
      if (foundStart) {
        foundEnd = true;
      } else {
        foundStart = true;
      }
    }
    if (foundStart) range.push(row);
    if (foundEnd) break;
  }
  return range;
}
```

3. Add handleRowSelect method to handle shift+click:
```typescript
/**
 * Handle row selection with shift+click range support.
 * Called from selection column checkbox click.
 */
public handleRowSelect(row: Row<TData>, event: MouseEvent): void {
  const table = this.tableController.table(...);

  if (event.shiftKey && this.lastSelectedRowId && this.enableSelection) {
    const { rows } = table.getRowModel();
    const range = this.getRowRange(rows, row.id, this.lastSelectedRowId);

    // Match selection state of the last selected row
    const lastRow = rows.find(r => r.id === this.lastSelectedRowId);
    const targetState = lastRow?.getIsSelected() ?? true;

    range.forEach(r => r.toggleSelected(targetState));
  } else {
    row.toggleSelected();
  }

  this.lastSelectedRowId = row.id;
}
```

4. Update selection-column.ts to pass event and use data-table method:
```typescript
cell: ({ row, table }: { row: Row<TData>; table: Table<TData> }) => {
  // Get the data-table element to call handleRowSelect
  // We need to pass the click event for shift detection

  return html`
    <lui-checkbox
      size="sm"
      .checked=${row.getIsSelected()}
      .disabled=${!row.getCanSelect()}
      @click=${(e: MouseEvent) => {
        e.stopPropagation(); // Prevent row click
        // The actual toggle is handled by ui-change, but we check shift here
        // Store event reference for the change handler
        (e.target as HTMLElement).dataset.shiftKey = String(e.shiftKey);
      }}
      @ui-change=${(e: CustomEvent) => {
        const checkbox = e.target as HTMLElement;
        const wasShiftClick = checkbox.dataset.shiftKey === 'true';
        delete checkbox.dataset.shiftKey;

        // Create a synthetic event for the handler
        const syntheticEvent = { shiftKey: wasShiftClick } as MouseEvent;

        // Get data-table host element
        const dataTable = checkbox.closest('lui-data-table') as DataTable<TData> | null;
        if (dataTable && 'handleRowSelect' in dataTable) {
          dataTable.handleRowSelect(row, syntheticEvent);
        } else {
          // Fallback: simple toggle
          row.toggleSelected();
        }
      }}
      aria-label="Select row"
    ></lui-checkbox>
  `;
}
```

Alternative simpler approach - handle at row level:
Update renderRow to detect shift+click on row and call handleRowSelect.

Important: Use TanStack row model for range calculation, NOT DOM indices (virtualization-safe).
  </action>
  <verify>
1. Build: `cd packages/data-table && pnpm build`
2. Visual test:
   - Click row A checkbox to select
   - Shift+click row D checkbox
   - Rows A, B, C, D should all be selected
   - Works correctly with virtualized rows
  </verify>
  <done>
Shift+click selects all rows between the last clicked row and current row.
Range is calculated using TanStack row model (virtualization-safe).
Selection state matches the last selected row's state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add select-all-across-pages banner</name>
  <files>
    packages/data-table/src/data-table.ts
  </files>
  <action>
1. Add property for total row count (used for server-side pagination):
```typescript
/**
 * Total number of rows across all pages.
 * Used for "Select all X items" display. For client-side, uses data.length.
 */
@property({ type: Number, attribute: 'total-row-count' })
totalRowCount?: number;
```

2. Add renderSelectionBanner method:
```typescript
/**
 * Render "Select all X items" banner when all page rows are selected.
 */
private renderSelectionBanner(table: Table<TData>): TemplateResult {
  if (!this.enableSelection) return html``;

  const isAllPageSelected = table.getIsAllPageRowsSelected();
  const totalCount = this.totalRowCount ?? this.data.length;
  const selectedCount = Object.keys(this.rowSelection).length;

  // Only show banner when:
  // 1. All rows on current page are selected
  // 2. Not all rows in dataset are selected
  if (!isAllPageSelected || selectedCount >= totalCount) {
    return html``;
  }

  return html`
    <div class="selection-banner" role="status" aria-live="polite">
      <span class="selection-banner-text">
        ${selectedCount} items on this page selected.
      </span>
      <button
        type="button"
        class="selection-banner-link"
        @click=${() => this.handleSelectAll(table, totalCount)}
      >
        Select all ${totalCount.toLocaleString()} items
      </button>
    </div>
  `;
}
```

3. Add handleSelectAll method:
```typescript
/**
 * Handle "Select all X items" click.
 * For client-side: selects all rows in data array.
 * For server-side: emits event for parent to handle.
 */
private handleSelectAll(table: Table<TData>, totalCount: number): void {
  if (this.manualPagination) {
    // Server-side: emit event with intent
    const event = new CustomEvent('ui-select-all-requested', {
      detail: { totalCount },
      bubbles: true,
      composed: true,
    });
    this.dispatchEvent(event);
  } else {
    // Client-side: select all rows
    table.toggleAllRowsSelected(true);
  }
}
```

Note: manualPagination property will be added in Phase 63. For now, default to client-side behavior.

4. Add CSS for banner:
```css
.selection-banner {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  background: var(--ui-data-table-banner-bg, #eff6ff);
  border-bottom: 1px solid var(--ui-data-table-border-color);
  font-size: 0.875rem;
  color: var(--ui-data-table-text-color);
}

:host-context(.dark) .selection-banner {
  --ui-data-table-banner-bg: rgba(59, 130, 246, 0.15);
}

.selection-banner-link {
  background: none;
  border: none;
  color: var(--color-primary, #3b82f6);
  font-weight: 500;
  cursor: pointer;
  text-decoration: underline;
  text-underline-offset: 2px;
}

.selection-banner-link:hover {
  text-decoration: none;
}

.selection-banner-link:focus-visible {
  outline: 2px solid var(--color-primary, #3b82f6);
  outline-offset: 2px;
  border-radius: 2px;
}
```

5. Update render() to include banner after header:
```typescript
return html`
  <div class="data-table-container" ...>
    ${this.renderHeader(table)}
    ${this.renderSelectionBanner(table)}
    ${this.renderBody(table)}
    ...
  </div>
`;
```
  </action>
  <verify>
1. Build: `cd packages/data-table && pnpm build`
2. Visual test:
   - Enable selection
   - Click header checkbox to select all page rows
   - Banner appears: "X items on this page selected. Select all Y items"
   - Click "Select all Y items" link
   - All rows selected, banner disappears
  </verify>
  <done>
Selection banner appears when all page rows selected but not all dataset rows.
Banner shows count and provides "Select all X items" action.
Client-side: toggleAllRowsSelected(true) called.
Server-side: ui-select-all-requested event emitted (ready for Phase 63).
  </done>
</task>

<task type="auto">
  <name>Task 3: Clear selection on filter change</name>
  <files>
    packages/data-table/src/data-table.ts
  </files>
  <action>
1. Add property to control filter-clear behavior:
```typescript
/**
 * Whether to preserve selection when filters change.
 * Default: false (selection clears on filter change).
 */
@property({ type: Boolean, attribute: 'preserve-selection-on-filter' })
preserveSelectionOnFilter = false;
```

2. Add properties for filter state (will be used in Phase 63):
```typescript
/**
 * Column filters state (used for selection clearing detection).
 * Full implementation in Phase 63.
 */
@property({ type: Array })
columnFilters: ColumnFiltersState = [];

/**
 * Global filter string (used for selection clearing detection).
 * Full implementation in Phase 63.
 */
@property({ type: String, attribute: 'global-filter' })
globalFilter = '';
```

3. Track previous filter state:
```typescript
/**
 * Previous filter state for change detection.
 */
@state()
private _previousFilterState = '';
```

4. Add filter change detection in updated():
```typescript
protected override updated(changedProperties: PropertyValues): void {
  super.updated(changedProperties);

  // ... existing code ...

  // SEL-06: Clear selection when filters change (unless configured to preserve)
  if (
    this.enableSelection &&
    !this.preserveSelectionOnFilter &&
    (changedProperties.has('columnFilters') || changedProperties.has('globalFilter'))
  ) {
    const currentFilterState = JSON.stringify({
      columnFilters: this.columnFilters,
      globalFilter: this.globalFilter,
    });

    if (this._previousFilterState && currentFilterState !== this._previousFilterState) {
      // Filters changed - clear selection
      this.rowSelection = {};
      this.lastSelectedRowId = null;

      // Dispatch event to notify parent
      const event = new CustomEvent('ui-selection-change', {
        detail: {
          rowSelection: {},
          selectedRows: [],
          selectedCount: 0,
          reason: 'filter-changed',
        } satisfies SelectionChangeEvent<TData>,
        bubbles: true,
        composed: true,
      });
      this.dispatchEvent(event);
    }

    this._previousFilterState = currentFilterState;
  }
}
```

5. Initialize previous filter state on first render:
```typescript
override firstUpdated(): void {
  this._previousFilterState = JSON.stringify({
    columnFilters: this.columnFilters,
    globalFilter: this.globalFilter,
  });
}
```
  </action>
  <verify>
1. Build: `cd packages/data-table && pnpm build`
2. Conceptual verification (full testing in Phase 63 when filters implemented):
   - When columnFilters or globalFilter property changes
   - If preserveSelectionOnFilter is false (default)
   - Selection should clear and ui-selection-change event fires with reason: 'filter-changed'
  </verify>
  <done>
Selection automatically clears when filter state changes.
Behavior is configurable via preserve-selection-on-filter attribute.
Event includes reason: 'filter-changed' for parent awareness.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Shift+click range selection:**
   - Click row 3 checkbox to select
   - Shift+click row 7 checkbox
   - Rows 3, 4, 5, 6, 7 all selected
   - Works with virtualized rows (no DOM index issues)

2. **Select all across pages:**
   - Click header checkbox (selects all on page)
   - Banner appears: "10 items on this page selected. Select all 1,000 items"
   - Click link
   - All 1,000 rows selected
   - Banner disappears

3. **Filter change clearing:**
   - Select some rows
   - Change globalFilter or columnFilters property
   - Selection clears automatically
   - ui-selection-change event fires with reason: 'filter-changed'
   - If preserve-selection-on-filter is true, selection persists
</verification>

<success_criteria>
1. SEL-03: Shift+click enables range selection (select all rows between two clicks)
2. SEL-04: "Select all X items" link appears after page select-all to select entire filtered dataset
3. SEL-06: Selection is cleared when filters change (with configurable option to preserve)
</success_criteria>

<output>
After completion, create `.planning/phases/62-sorting-&-selection/62-03-SUMMARY.md`
</output>
