---
phase: 101-webgpu-two-layer-canvas-for-line-area
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/charts/package.json
  - packages/charts/src/shared/webgpu-device.ts
autonomous: true
requirements: [WEBGPU-02]

must_haves:
  truths:
    - "chartgpu@0.3.2 is a runtime dependency in packages/charts/package.json"
    - "releaseGpuDevice() decrements a refcount and only calls device.destroy() when count reaches zero"
    - "acquireGpuDevice() increments the refcount on every call (not just first)"
    - "getGpuAdapter() returns the stored GPUAdapter so ChartGPU.create() can receive { adapter, device }"
  artifacts:
    - path: "packages/charts/package.json"
      provides: "chartgpu@0.3.2 in dependencies"
      contains: "chartgpu"
    - path: "packages/charts/src/shared/webgpu-device.ts"
      provides: "Refcounted GPUDevice singleton with adapter storage"
      exports: ["acquireGpuDevice", "getGpuDevice", "getGpuAdapter", "releaseGpuDevice", "RendererTier"]
  key_links:
    - from: "packages/charts/src/line/line-chart.ts"
      to: "packages/charts/src/shared/webgpu-device.ts"
      via: "getGpuDevice() + getGpuAdapter() imports"
      pattern: "getGpuAdapter|getGpuDevice"
    - from: "packages/charts/src/shared/webgpu-device.ts"
      to: "GPUDevice.destroy()"
      via: "releaseGpuDevice() refcount reaching zero"
      pattern: "device\\.destroy\\(\\)"
---

<objective>
Install ChartGPU and upgrade the Phase 98 GPUDevice singleton to support refcounted lifecycle and GPUAdapter storage.

Purpose: Phase 101 requires ChartGPU 0.3.2 as a runtime dependency and a real teardown path for GPUDevice — the Phase 98 stub (`releaseGpuDevice()` that only nulls the promise) is insufficient for WEBGPU-02 Success Criterion 4 (no memory leak over 10 create/destroy cycles). The GPUAdapter must also be stored so Plans 02 and 03 can pass `{ adapter, device }` to `ChartGPU.create()`.

Output: `chartgpu@0.3.2` in `packages/charts/package.json` dependencies + refcounted `webgpu-device.ts` with `getGpuAdapter()`.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/101-webgpu-two-layer-canvas-for-line-area/101-RESEARCH.md

<interfaces>
<!-- Existing webgpu-device.ts exports (Phase 98 baseline) -->
From packages/charts/src/shared/webgpu-device.ts:
```typescript
/// <reference types="@webgpu/types" />

export type RendererTier = 'webgpu' | 'webgl' | 'canvas';

let _devicePromise: Promise<GPUDevice> | null = null;

export async function acquireGpuDevice(adapter: GPUAdapter): Promise<GPUDevice>;
// First call: caches adapter.requestDevice(); subsequent calls: returns cached promise, adapter discarded

export function getGpuDevice(): Promise<GPUDevice> | null;
// Returns cached promise; null if not yet acquired

export function releaseGpuDevice(): void;
// STUB: Currently just sets _devicePromise = null — no refcount, no device.destroy()
```

<!-- base-chart-element.ts acquireGpuDevice call site -->
From packages/charts/src/base/base-chart-element.ts:
```typescript
import { acquireGpuDevice, type RendererTier } from '../shared/webgpu-device.js';

// Inside _detectRenderer():
const adapter = await navigator.gpu.requestAdapter();
if (!adapter) { ... fallback ... }
await acquireGpuDevice(adapter);
this.renderer = 'webgpu';
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install chartgpu@0.3.2 and upgrade webgpu-device.ts to refcounted lifecycle with adapter storage</name>
  <files>
    packages/charts/package.json
    packages/charts/src/shared/webgpu-device.ts
  </files>
  <action>
**Step 1 — Install chartgpu:**

```bash
pnpm add chartgpu@0.3.2 --filter @lit-ui/charts
```

Verify `chartgpu` appears in `packages/charts/package.json` under `"dependencies"` (not devDependencies — it is a runtime dep, dynamically imported but still needs to ship with the package).

**Step 2 — Rewrite webgpu-device.ts with refcounting and adapter storage:**

Replace the entire content of `packages/charts/src/shared/webgpu-device.ts` with the following implementation. Preserve the triple-slash directive (Phase 98 decision), all existing JSDoc comments (updated), and all existing exports. Add two new module-level variables: `_refCount` (number) and `_adapter` (GPUAdapter | null). Add new export `getGpuAdapter()`.

Key behavior changes:
- `acquireGpuDevice(adapter)`: On first call (no cached promise), store `_adapter = adapter` and set `_refCount = 1`. On subsequent calls (promise already cached), increment `_refCount` and return the existing promise WITHOUT calling `adapter.requestDevice()` again (existing behavior preserved). Change signature to `async function` — callers already await it.
- `releaseGpuDevice()`: Change from `void` to `Promise<void>`. Decrement `_refCount` (floor at 0). If `_refCount === 0` and `_devicePromise` is not null, await the device and call `device.destroy()`, then null both `_devicePromise` and `_adapter`. This is now the real teardown.
- `getGpuAdapter()`: New export. Returns `_adapter` (or null if not yet set). Used by Plans 02 and 03 to pass the adapter to `ChartGPU.create()`.

The `_refCount` starts at 0 (module level). `acquireGpuDevice()` sets it to 1 on first call, increments on subsequent calls.

**CRITICAL:** `base-chart-element.ts` calls `await acquireGpuDevice(adapter)` — this call site already awaits, so the async return is backward-compatible. `disconnectedCallback()` in Plans 02 and 03 will call `void releaseGpuDevice()` (async, fire-and-forget from synchronous context — this is correct per the research pattern).

**Do NOT modify base-chart-element.ts in this plan** — its `acquireGpuDevice(adapter)` call already passes the adapter. The adapter is now stored internally in `webgpu-device.ts` on first call.

After writing, verify TypeScript compiles with no errors:
```bash
pnpm --filter @lit-ui/charts exec tsc --noEmit 2>&1 | head -30
```
  </action>
  <verify>
    <automated>
      pnpm --filter @lit-ui/charts exec tsc --noEmit 2>&1 | grep -c "error TS" || echo "0 errors"
    </automated>
  </verify>
  <done>
    - `pnpm add chartgpu@0.3.2` succeeds; `packages/charts/package.json` contains `"chartgpu": "0.3.2"` under dependencies
    - `webgpu-device.ts` exports: `acquireGpuDevice`, `getGpuDevice`, `getGpuAdapter`, `releaseGpuDevice`, `RendererTier`
    - `releaseGpuDevice()` is now `async` and calls `device.destroy()` when refcount reaches 0
    - `getGpuAdapter()` returns the stored `GPUAdapter | null`
    - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
After Task 1:
1. `grep -r "chartgpu" packages/charts/package.json` — should show `"chartgpu": "0.3.2"` in dependencies
2. `grep -n "releaseGpuDevice\|_refCount\|device.destroy\|getGpuAdapter" packages/charts/src/shared/webgpu-device.ts` — should show all four present
3. `pnpm --filter @lit-ui/charts exec tsc --noEmit` — exits 0
</verification>

<success_criteria>
- `chartgpu@0.3.2` is a runtime dependency installed and present in the lock file
- `webgpu-device.ts` has refcounted lifecycle: each `acquireGpuDevice()` call increments refcount; `releaseGpuDevice()` decrements and destroys when zero
- `getGpuAdapter()` is exported and returns the stored `GPUAdapter` from the first `acquireGpuDevice()` call
- Zero TypeScript errors — base-chart-element.ts import compatibility preserved
</success_criteria>

<output>
After completion, create `.planning/phases/101-webgpu-two-layer-canvas-for-line-area/101-01-SUMMARY.md`
</output>
