---
phase: 101-webgpu-two-layer-canvas-for-line-area
plan: 02
type: execute
wave: 2
depends_on: [101-01]
files_modified:
  - packages/charts/src/line/line-chart.ts
autonomous: true
requirements: [WEBGPU-02]

must_haves:
  truths:
    - "LuiLineChart initializes a ChartGPU canvas layer beneath ECharts when this.renderer === 'webgpu'"
    - "ChartGPU canvas is positioned absolutely with z-index:0 and pointer-events:none so ECharts receives all mouse events"
    - "DataZoom interactions sync the ChartGPU zoom range via setZoomRange(start, end)"
    - "Streamed data is pushed to ChartGPU in _flushLineUpdates() alongside the ECharts setOption call"
    - "disconnectedCallback() disposes ChartGPU, disconnects its ResizeObserver, and calls releaseGpuDevice() before super.disconnectedCallback()"
    - "On non-WebGPU browsers the chart renders identically to Phase 100 with no errors"
  artifacts:
    - path: "packages/charts/src/line/line-chart.ts"
      provides: "LuiLineChart with ChartGPU two-layer canvas when WebGPU available"
      contains: "_gpuChart"
      min_lines: 220
  key_links:
    - from: "packages/charts/src/line/line-chart.ts"
      to: "chartgpu (dynamic import)"
      via: "await import('chartgpu') inside _initWebGpuLayer()"
      pattern: "import\\('chartgpu'\\)"
    - from: "packages/charts/src/line/line-chart.ts"
      to: "packages/charts/src/shared/webgpu-device.ts"
      via: "getGpuDevice(), getGpuAdapter(), releaseGpuDevice()"
      pattern: "getGpuDevice|getGpuAdapter|releaseGpuDevice"
    - from: "_flushLineUpdates()"
      to: "_gpuChart.appendData()"
      via: "WebGPU branch inside _flushLineUpdates()"
      pattern: "_gpuChart.*appendData|appendData.*_gpuChart"
---

<objective>
Add ChartGPU two-layer canvas rendering to LuiLineChart — the WebGPU data layer beneath ECharts for 1M+ point GPU-accelerated streaming.

Purpose: On WebGPU-capable browsers, ECharts' canvas rendering path is CPU-bound at high point counts. ChartGPU renders the data pixels directly on the GPU, decoupling rendering cost from point count. ECharts continues to own axes, tooltip, DataZoom, and legend. This satisfies WEBGPU-02 Success Criteria 1–4 for the line chart.

Output: Modified `line-chart.ts` with `_initWebGpuLayer()`, `_syncCoordinates()`, `_gpuResizeObserver`, patched `_flushLineUpdates()`, and patched `disconnectedCallback()`.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/101-webgpu-two-layer-canvas-for-line-area/101-RESEARCH.md
@.planning/phases/101-webgpu-two-layer-canvas-for-line-area/101-01-SUMMARY.md

<interfaces>
<!-- webgpu-device.ts exports after Plan 01 (refcounted, with adapter) -->
From packages/charts/src/shared/webgpu-device.ts:
```typescript
/// <reference types="@webgpu/types" />

export type RendererTier = 'webgpu' | 'webgl' | 'canvas';

export async function acquireGpuDevice(adapter: GPUAdapter): Promise<GPUDevice>;
// Increments refcount; first call stores adapter and creates device

export function getGpuDevice(): Promise<GPUDevice> | null;
// Returns cached Promise<GPUDevice> or null

export function getGpuAdapter(): GPUAdapter | null;
// Returns stored GPUAdapter or null (new in Plan 01)

export async function releaseGpuDevice(): Promise<void>;
// Decrements refcount; calls device.destroy() when refcount === 0 (upgraded in Plan 01)
```

<!-- ChartGPU 0.3.2 API (confirmed from docs/api/chart.md) -->
```typescript
// ChartGPU.create(container, options, context?) → Promise<ChartGPUInstance>
// context: { adapter?: GPUAdapter; device: GPUDevice; pipelineCache?: ... }
// options: { series: [...], autoScroll?: boolean, connectNulls?: boolean }

interface ChartGPUInstance {
  resize(): void;           // Recompute canvas size from container; schedule redraw
  dispose(): void;          // Release GPU buffers/textures, remove canvas; does NOT destroy injected device
  setZoomRange(start: number, end: number): void;  // percent space [0, 100]
  getZoomRange(): { start: number; end: number } | null;
  appendData(points: [number, number][]): void;    // Incremental — adds new points, does not replace
  on(event: string, handler: Function): void;
  off(event: string, handler: Function): void;
}
```

<!-- Current line-chart.ts field inventory (Phase 100 baseline) -->
From packages/charts/src/line/line-chart.ts:
```typescript
// Private fields added in Phase 100:
private _lineBuffers: unknown[][] = [[]];
private _totalPoints = 0;
private _lineRafId?: number;
override maxPoints = 500_000;

// Key methods:
override pushData(point: unknown, seriesIndex = 0): void;       // routes to _lineBuffers
private _flushLineUpdates(): void;   // setOption({series}, {lazyUpdate:true}) — MUST ALSO push to _gpuChart
private _triggerReset(): void;       // dispose+reinit on overflow
override disconnectedCallback(): void;  // cancels _lineRafId then super.disconnectedCallback()
```

<!-- base-chart-element.ts: _initChart() is protected -->
From packages/charts/src/base/base-chart-element.ts:
```typescript
protected async _initChart(): Promise<void>;
// Calls _registerModules(), init(), sets up ResizeObserver, _colorSchemeObserver, calls _applyData()
// Container: this.shadowRoot?.querySelector<HTMLDivElement>('#chart')
// CRITICAL: ECharts binds its own ResizeObserver to the #chart div
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ChartGPU fields, _initWebGpuLayer(), and _initChart() override to LuiLineChart</name>
  <files>packages/charts/src/line/line-chart.ts</files>
  <action>
Add the WebGPU two-layer canvas infrastructure to LuiLineChart. All changes are additive or replace existing private methods — no existing behavior is removed for the non-WebGPU path.

**Import additions** at the top of the file (after existing imports):
```typescript
import {
  getGpuDevice,
  getGpuAdapter,
  releaseGpuDevice,
} from '../shared/webgpu-device.js';
```

**New private fields** (add after `private _lineRafId?: number;`):
```typescript
// WEBGPU-02: ChartGPU instance — null when WebGPU unavailable or before init.
private _gpuChart: import('chartgpu').ChartGPUInstance | null = null;

// WEBGPU-02: Separate ResizeObserver for ChartGPU — the base class observer only calls this._chart.resize().
private _gpuResizeObserver?: ResizeObserver;

// WEBGPU-02: Flag set to true when WebGPU path was active — used to gate releaseGpuDevice() in cleanup.
private _wasWebGpu = false;
```

Note on the `import('chartgpu').ChartGPUInstance` type: use a type-only dynamic import for the field type. Since ChartGPU only ships a CJS type, the safest approach is to type the field as `unknown` and cast on use if the import type isn't available, OR define a minimal local interface:
```typescript
// Minimal ChartGPU instance interface — avoids hard dependency on chartgpu types at module scope.
// Full type is inferred at runtime from await import('chartgpu').
interface _GpuChartInstance {
  resize(): void;
  dispose(): void;
  setZoomRange(start: number, end: number): void;
  appendData(points: [number, number][]): void;
}

private _gpuChart: _GpuChartInstance | null = null;
```

**Override `_initChart()`** — add after the existing field declarations:
```typescript
protected override async _initChart(): Promise<void> {
  // 1. Standard ECharts init (registers modules, builds theme, sets up ResizeObserver).
  await super._initChart();

  // 2. If WebGPU was detected, layer ChartGPU beneath ECharts canvas.
  if (this.renderer === 'webgpu') {
    await this._initWebGpuLayer();
  }
}
```

**Add `_initWebGpuLayer()` private method:**
```typescript
private async _initWebGpuLayer(): Promise<void> {
  const devicePromise = getGpuDevice();
  if (!devicePromise) return; // guard — renderer === 'webgpu' implies device exists

  const device = await devicePromise;
  const adapter = getGpuAdapter(); // may be null for injected-device-only case; ChartGPU accepts device-only

  // Dynamic import — NEVER at module top level (SSR + tree-shaking constraint).
  // Same pattern as echarts-gl import in base-chart-element.ts.
  const { ChartGPU } = await import('chartgpu');

  const container = this.shadowRoot?.querySelector<HTMLDivElement>('#chart');
  if (!container) return;

  // Insert a host div for ChartGPU BEFORE ECharts' canvas elements.
  // z-index:0 keeps ChartGPU below ECharts (which renders at default stacking order above 0).
  // pointer-events:none is CRITICAL — ECharts must receive all mouse events for tooltip + DataZoom.
  const gpuHost = document.createElement('div');
  gpuHost.style.cssText =
    'position:absolute;inset:0;width:100%;height:100%;z-index:0;pointer-events:none;';
  container.insertBefore(gpuHost, container.firstChild);

  // WEBGPU-03: Pass the Phase 98 singleton device — ChartGPU will NOT destroy it on dispose().
  // adapter is passed for completeness; ChartGPU accepts device-only if adapter is null.
  const context: Record<string, unknown> = { device };
  if (adapter) context['adapter'] = adapter;

  this._gpuChart = await ChartGPU.create(
    gpuHost,
    {
      series: [{ type: 'line', data: [] }],
      // Do NOT set renderMode:'external' — let ChartGPU own its RAF loop.
      // (Research Pitfall 7: external mode requires manual renderFrame() calls; not needed for Phase 101.)
    },
    context as { device: GPUDevice }
  ) as _GpuChartInstance;

  this._wasWebGpu = true;

  // ChartGPU needs its own resize tracking — the base class ResizeObserver only calls this._chart.resize().
  this._gpuResizeObserver = new ResizeObserver(() => this._gpuChart?.resize());
  this._gpuResizeObserver.observe(container);

  // Wire coordinate sync — fires on every DataZoom and after each layout paint.
  this._chart!.on('dataZoom', () => this._syncCoordinates());
  this._chart!.on('rendered', () => this._syncCoordinates());
}
```

**Add `_syncCoordinates()` private method** (ECharts dataZoom percent → ChartGPU zoom range):
```typescript
private _syncCoordinates(): void {
  if (!this._chart || !this._gpuChart) return;

  // DataZoom percent-space [0, 100] — same space ChartGPU.setZoomRange() uses.
  const option = this._chart.getOption() as Record<string, unknown>;
  const dataZoom = (option['dataZoom'] as Array<Record<string, unknown>> | undefined)?.[0];
  if (!dataZoom) return;

  const start = (dataZoom['start'] as number) ?? 0;
  const end = (dataZoom['end'] as number) ?? 100;

  // Guard against NaN — can occur before first setOption initializes coordinate system.
  if (isNaN(start) || isNaN(end)) return;

  this._gpuChart.setZoomRange(start, end);
}
```

**Verify TypeScript compiles:**
```bash
pnpm --filter @lit-ui/charts exec tsc --noEmit 2>&1 | head -30
```

If TypeScript cannot resolve `import('chartgpu').ChartGPUInstance` (the package may not ship a named type), use the local `_GpuChartInstance` interface pattern instead (defined above).
  </action>
  <verify>
    <automated>pnpm --filter @lit-ui/charts exec tsc --noEmit 2>&1 | grep -c "error TS" || echo "0 errors"</automated>
  </verify>
  <done>
    - `line-chart.ts` has `_gpuChart`, `_gpuResizeObserver`, `_wasWebGpu` fields
    - `_initChart()` override calls `super._initChart()` then conditionally calls `_initWebGpuLayer()`
    - `_initWebGpuLayer()` does: `getGpuDevice()` + `getGpuAdapter()` → dynamic `import('chartgpu')` → creates `gpuHost` div with correct CSS → `ChartGPU.create(gpuHost, opts, { device })` → wires `dataZoom` + `rendered` handlers → `_gpuResizeObserver`
    - `_syncCoordinates()` reads `dataZoom[0].start/end` from ECharts option and calls `_gpuChart.setZoomRange()`
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Patch _flushLineUpdates() to push data to ChartGPU and update disconnectedCallback() for full cleanup</name>
  <files>packages/charts/src/line/line-chart.ts</files>
  <action>
**Patch `_flushLineUpdates()` to also push data to ChartGPU when active:**

The existing `_flushLineUpdates()` only calls `this._chart.setOption()`. Add a WebGPU branch that pushes the same data to `_gpuChart` via `appendData()`.

CRITICAL QUESTION from RESEARCH.md Open Question 1: Does ChartGPU `appendData()` accept cumulative (full buffer) or incremental (new points only)?

Research recommendation: treat it as INCREMENTAL (accumulates internally, same as ECharts' old appendData path). This means each flush should pass ONLY the new points accumulated since the last flush — not the full `_lineBuffers` contents.

To implement incremental push, track the last-flushed index per series with a new field:
```typescript
// WEBGPU-02: Tracks the last flushed buffer length per series — enables incremental ChartGPU pushes.
private _gpuFlushedLengths: number[] = [];
```

Then in `_flushLineUpdates()`, after the existing ECharts `setOption` call, add:
```typescript
// WEBGPU-02: Push new points to ChartGPU data layer (incremental — not full buffer replacement).
if (this._gpuChart) {
  this._lineBuffers.slice(0, seriesCount).forEach((buf, idx) => {
    const lastFlushed = this._gpuFlushedLengths[idx] ?? 0;
    const newPoints = buf.slice(lastFlushed) as number[];
    if (newPoints.length > 0) {
      // ChartGPU appendData expects [number, number][] — [index, value] pairs.
      // Line/area buffers hold y-values only (x is position index).
      const startIdx = lastFlushed;
      const pairs = newPoints.map((v, i) => [startIdx + i, v] as [number, number]);
      this._gpuChart!.appendData(pairs);
      this._gpuFlushedLengths[idx] = buf.length;
    }
  });
}
```

If testing reveals ChartGPU's `appendData()` is full-replacement (not incremental), simplify the flush to pass the full buffer directly without the index tracking — remove `_gpuFlushedLengths` and pass `_lineBuffers` data converted to `[index, value]` pairs directly. Document which behavior was found in the SUMMARY.

Also reset `_gpuFlushedLengths` in `_triggerReset()`:
```typescript
// After clearing _lineBuffers, add:
this._gpuFlushedLengths = [];
```

**Replace `disconnectedCallback()` with full WebGPU-aware cleanup:**

The current `disconnectedCallback()` only cancels `_lineRafId` then calls `super.disconnectedCallback()`. Replace with the full cleanup sequence from RESEARCH.md Pattern cleanup ordering (Pitfall 5 — reverse-init order):

```typescript
override disconnectedCallback(): void {
  // 1. Cancel streaming RAF — no flushes after teardown starts.
  if (this._lineRafId !== undefined) {
    cancelAnimationFrame(this._lineRafId);
    this._lineRafId = undefined;
  }

  // 2. WEBGPU-02: Disconnect ChartGPU's resize observer before disposing.
  this._gpuResizeObserver?.disconnect();
  this._gpuResizeObserver = undefined;

  // 3. WEBGPU-02: Dispose ChartGPU — releases GPU buffers + removes canvas.
  //    Does NOT destroy the injected GPUDevice (WEBGPU-03: singleton owned by webgpu-device.ts).
  this._gpuChart?.dispose();
  this._gpuChart = null;

  // 4. WEBGPU-02: Release refcount — device.destroy() fires when last chart disconnects.
  //    void cast: releaseGpuDevice() is async; disconnectedCallback() is sync.
  if (this._wasWebGpu) {
    void releaseGpuDevice();
  }

  // 5. ECharts cleanup (base class) — disposes chart, disconnects ResizeObserver/MutationObserver.
  //    Must be LAST — base class references this._chart which ChartGPU event listeners may hold.
  super.disconnectedCallback();
}
```

**Verify final TypeScript compilation:**
```bash
pnpm --filter @lit-ui/charts exec tsc --noEmit 2>&1 | head -30
```
  </action>
  <verify>
    <automated>pnpm --filter @lit-ui/charts exec tsc --noEmit 2>&1 | grep -c "error TS" || echo "0 errors"</automated>
  </verify>
  <done>
    - `_flushLineUpdates()` pushes new points to `_gpuChart.appendData()` as `[index, value]` pairs when `_gpuChart` is non-null
    - `_gpuFlushedLengths[]` tracks last-flushed buffer length per series; reset to `[]` in `_triggerReset()`
    - `disconnectedCallback()` follows reverse-init order: cancel RAF → disconnect gpuResizeObserver → dispose _gpuChart → releaseGpuDevice() if _wasWebGpu → super.disconnectedCallback()
    - TypeScript compiles without errors
    - Non-WebGPU path unchanged: `if (this._gpuChart)` guards all WebGPU branches
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `grep -n "_gpuChart\|_initWebGpuLayer\|_syncCoordinates\|_gpuResizeObserver\|_wasWebGpu\|_gpuFlushedLengths" packages/charts/src/line/line-chart.ts` — all six identifiers present
2. `grep -n "releaseGpuDevice\|getGpuDevice\|getGpuAdapter" packages/charts/src/line/line-chart.ts` — all three imports present
3. `grep -n "import('chartgpu')" packages/charts/src/line/line-chart.ts` — dynamic import present (not top-level)
4. `pnpm --filter @lit-ui/charts exec tsc --noEmit` — exits 0
5. `grep -n "pointer-events:none" packages/charts/src/line/line-chart.ts` — present on gpuHost CSS
</verification>

<success_criteria>
- LuiLineChart conditionally initializes ChartGPU only when `this.renderer === 'webgpu'`
- ChartGPU host div positioned with `z-index:0` and `pointer-events:none`
- DataZoom events trigger `_syncCoordinates()` → `_gpuChart.setZoomRange(start, end)`
- `_flushLineUpdates()` sends incremental `[index, value]` pairs to `_gpuChart.appendData()` alongside ECharts `setOption`
- `disconnectedCallback()` performs full reverse-init cleanup including `releaseGpuDevice()`
- Zero TypeScript errors; non-WebGPU path unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/101-webgpu-two-layer-canvas-for-line-area/101-02-SUMMARY.md`
</output>
