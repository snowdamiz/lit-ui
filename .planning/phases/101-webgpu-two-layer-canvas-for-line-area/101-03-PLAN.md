---
phase: 101-webgpu-two-layer-canvas-for-line-area
plan: 03
type: execute
wave: 3
depends_on: [101-01, 101-02]
files_modified:
  - packages/charts/src/area/area-chart.ts
autonomous: true
requirements: [WEBGPU-02]

must_haves:
  truths:
    - "LuiAreaChart initializes a ChartGPU canvas layer beneath ECharts when this.renderer === 'webgpu'"
    - "ChartGPU canvas is positioned absolutely with z-index:0 and pointer-events:none"
    - "DataZoom interactions sync the ChartGPU zoom range via setZoomRange(start, end)"
    - "Streamed data is pushed to ChartGPU in _flushLineUpdates() alongside the ECharts setOption call"
    - "disconnectedCallback() disposes ChartGPU, disconnects its ResizeObserver, and calls releaseGpuDevice() before super.disconnectedCallback()"
    - "On non-WebGPU browsers the chart renders identically to Phase 100 with no errors"
  artifacts:
    - path: "packages/charts/src/area/area-chart.ts"
      provides: "LuiAreaChart with ChartGPU two-layer canvas when WebGPU available"
      contains: "_gpuChart"
      min_lines: 220
  key_links:
    - from: "packages/charts/src/area/area-chart.ts"
      to: "chartgpu (dynamic import)"
      via: "await import('chartgpu') inside _initWebGpuLayer()"
      pattern: "import\\('chartgpu'\\)"
    - from: "packages/charts/src/area/area-chart.ts"
      to: "packages/charts/src/shared/webgpu-device.ts"
      via: "getGpuDevice(), getGpuAdapter(), releaseGpuDevice()"
      pattern: "getGpuDevice|getGpuAdapter|releaseGpuDevice"
    - from: "_flushLineUpdates()"
      to: "_gpuChart.appendData()"
      via: "WebGPU branch inside _flushLineUpdates()"
      pattern: "_gpuChart.*appendData|appendData.*_gpuChart"
---

<objective>
Apply the identical ChartGPU two-layer canvas pattern from Plan 02 (LuiLineChart) to LuiAreaChart.

Purpose: LuiAreaChart uses the same ring-buffer streaming infrastructure as LuiLineChart (identical `_lineBuffers`, `_lineRafId`, `_flushLineUpdates()` pattern — per STATE.md: "Area chart streaming uses identical pattern to line chart"). The WebGPU integration is therefore also identical. This plan follows the Phase 100 duplication pattern (same as 100-02 for line and 100-03 for area) to keep both charts at feature parity.

Output: Modified `area-chart.ts` with the same WebGPU fields and methods as `line-chart.ts` from Plan 02.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/101-webgpu-two-layer-canvas-for-line-area/101-RESEARCH.md
@.planning/phases/101-webgpu-two-layer-canvas-for-line-area/101-01-SUMMARY.md
@.planning/phases/101-webgpu-two-layer-canvas-for-line-area/101-02-SUMMARY.md

<interfaces>
<!-- webgpu-device.ts exports after Plan 01 -->
From packages/charts/src/shared/webgpu-device.ts:
```typescript
export async function acquireGpuDevice(adapter: GPUAdapter): Promise<GPUDevice>;
export function getGpuDevice(): Promise<GPUDevice> | null;
export function getGpuAdapter(): GPUAdapter | null;
export async function releaseGpuDevice(): Promise<void>;
export type RendererTier = 'webgpu' | 'webgl' | 'canvas';
```

<!-- ChartGPU 0.3.2 API -->
```typescript
interface _GpuChartInstance {
  resize(): void;
  dispose(): void;
  setZoomRange(start: number, end: number): void;
  appendData(points: [number, number][]): void;
}
// ChartGPU.create(container, options, context?) → Promise<_GpuChartInstance>
// context: { adapter?: GPUAdapter; device: GPUDevice }
```

<!-- area-chart.ts field inventory (Phase 100 baseline) — IDENTICAL structure to line-chart.ts -->
From packages/charts/src/area/area-chart.ts:
```typescript
private _lineBuffers: unknown[][] = [[]];   // same name as line-chart.ts
private _totalPoints = 0;
private _lineRafId?: number;
override maxPoints = 500_000;

// Methods with identical signatures to line-chart.ts:
override pushData(point: unknown, seriesIndex = 0): void;
private _flushLineUpdates(): void;     // setOption({series}, {lazyUpdate:true})
private _triggerReset(): void;
override disconnectedCallback(): void;
```

<!-- Plan 02 WebGPU pattern (read 101-02-SUMMARY.md for exact implementation) -->
<!-- All field names, method signatures, and cleanup ordering are identical to Plan 02. -->
<!-- The only differences from line-chart.ts:
     - LuiAreaChart has additional properties: stacked, labelPosition
     - _applyData() calls buildLineOption(..., 'area') instead of 'line'
     - These differences do NOT affect WebGPU layer integration -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apply identical ChartGPU two-layer canvas pattern to LuiAreaChart</name>
  <files>packages/charts/src/area/area-chart.ts</files>
  <action>
Apply the **exact same** WebGPU two-layer canvas integration to `area-chart.ts` as was applied to `line-chart.ts` in Plan 02. Read `101-02-SUMMARY.md` first to get the exact implementation decisions made — especially:
- Whether `_GpuChartInstance` local interface was used or `import('chartgpu').ChartGPUInstance`
- Whether `appendData()` was confirmed as incremental or full-replacement (Open Question 1 from RESEARCH.md)
- Exact CSS text used for `gpuHost.style.cssText`

The implementation is **point-for-point identical** to Plan 02 with these minimal differences:
1. Class name is `LuiAreaChart` (not `LuiLineChart`)
2. Existing properties differ (`stacked`, `labelPosition` instead of `smooth`, `zoom`, `markLines`) — these are unaffected by WebGPU integration
3. `_applyData()` calls `buildLineOption(..., 'area')` — unchanged

**Steps:**

1. **Add imports** — same as Plan 02:
```typescript
import {
  getGpuDevice,
  getGpuAdapter,
  releaseGpuDevice,
} from '../shared/webgpu-device.js';
```

2. **Add local interface** — copy from Plan 02:
```typescript
interface _GpuChartInstance {
  resize(): void;
  dispose(): void;
  setZoomRange(start: number, end: number): void;
  appendData(points: [number, number][]): void;
}
```

3. **Add new private fields** (after `private _lineRafId?: number;`):
```typescript
private _gpuChart: _GpuChartInstance | null = null;
private _gpuResizeObserver?: ResizeObserver;
private _wasWebGpu = false;
private _gpuFlushedLengths: number[] = [];
```

4. **Add `_initChart()` override** — identical to Plan 02:
```typescript
protected override async _initChart(): Promise<void> {
  await super._initChart();
  if (this.renderer === 'webgpu') {
    await this._initWebGpuLayer();
  }
}
```

5. **Add `_initWebGpuLayer()` private method** — identical to Plan 02.

6. **Add `_syncCoordinates()` private method** — identical to Plan 02.

7. **Patch `_flushLineUpdates()`** — add the same `if (this._gpuChart)` incremental appendData branch after the ECharts `setOption` call. Use the same `_gpuFlushedLengths` tracking approach as Plan 02.

8. **Patch `_triggerReset()`** — add `this._gpuFlushedLengths = [];` after `this._lineBuffers = this._lineBuffers.map(() => []);`.

9. **Replace `disconnectedCallback()`** — identical reverse-init order to Plan 02:
   1. Cancel `_lineRafId`
   2. Disconnect `_gpuResizeObserver`
   3. Dispose `_gpuChart`
   4. `void releaseGpuDevice()` if `_wasWebGpu`
   5. `super.disconnectedCallback()`

After completing all changes, verify:
```bash
pnpm --filter @lit-ui/charts exec tsc --noEmit 2>&1 | head -30
```

**Key constraint from RESEARCH.md Pattern 4:** The dynamic `import('chartgpu')` must ONLY appear inside `_initWebGpuLayer()` — never at the module top level. Verify with:
```bash
grep -n "^import.*chartgpu\|from 'chartgpu'" packages/charts/src/area/area-chart.ts
```
This should return nothing — the import is dynamic (`await import('chartgpu')`).
  </action>
  <verify>
    <automated>pnpm --filter @lit-ui/charts exec tsc --noEmit 2>&1 | grep -c "error TS" || echo "0 errors"</automated>
  </verify>
  <done>
    - `area-chart.ts` has `_gpuChart`, `_gpuResizeObserver`, `_wasWebGpu`, `_gpuFlushedLengths` fields
    - `_initChart()` override calls `super._initChart()` then conditionally `_initWebGpuLayer()`
    - `_flushLineUpdates()` sends incremental `[index, value]` pairs to `_gpuChart.appendData()` when `_gpuChart` is non-null
    - `disconnectedCallback()` follows reverse-init cleanup order with `releaseGpuDevice()` before `super.disconnectedCallback()`
    - No static `import from 'chartgpu'` at module top level
    - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
After task completes:
1. `grep -n "_gpuChart\|_initWebGpuLayer\|_syncCoordinates\|_gpuResizeObserver\|_wasWebGpu\|_gpuFlushedLengths" packages/charts/src/area/area-chart.ts` — all six identifiers present
2. `grep -n "releaseGpuDevice\|getGpuDevice\|getGpuAdapter" packages/charts/src/area/area-chart.ts` — all three imports present
3. `grep -n "import('chartgpu')" packages/charts/src/area/area-chart.ts` — dynamic import present
4. `grep -n "^import.*chartgpu" packages/charts/src/area/area-chart.ts` — returns nothing (no static import)
5. `pnpm --filter @lit-ui/charts exec tsc --noEmit` — exits 0
6. `diff <(grep -n "private _gpu\|_initWebGpuLayer\|_syncCoordinates\|releaseGpuDevice" packages/charts/src/line/line-chart.ts) <(grep -n "private _gpu\|_initWebGpuLayer\|_syncCoordinates\|releaseGpuDevice" packages/charts/src/area/area-chart.ts)` — structural parity (field names match)
</verification>

<success_criteria>
- LuiAreaChart has identical WebGPU two-layer canvas integration as LuiLineChart from Plan 02
- Both charts satisfy WEBGPU-02 Success Criteria 1–4 for their respective types
- Zero TypeScript errors in either chart file
- No static chartgpu import at module top level — dynamic import only
- Non-WebGPU path unchanged: all WebGPU branches gated by `if (this._gpuChart)` or `if (this.renderer === 'webgpu')`
</success_criteria>

<output>
After completion, create `.planning/phases/101-webgpu-two-layer-canvas-for-line-area/101-03-SUMMARY.md`
</output>
