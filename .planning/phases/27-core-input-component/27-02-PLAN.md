---
phase: 27-core-input-component
plan: 02
type: execute
wave: 2
depends_on: ["27-01"]
files_modified:
  - packages/input/src/input.ts
  - packages/input/src/jsx.d.ts
autonomous: true

must_haves:
  truths:
    - "User sees focus state (border color change) when input is focused via keyboard"
    - "User sees disabled input with muted styling and cannot interact"
    - "User sees readonly input with distinct styling and can select/copy text"
    - "User sees error border when input is invalid after blur"
    - "User sees placeholder text in empty input"
    - "User sees label above input when label prop is provided"
    - "User sees error message below input when validation fails"
    - "Form submission is blocked with browser validation error when required field is empty"
  artifacts:
    - path: "packages/input/src/input.ts"
      provides: "Complete Input component with all states and validation"
      min_lines: 250
      contains: "setValidity"
  key_links:
    - from: "packages/input/src/input.ts"
      to: "ElementInternals.setValidity"
      via: "validation method"
      pattern: "setValidity\\("
    - from: "packages/input/src/input.ts"
      to: "native input validity"
      via: "validity state mirroring"
      pattern: "input\\.validity"
---

<objective>
Complete the Input component with all visual states (focus, disabled, readonly, error), comprehensive validation (required, minlength/maxlength, pattern, email, number min/max), and UX features (label, helper text, error display, placeholder).

Purpose: Deliver a fully functional input component that matches native input behavior with enhanced styling and accessibility.

Output: Production-ready lui-input element with complete form validation and visual feedback.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/27-core-input-component/27-CONTEXT.md
@.planning/phases/27-core-input-component/27-RESEARCH.md
@.planning/phases/27-core-input-component/27-01-SUMMARY.md

# Component to extend
@packages/input/src/input.ts
@packages/input/src/jsx.d.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add visual states (focus, disabled, readonly, error) and placeholder</name>
  <files>
    packages/input/src/input.ts
  </files>
  <action>
Extend the Input component from Plan 01 with visual state styling and props.

**Add properties:**
```typescript
@property({ type: String }) placeholder = '';
@property({ type: Boolean, reflect: true }) disabled = false;
@property({ type: Boolean, reflect: true }) readonly = false;

@state() private touched = false;
@state() private showError = false;
```

**Update static styles** - Add after existing size styles:

```css
/* Host states */
:host([disabled]) {
  pointer-events: none;
}

/* Focus state - per CONTEXT.md: border color change, no outer ring */
input:focus-visible {
  outline: none;
  border-color: var(--ui-input-border-focus);
}

/* Error state */
input.input-error {
  border-color: var(--ui-input-border-error);
}

/* Disabled state */
input:disabled {
  background-color: var(--ui-input-bg-disabled);
  color: var(--ui-input-text-disabled);
  border-color: var(--ui-input-border-disabled);
  cursor: not-allowed;
}

/* Readonly state - per CONTEXT.md: distinct from disabled */
input:read-only:not(:disabled) {
  background-color: var(--ui-input-bg-readonly, var(--color-muted));
  cursor: text;
}

/* Placeholder styling */
input::placeholder {
  color: var(--ui-input-placeholder);
}
```

**Update getInputClasses():**
```typescript
private getInputClasses(): string {
  const classes = [
    'input-base',
    `input-${this.size}`,
  ];
  if (this.showError) {
    classes.push('input-error');
  }
  return classes.join(' ');
}
```

**Update render() input element** to include new attributes:
```typescript
<input
  ...existing attributes...
  placeholder=${this.placeholder || nothing}
  ?disabled=${this.disabled}
  ?readonly=${this.readonly}
  @blur=${this.handleBlur}
/>
```

**Add handleBlur method:**
```typescript
private handleBlur() {
  this.touched = true;
  // Validation will be added in Task 2
}
```
  </action>
  <verify>
```bash
# Check for state-related code
grep -E "(disabled|readonly|placeholder|focus-visible|input-error)" packages/input/src/input.ts
grep "@state()" packages/input/src/input.ts
```
  </verify>
  <done>Visual states (focus, disabled, readonly, error) and placeholder implemented</done>
</task>

<task type="auto">
  <name>Task 2: Implement validation logic with ElementInternals</name>
  <files>
    packages/input/src/input.ts
  </files>
  <action>
Add comprehensive validation following RESEARCH.md patterns.

**Add validation-related properties:**
```typescript
@property({ type: Boolean, reflect: true }) required = false;
@property({ type: Number }) minlength?: number;
@property({ type: Number }) maxlength?: number;
@property({ type: String }) pattern = '';
@property({ type: Number }) min?: number;
@property({ type: Number }) max?: number;
```

**Implement validate() method** - Mirror native input validity to ElementInternals:
```typescript
private validate(): boolean {
  const input = this.inputEl;
  if (!input || !this.internals) return true;

  const validity = input.validity;

  if (!validity.valid) {
    // Map native validity to ElementInternals
    this.internals.setValidity(
      {
        valueMissing: validity.valueMissing,
        typeMismatch: validity.typeMismatch,
        patternMismatch: validity.patternMismatch,
        tooShort: validity.tooShort,
        tooLong: validity.tooLong,
        rangeUnderflow: validity.rangeUnderflow,
        rangeOverflow: validity.rangeOverflow,
      },
      input.validationMessage,
      input // anchor for popup positioning
    );
    return false;
  }

  // Clear validity when valid
  this.internals.setValidity({});
  return true;
}
```

**Update handleBlur():**
```typescript
private handleBlur() {
  this.touched = true;
  const isValid = this.validate();
  this.showError = !isValid;
}
```

**Update handleInput():**
```typescript
private handleInput(e: Event) {
  const input = e.target as HTMLInputElement;
  this.value = input.value;
  this.updateFormValue();

  // Re-validate if already touched (blur occurred)
  if (this.touched) {
    const isValid = this.validate();
    this.showError = !isValid;
  }
}
```

**Add form lifecycle callbacks:**
```typescript
formResetCallback() {
  this.value = '';
  this.touched = false;
  this.showError = false;
  this.internals?.setFormValue('');
  this.internals?.setValidity({});
}

formDisabledCallback(disabled: boolean) {
  this.disabled = disabled;
}
```

**Add getter for validation message:**
```typescript
private get errorMessage(): string {
  return this.internals?.validationMessage || '';
}
```

**Update render() input element** with validation attributes:
```typescript
<input
  ...existing attributes...
  ?required=${this.required}
  minlength=${this.minlength ?? nothing}
  maxlength=${this.maxlength ?? nothing}
  min=${this.min ?? nothing}
  max=${this.max ?? nothing}
  pattern=${this.pattern || nothing}
  aria-invalid=${this.showError ? 'true' : nothing}
/>
```
  </action>
  <verify>
```bash
# Check validation implementation
grep "setValidity" packages/input/src/input.ts
grep "formResetCallback" packages/input/src/input.ts
grep "validate()" packages/input/src/input.ts
grep -E "(required|minlength|maxlength|pattern|min|max)" packages/input/src/input.ts | head -10
```
  </verify>
  <done>Validation logic with ElementInternals setValidity() implemented</done>
</task>

<task type="auto">
  <name>Task 3: Add label, helper text, error display, and update JSX types</name>
  <files>
    packages/input/src/input.ts
    packages/input/src/jsx.d.ts
  </files>
  <action>
**Add label/helper properties to input.ts:**
```typescript
@property({ type: String }) label = '';
@property({ type: String, attribute: 'helper-text' }) helperText = '';
@property({ type: String, attribute: 'required-indicator' }) requiredIndicator: 'asterisk' | 'text' = 'asterisk';
```

**Add label/helper/error styles** to static styles:
```css
/* Wrapper for label structure */
.input-wrapper {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

/* Label styling - scales with size */
.input-label {
  font-weight: 500;
  color: var(--ui-input-text);
}

.input-label.label-sm { font-size: var(--ui-input-font-size-sm); }
.input-label.label-md { font-size: var(--ui-input-font-size-md); }
.input-label.label-lg { font-size: var(--ui-input-font-size-lg); }

.required-indicator {
  color: var(--ui-input-text-error);
  margin-left: 0.125rem;
}

/* Helper text - below label, above input */
.helper-text {
  font-size: 0.875em;
  color: var(--color-muted-foreground);
}

/* Error text - below input */
.error-text {
  font-size: 0.875em;
  color: var(--ui-input-text-error);
}
```

**Update render() method** with complete structure per CONTEXT.md:
```typescript
render() {
  return html`
    <div class="input-wrapper" part="wrapper">
      ${this.label ? html`
        <label for=${this.inputId} part="label" class="input-label label-${this.size}">
          ${this.label}
          ${this.required ? html`<span class="required-indicator">${this.requiredIndicator === 'text' ? ' (required)' : '*'}</span>` : nothing}
        </label>
      ` : nothing}

      ${this.helperText ? html`
        <span part="helper" class="helper-text">${this.helperText}</span>
      ` : nothing}

      <input
        id=${this.inputId}
        part="input"
        class=${this.getInputClasses()}
        type=${this.type}
        name=${this.name}
        .value=${this.value}
        placeholder=${this.placeholder || nothing}
        ?required=${this.required}
        ?disabled=${this.disabled}
        ?readonly=${this.readonly}
        minlength=${this.minlength ?? nothing}
        maxlength=${this.maxlength ?? nothing}
        min=${this.min ?? nothing}
        max=${this.max ?? nothing}
        pattern=${this.pattern || nothing}
        aria-invalid=${this.showError ? 'true' : nothing}
        aria-describedby=${this.showError ? `${this.inputId}-error` : (this.helperText ? `${this.inputId}-helper` : nothing)}
        @input=${this.handleInput}
        @blur=${this.handleBlur}
      />

      ${this.showError && this.errorMessage ? html`
        <span id="${this.inputId}-error" part="error" class="error-text" role="alert">
          ${this.errorMessage}
        </span>
      ` : nothing}
    </div>
  `;
}
```

Note: Also add id to helper text element:
```typescript
${this.helperText ? html`
  <span id="${this.inputId}-helper" part="helper" class="helper-text">${this.helperText}</span>
` : nothing}
```

**Update jsx.d.ts** with all props:
```typescript
interface LuiInputAttributes {
  type?: InputType;
  size?: InputSize;
  name?: string;
  value?: string;
  placeholder?: string;
  label?: string;
  'helper-text'?: string;
  'required-indicator'?: 'asterisk' | 'text';
  required?: boolean;
  disabled?: boolean;
  readonly?: boolean;
  minlength?: number;
  maxlength?: number;
  min?: number;
  max?: number;
  pattern?: string;
}
```
  </action>
  <verify>
```bash
# Check label and helper implementation
grep -E "(label|helper|error-text|required-indicator)" packages/input/src/input.ts | head -15
grep "aria-describedby" packages/input/src/input.ts

# Check JSX types updated
grep -E "(required|disabled|label|helper-text)" packages/input/src/jsx.d.ts
```
  </verify>
  <done>Label, helper text, error display complete; JSX types updated</done>
</task>

</tasks>

<verification>
After all tasks:

```bash
# Rebuild the package
cd packages/input && pnpm build

# Type check
cd packages/input && pnpm tsc --noEmit

# Verify all requirements covered
grep -c "setValidity" packages/input/src/input.ts  # Should be > 0
grep -c "required" packages/input/src/input.ts      # Should be > 0
grep -c "minlength" packages/input/src/input.ts     # Should be > 0
grep -c "pattern" packages/input/src/input.ts       # Should be > 0
grep -c "focus-visible" packages/input/src/input.ts # Should be > 0
grep -c "disabled" packages/input/src/input.ts      # Should be > 0
```

**Manual verification hint (for verification phase):**
Test in docs app or browser console:
```javascript
// Create test form
document.body.innerHTML = `
  <form id="test">
    <lui-input name="email" type="email" label="Email" required></lui-input>
    <button type="submit">Submit</button>
  </form>
`;

// Should show validation error on submit with empty field
document.querySelector('form').addEventListener('submit', e => {
  e.preventDefault();
  console.log(new FormData(e.target));
});
```
</verification>

<success_criteria>
**Visual States:**
1. Focus shows border color change (var(--ui-input-border-focus)), no outer ring
2. Disabled shows muted background, disabled cursor, pointer-events: none
3. Readonly shows distinct background, text cursor (selectable text)
4. Error shows red border (var(--ui-input-border-error))

**Validation (INPUT-05 through INPUT-09):**
5. Required field validation blocks form submission, shows browser error
6. minlength/maxlength validation works
7. Pattern validation works
8. Email type validation works (typeMismatch)
9. Number min/max validation works (rangeUnderflow/rangeOverflow)

**UX Features:**
10. Placeholder text displays in empty input
11. Label renders above input with for/id association
12. Helper text renders between label and input
13. Required indicator shows (* or "(required)")
14. Error message renders below input when invalid

**Accessibility:**
15. aria-invalid set when showError is true
16. aria-describedby links to error or helper text
17. Error message has role="alert"
</success_criteria>

<output>
After completion, create `.planning/phases/27-core-input-component/27-02-SUMMARY.md`
</output>
