---
phase: 35-combobox
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/select/src/select.ts
autonomous: true

must_haves:
  truths:
    - "User clicks searchable select and sees text input instead of display text"
    - "User types in searchable select and options filter to matching items"
    - "User uses arrow keys in searchable mode and options navigate correctly"
    - "Screen reader announces combobox with autocomplete list behavior"
  artifacts:
    - path: "packages/select/src/select.ts"
      provides: "Searchable mode with filtering"
      contains: "searchable"
  key_links:
    - from: "packages/select/src/select.ts"
      to: "filterQuery state"
      via: "input event handler"
      pattern: "filterQuery"
    - from: "packages/select/src/select.ts"
      to: "effectiveOptions"
      via: "filteredOptions getter"
      pattern: "filteredOptions"
---

<objective>
Add searchable prop to Select that transforms the trigger into a text input with filtering capability.

Purpose: Enable users to type and filter through options in large lists, improving UX for selects with many options.
Output: Working searchable select with case-insensitive contains filtering, proper ARIA attributes, and keyboard navigation that works with text input.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-combobox/35-CONTEXT.md
@.planning/phases/35-combobox/35-RESEARCH.md
@packages/select/src/select.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add searchable prop and filter state</name>
  <files>packages/select/src/select.ts</files>
  <action>
Add searchable mode foundation to Select component:

1. Add new properties:
   - `searchable: boolean = false` - enables text input mode
   - Add state: `filterQuery: string = ''` - current filter text

2. Add `filteredOptions` getter that filters `effectiveOptions`:
   - When `searchable` is false or `filterQuery` is empty, return all options
   - When filtering: case-insensitive contains matching on label (or value if no label)
   - Example: "app" matches "Apple", "Pineapple", "application"

3. Update all references to `effectiveOptions` in keyboard navigation and rendering to use `filteredOptions` instead when in searchable mode:
   - `focusFirstEnabledOption`, `focusLastEnabledOption`, etc.
   - `selectOption` - need to map filtered index back to original index
   - `renderOption` loop
   - Option count for ARIA

4. Add `applyFilter(query: string)` method:
   - Sets `filterQuery = query`
   - Auto-opens dropdown if not open and query is not empty
   - Resets `activeIndex` to 0 (first filtered option) or -1 if no matches
   - Calls `requestUpdate()`

Important: Store the original option index in a Map or use a wrapper object so we can map filtered indices back to original indices for selection.
  </action>
  <verify>TypeScript compiles without errors: `cd packages/select && pnpm build`</verify>
  <done>Select has searchable prop, filterQuery state, and filteredOptions getter that correctly filters options by case-insensitive contains matching</done>
</task>

<task type="auto">
  <name>Task 2: Transform trigger to input in searchable mode</name>
  <files>packages/select/src/select.ts</files>
  <action>
Modify the trigger rendering for searchable mode:

1. Create `renderSearchableTrigger()` method that returns:
```typescript
html`
  <input
    type="text"
    id=${this.selectId}
    class=${this.getTriggerClasses()}
    role="combobox"
    aria-expanded=${this.open ? 'true' : 'false'}
    aria-haspopup="listbox"
    aria-controls=${listboxId}
    aria-autocomplete="list"
    aria-activedescendant=${this.open && this.activeIndex >= 0 ? optionId : ''}
    aria-invalid=${this.showError ? 'true' : nothing}
    placeholder=${this.placeholder}
    .value=${this.getInputDisplayValue()}
    ?disabled=${this.disabled}
    @input=${this.handleInput}
    @keydown=${this.handleKeydown}
    @focus=${this.handleInputFocus}
    @blur=${this.handleBlur}
  />
`
```

2. Add `getInputDisplayValue()` method:
   - When dropdown is open: return `filterQuery` (what user is typing)
   - When dropdown is closed: return selected option's label (display the selection)
   - This prevents the filter text from persisting after selection

3. Add `handleInput(e: InputEvent)` method:
   - Get input value from `e.target`
   - Call `applyFilter(value)`

4. Add `handleInputFocus()` method:
   - When focused, show all options initially (don't auto-filter)
   - User can start typing to filter

5. Modify `render()` to conditionally render:
   - If `searchable`: render input-based trigger (with separate chevron/actions div)
   - Else: render existing div-based trigger

6. Modify `closeDropdown()`:
   - Clear `filterQuery` when closing (reset for next open)

7. Add trigger wrapper div styling for searchable mode:
   - The input needs to be inside a wrapper with the actions (clear button, chevron)
   - Use flex layout similar to existing trigger

CSS additions in static styles:
```css
.trigger-input {
  flex: 1;
  border: none;
  background: transparent;
  outline: none;
  font-size: inherit;
  color: inherit;
  padding: 0;
  min-width: 0;
}

.trigger-input::placeholder {
  color: var(--ui-select-placeholder);
}
```
  </action>
  <verify>Run dev server: `cd packages/select && pnpm dev` - searchable select shows input, typing filters options</verify>
  <done>Searchable select renders text input, typing filters options, closing clears filter and shows selected value</done>
</task>

<task type="auto">
  <name>Task 3: Fix keyboard navigation for searchable mode</name>
  <files>packages/select/src/select.ts</files>
  <action>
Update keyboard handling to work correctly with text input:

1. Modify `handleKeydown()` for searchable mode when dropdown is OPEN:
   - Arrow Up/Down: preventDefault() and navigate options (don't move cursor)
   - Home/End: preventDefault() and jump to first/last option
   - Enter: Select current option and close (existing behavior)
   - Escape: Close dropdown and clear filter (existing behavior)
   - Tab: Close dropdown (existing behavior)
   - Printable characters: Let input handle them (don't preventDefault)
   - Backspace/Delete: Let input handle them (don't preventDefault)
   - Left/Right arrows: Let input handle cursor movement (don't preventDefault)

2. Modify `handleKeydown()` for searchable mode when dropdown is CLOSED:
   - Any character input: Open dropdown and let input handle it
   - Arrow Down/Up/Space/Enter: Open dropdown (existing behavior)
   - Don't use type-ahead search (input handles this natively)

3. Important: In searchable mode, disable the typeahead mechanism entirely since the input handles text entry natively.

4. Update active index management:
   - After filtering, clamp `activeIndex` to valid range (0 to filteredOptions.length - 1)
   - If no options match, set `activeIndex = -1`
   - When navigating, use `filteredOptions` length not `effectiveOptions` length

5. Fix index mapping for selection:
   - When user selects in searchable mode, we have filtered index
   - Need to get the actual option from `filteredOptions[activeIndex]`
   - Then find its original value to set `_value`
  </action>
  <verify>Manual test: Arrow keys navigate filtered options, typing doesn't break navigation, Enter selects correct option</verify>
  <done>Keyboard navigation works correctly in searchable mode - arrows navigate, typing filters, Enter selects, Escape closes</done>
</task>

</tasks>

<verification>
1. Build passes: `cd packages/select && pnpm build`
2. Searchable prop transforms trigger to input
3. Typing in input filters options case-insensitively
4. Arrow keys navigate filtered options (not original list)
5. Enter selects the correct option from filtered list
6. Closing dropdown clears filter and shows selected label
7. Screen reader announces "combobox" with autocomplete list
</verification>

<success_criteria>
- COMBO-01: Select supports searchable prop for text input filtering
- COMBO-02: Combobox filters options as user types
- A11Y-06: Keyboard navigation follows W3C APG combobox pattern
- TypeScript compiles without errors
- Filter uses case-insensitive contains matching
</success_criteria>

<output>
After completion, create `.planning/phases/35-combobox/35-01-SUMMARY.md`
</output>
