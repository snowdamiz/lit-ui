---
phase: 63-filtering-pagination
plan: 04
type: execute
wave: 2
depends_on: ["63-01", "63-03"]
files_modified:
  - packages/data-table/src/types.ts
  - packages/data-table/src/data-table.ts
  - packages/data-table/src/async-handler.ts
autonomous: true

must_haves:
  truths:
    - "DataTable accepts async dataCallback function for server-side data fetching"
    - "Callback receives current state (page, pageSize, sort, filters) as parameters"
    - "AbortController cancels previous requests when new request starts"
    - "Debounced requests (300ms) prevent excessive server calls during filter input"
    - "Error state displays when fetch fails with retry button"
  artifacts:
    - path: "packages/data-table/src/types.ts"
      provides: "DataCallback type, DataCallbackParams, DataCallbackResult, ErrorState"
      contains: "DataCallback"
    - path: "packages/data-table/src/data-table.ts"
      provides: "dataCallback property, fetchData method, error state handling"
      contains: "dataCallback"
    - path: "packages/data-table/src/async-handler.ts"
      provides: "Debounce utility, optional AsyncDataHandler class"
      contains: "debounce"
  key_links:
    - from: "packages/data-table/src/data-table.ts"
      to: "dataCallback"
      via: "fetchData method calling callback"
      pattern: "this.dataCallback"
    - from: "packages/data-table/src/data-table.ts"
      to: "AbortController"
      via: "request cancellation"
      pattern: "abortController"
---

<objective>
Implement async data callback pattern for server-side data fetching with proper request cancellation, debouncing, and error handling.

Purpose: Enable DataTable to work with server-side data sources where sorting, filtering, and pagination are handled by an API. The callback pattern gives developers full control over data fetching while the component handles loading states, cancellation, and error display.

Output: DataTable with dataCallback property that receives table state and returns data, complete with AbortController cancellation, debounced filter input, and error state with retry capability.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/63-filtering-pagination/63-RESEARCH.md
@.planning/phases/63-filtering-pagination/63-01-SUMMARY.md
@.planning/phases/63-filtering-pagination/63-03-SUMMARY.md

@packages/data-table/src/data-table.ts
@packages/data-table/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add async callback types and DataTable properties</name>
  <files>
    packages/data-table/src/types.ts
    packages/data-table/src/data-table.ts
  </files>
  <action>
In types.ts, add:

```typescript
/**
 * Parameters passed to the async data callback.
 * Contains current table state for server-side operations.
 */
export interface DataCallbackParams {
  /** Current page index (0-based) */
  pageIndex: number;
  /** Current page size */
  pageSize: number;
  /** Current sorting state */
  sorting: SortingState;
  /** Current column filters */
  columnFilters: ColumnFiltersState;
  /** Current global filter string */
  globalFilter: string;
}

/**
 * Result returned from the async data callback.
 */
export interface DataCallbackResult<TData> {
  /** Row data for current page */
  data: TData[];
  /** Total row count across all pages */
  totalRowCount: number;
  /** Optional page count (calculated from totalRowCount/pageSize if not provided) */
  pageCount?: number;
}

/**
 * Async data callback function type.
 * @param params - Current table state
 * @param signal - AbortSignal for request cancellation
 * @returns Promise resolving to data result
 */
export type DataCallback<TData> = (
  params: DataCallbackParams,
  signal: AbortSignal
) => Promise<DataCallbackResult<TData>>;

/**
 * Error state for async data fetching.
 */
export interface DataTableErrorState {
  /** Error message to display */
  message: string;
  /** Whether retry is possible */
  canRetry: boolean;
}
```

In data-table.ts, add properties:

```typescript
/**
 * Async data callback for server-side data fetching.
 * When provided, the component calls this function when state changes.
 */
@property({ attribute: false })
dataCallback?: DataCallback<TData>;

/**
 * Error state from async data fetching.
 */
@state()
private errorState: DataTableErrorState | null = null;

/**
 * AbortController for cancelling in-flight requests.
 */
private abortController?: AbortController;

/**
 * Debounce timeout for filter changes.
 */
private debounceTimeout?: ReturnType<typeof setTimeout>;

/**
 * Debounce delay in milliseconds for filter-triggered fetches.
 */
@property({ type: Number, attribute: 'debounce-delay' })
debounceDelay = 300;
```

Import DataCallback, DataCallbackParams, DataCallbackResult, DataTableErrorState from types.
  </action>
  <verify>
Run `pnpm build --filter @lit-ui/data-table` - should succeed with no type errors.
  </verify>
  <done>
All async callback types defined and properties added to DataTable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement fetchData with AbortController and debouncing</name>
  <files>
    packages/data-table/src/data-table.ts
  </files>
  <action>
Add the following methods to DataTable:

```typescript
/**
 * Fetch data from async callback with current table state.
 * Handles request cancellation and error states.
 */
private async fetchData(): Promise<void> {
  if (!this.dataCallback) return;

  // Cancel any pending request
  this.abortController?.abort();
  this.abortController = new AbortController();

  const params: DataCallbackParams = {
    pageIndex: this.pagination.pageIndex,
    pageSize: this.pagination.pageSize,
    sorting: this.sorting,
    columnFilters: this.columnFilters,
    globalFilter: this.globalFilter,
  };

  // Show updating state (preserves existing content)
  this.loading = 'updating';
  this.errorState = null;

  try {
    const result = await this.dataCallback(params, this.abortController.signal);

    // Update data and counts
    this.data = result.data;
    this.totalRowCount = result.totalRowCount;
    if (result.pageCount !== undefined) {
      this.pageCount = result.pageCount;
    } else {
      // Calculate page count from total
      this.pageCount = Math.ceil(result.totalRowCount / this.pagination.pageSize);
    }

    this.loading = 'idle';
  } catch (error) {
    // Ignore abort errors - these are intentional cancellations
    if ((error as Error).name === 'AbortError') {
      return;
    }

    // Set error state for display
    this.errorState = {
      message: (error as Error).message || 'Failed to load data',
      canRetry: true,
    };
    this.loading = 'idle';
  }
}

/**
 * Debounced fetch for filter changes.
 * Prevents excessive requests during rapid input.
 */
private debouncedFetchData(): void {
  clearTimeout(this.debounceTimeout);
  this.debounceTimeout = setTimeout(() => {
    this.fetchData();
  }, this.debounceDelay);
}

/**
 * Handle retry button click from error state.
 */
private handleRetry(): void {
  this.errorState = null;
  this.fetchData();
}
```

Update disconnectedCallback to clean up:

```typescript
override disconnectedCallback(): void {
  super.disconnectedCallback();
  this.virtualizer = undefined;
  clearTimeout(this.debounceTimeout);
  this.abortController?.abort();
}
```

Update the existing state change handlers to trigger fetches when in manual mode:

1. In onSortingChange handler:
```typescript
// After dispatching event
if (this.dataCallback && this.manualSorting) {
  this.fetchData(); // Immediate fetch for sorting (no debounce)
}
```

2. In onColumnFiltersChange handler (or wherever filter changes are handled):
```typescript
if (this.dataCallback && this.manualFiltering) {
  this.debouncedFetchData(); // Debounced for filter input
}
```

3. In onGlobalFilterChange handler:
```typescript
if (this.dataCallback && this.manualFiltering) {
  this.debouncedFetchData();
}
```

4. In onPaginationChange handler:
```typescript
if (this.dataCallback && this.manualPagination) {
  this.fetchData(); // Immediate fetch for pagination
}
```
  </action>
  <verify>
Run `pnpm build --filter @lit-ui/data-table` - should succeed.
Verify fetchData, debouncedFetchData, and handleRetry methods exist.
  </verify>
  <done>
AbortController cancels previous requests (ASYNC-03).
Debounced requests prevent excessive calls (ASYNC-04).
  </done>
</task>

<task type="auto">
  <name>Task 3: Add error state rendering with retry</name>
  <files>
    packages/data-table/src/data-table.ts
  </files>
  <action>
1. Add renderErrorState method:

```typescript
/**
 * Render error state with retry button.
 */
private renderErrorState(): TemplateResult {
  if (!this.errorState) return html``;

  return html`
    <div class="error-state-container">
      <div class="error-state" role="alert" aria-live="polite">
        <div class="error-state-icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/>
            <line x1="12" y1="8" x2="12" y2="12"/>
            <circle cx="12" cy="16" r="1" fill="currentColor" stroke="none"/>
          </svg>
        </div>
        <p class="error-state-message">${this.errorState.message}</p>
        <p class="error-state-description">Unable to load data. Please try again.</p>
        ${this.errorState.canRetry ? html`
          <lui-button
            variant="outline"
            size="sm"
            @click=${this.handleRetry}
          >
            Retry
          </lui-button>
        ` : nothing}
      </div>
    </div>
  `;
}
```

2. Update renderBody to show error state:

```typescript
private renderBody(table: Table<TData>): TemplateResult {
  // Show error state first if present
  if (this.errorState) {
    return this.renderErrorState();
  }

  // Show skeleton during initial loading
  if (this.loading === 'loading') {
    return this.renderSkeletonRows();
  }

  // ... rest of existing logic
}
```

3. Add CSS for error state (add to static styles):

```css
/* Error State Styles */
.error-state-container {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 200px;
  padding: 2rem;
}

.error-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  max-width: 300px;
}

.error-state-icon {
  color: var(--color-destructive, #ef4444);
  margin-bottom: 1rem;
}

.error-state-message {
  font-size: 1rem;
  font-weight: 500;
  color: var(--ui-data-table-text-color);
  margin: 0 0 0.5rem 0;
}

.error-state-description {
  font-size: 0.875rem;
  color: var(--ui-data-table-header-text);
  margin: 0 0 1rem 0;
}
```

4. Add initial fetch on first update when dataCallback is provided:

```typescript
override firstUpdated(): void {
  // Existing code...
  this._previousFilterState = JSON.stringify({
    columnFilters: this.columnFilters,
    globalFilter: this.globalFilter,
  });

  // Initial fetch if dataCallback is provided
  if (this.dataCallback) {
    this.loading = 'loading'; // Initial load shows skeleton
    this.fetchData();
  }
}
```

5. Watch for dataCallback changes:

```typescript
protected override updated(changedProperties: PropertyValues): void {
  super.updated(changedProperties);

  // Existing code...

  // Trigger fetch when dataCallback is first set
  if (changedProperties.has('dataCallback') && this.dataCallback && !changedProperties.get('dataCallback')) {
    this.loading = 'loading';
    this.fetchData();
  }
}
```
  </action>
  <verify>
Run `pnpm build --filter @lit-ui/data-table` - should succeed.
Verify renderErrorState method exists with retry button.
  </verify>
  <done>
Error state displays when fetch fails with retry option (ASYNC-05).
DataTable accepts async data callback (ASYNC-01).
Callback receives current state as parameters (ASYNC-02).
  </done>
</task>

</tasks>

<verification>
1. `pnpm build --filter @lit-ui/data-table` succeeds
2. types.ts contains DataCallback, DataCallbackParams, DataCallbackResult, DataTableErrorState
3. data-table.ts has dataCallback property
4. data-table.ts has fetchData with AbortController
5. data-table.ts has debouncedFetchData with configurable delay
6. data-table.ts has renderErrorState with retry button
7. disconnectedCallback cleans up timeout and aborts requests
</verification>

<success_criteria>
- dataCallback property accepts async function (ASYNC-01)
- Callback receives {pageIndex, pageSize, sorting, columnFilters, globalFilter} (ASYNC-02)
- AbortController cancels previous request on new request (ASYNC-03)
- Filter changes debounced at 300ms default (ASYNC-04)
- Error state shows message and retry button (ASYNC-05)
- Initial fetch triggered when dataCallback set
- Cleanup in disconnectedCallback prevents memory leaks
</success_criteria>

<output>
After completion, create `.planning/phases/63-filtering-pagination/63-04-SUMMARY.md`
</output>
