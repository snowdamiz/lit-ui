---
phase: 99-incremental-moving-average-state-machine
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/charts/src/shared/ma-state-machine.ts
autonomous: true
requirements: [MA-01, MA-03]

must_haves:
  truths:
    - "MAStateMachine.push() returns null during SMA warm-up (first period-1 bars) and a correct average once the window is full"
    - "MAStateMachine.push() returns null (not NaN) when given a NaN close, and resumes correct output after the next valid close"
    - "MAStateMachine reset() + replay from a full closes array produces the same values array as calling push() individually from scratch"
    - "EMA warm-up correctly ignores NaN inputs and only counts valid closes toward the period threshold"
    - "MAStateMachine.push() appends to .values and returns the updated array each call (O(1) per call)"
  artifacts:
    - path: "packages/charts/src/shared/ma-state-machine.ts"
      provides: "MAStateMachine class with O(1) SMA ring buffer and EMA incremental state"
      exports: ["MAStateMachine"]
      min_lines: 80
  key_links:
    - from: "packages/charts/src/shared/ma-state-machine.ts"
      to: "packages/charts/src/shared/candlestick-option-builder.ts"
      via: "imports MAConfig type"
      pattern: "import.*MAConfig.*candlestick-option-builder"
---

<objective>
Create the MAStateMachine class in a new file using TDD. This is the O(1) incremental state machine that replaces the full O(n) _computeSMA/_computeEMA recomputation that currently happens every RAF flush.

Purpose: MA-01 mandates O(1) per-bar computation so that frame time stays constant regardless of total bar count. MA-03 mandates NaN-gap isolation so bad closes don't corrupt the SMA running sum or EMA state.

Output: packages/charts/src/shared/ma-state-machine.ts with an exported MAStateMachine class wrapping SMAState (ring buffer) and EMAState (warm-up + exponential smoothing).
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/99-incremental-moving-average-state-machine/99-RESEARCH.md

<interfaces>
<!-- Key types the executor needs. No codebase exploration required. -->

From packages/charts/src/shared/candlestick-option-builder.ts (current):
```typescript
export type MAConfig = {
  period: number;
  color: string;          // NOTE: Phase 99 plan 02 will make color optional — import as type only
  type?: 'sma' | 'ema';
  showType?: boolean;     // Added by plan 02 — use type-only import to avoid circular dependency
};
```

MAStateMachine target interface (from RESEARCH.md):
```typescript
export class MAStateMachine {
  constructor(config: MAConfig): void
  reset(closes: number[]): (number | null)[]   // O(n) — full replay from _applyData()
  push(close: number): (number | null)[]        // O(1) — incremental from _flushBarUpdates()
  get values(): (number | null)[]               // current output array
}
```
</interfaces>
</context>

<feature>
  <name>MAStateMachine — O(1) incremental SMA/EMA state machine with NaN gap handling</name>
  <files>
    packages/charts/src/shared/ma-state-machine.ts
  </files>
  <behavior>
    SMA (type: 'sma' or default):
    - push(close) returns null for the first (period - 1) calls (warm-up)
    - push(close) returns the sliding window average once `period` valid closes have been seen
    - push(NaN) returns null without touching the running sum or ring buffer (MA-03)
    - After a NaN gap, the next valid close is processed correctly — the window still holds the pre-NaN values

    EMA (type: 'ema'):
    - push(close) returns null until `period` valid non-NaN closes have been accumulated
    - Seeds from the SMA of the first `period` valid closes
    - push(NaN) returns null without incrementing the warm-up counter (MA-03)
    - After warm-up, push(close) applies: ema = close * k + prevEma * (1 - k), k = 2/(period+1)

    MAStateMachine (public):
    - constructor(config) picks SMAState or EMAState based on config.type ?? 'sma'
    - reset(closes): resets internal state, replays all closes via push(), returns resulting array
    - push(close): calls internal state.push(), appends to _values[], returns _values
    - values getter: returns _values reference

    Test cases (input → expected output):
    - SMA(3): [1,2,3,4,5] → [null, null, 2, 3, 4]
    - SMA(3): [1,NaN,3,4,5] → [null, null, null, null, 4] (NaN resets ready; window has 1,NaN,3 → only 2 valid pre-4 but 3,4,5 → ready at [4])

    CORRECTION from RESEARCH.md algorithm: NaN does NOT consume a window slot. The SMAState ring buffer skips NaN (returns null without updating window). So:
    - SMA(3): [1, 2, NaN, 3, 4] → push(1)=null, push(2)=null, push(NaN)=null, push(3)=[1,2,3]→avg=2=null? No — window had [1,2,_] then 3 fills → count=3 → ready → (1+2+3)/3=2 → returns 2, push(4) → evict 1 → (2+3+4)/3=3
      Actually: [null, null, null, 2.0, 3.0]

    - EMA(3): [1,2,3,4,5] → [null, null, 1+2+3/3=2.0 (seed), 4*0.5+2*0.5=3.0, 5*0.5+3*0.5=4.0]
    - EMA(3): [1,NaN,3,4,5,6] → [null, null (NaN skipped), null (only 2 valid so far), null (still warming), 4+5+6... wait: valid closes are 1,3,4,5,6] → push(1)=null, push(NaN)=null (warmup stays [1]), push(3)=null ([1,3]), push(4)=seed from [1,3,4]=(1+3+4)/3=2.67, push(5)=5*0.5+2.67*0.5=3.83, push(6)=6*0.5+3.83*0.5=4.92
      So: [null, null, null, 2.67, 3.83, 4.92]

    - MAStateMachine(sma, period=3).reset([10,20,30,40]) === [null, null, 20, 30] then push(50) returns [..., 40]
  </behavior>
  <implementation>
    File: packages/charts/src/shared/ma-state-machine.ts

    Three classes:
    1. SMAState (not exported) — ring buffer of size `period` initialized with NaN. Running sum and valid count tracked separately. push(NaN) returns null without touching state. push(valid) evicts oldest slot (subtract from sum if it was valid), inserts new value, advances pointer.

    2. EMAState (not exported) — stores _warmup: number[] (valid closes only). Once _warmup.length >= period, computes seed SMA, sets _prevEma. Subsequent push() applies EMA formula. push(NaN) returns null without appending to _warmup.

    3. MAStateMachine (exported) — thin wrapper: constructor picks SMAState or EMAState. reset(closes) calls _state.reset() then maps closes through _state.push(). push(close) calls _state.push() and appends to _values. values getter returns _values.

    Import: `import type { MAConfig } from './candlestick-option-builder.js';` — type-only import avoids any circular dependency since candlestick-option-builder.ts does NOT import ma-state-machine.ts.

    No external dependencies. No framework imports.
  </implementation>
</feature>

<verification>
RED phase: Run tsc --noEmit from packages/charts — test file must fail because ma-state-machine.ts does not exist yet.

GREEN phase: Run tsc --noEmit from packages/charts — must pass with zero type errors after implementing ma-state-machine.ts.

Behavioral tests embedded as assertions using Node.js assert module (no test runner available in this package):

```bash
# After implementing, verify via TypeScript compilation only
cd /Users/sn0w/Documents/dev/lit-components && pnpm --filter @lit-ui/charts run build
```

The build passes only if:
1. MAStateMachine is exported and matches the type contract
2. No circular imports (ma-state-machine.ts → type-only MAConfig import)
3. TypeScript strict mode satisfied
</verification>

<success_criteria>
- packages/charts/src/shared/ma-state-machine.ts exists with MAStateMachine exported class
- MAStateMachine constructor accepts MAConfig, picks SMAState vs EMAState based on config.type
- SMAState.push(NaN) returns null without corrupting _sum (MA-03)
- EMAState.push(NaN) returns null without incrementing warm-up counter (MA-03)
- Both states track _values array; push() appends and returns it O(1) per call (MA-01)
- reset(closes) replays full array, returning correct historical values
- pnpm --filter @lit-ui/charts run build completes with zero errors
</success_criteria>

<output>
After completion, create .planning/phases/99-incremental-moving-average-state-machine/99-01-SUMMARY.md
</output>
