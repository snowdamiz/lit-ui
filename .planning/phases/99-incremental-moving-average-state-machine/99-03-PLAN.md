---
phase: 99-incremental-moving-average-state-machine
plan: 03
type: execute
wave: 2
depends_on: [99-01, 99-02]
files_modified:
  - packages/charts/src/candlestick/candlestick-chart.ts
autonomous: true
requirements: [MA-01, MA-02, MA-03, MA-04]

must_haves:
  truths:
    - "LuiCandlestickChart maintains one MAStateMachine per MAConfig entry in _maStateMachines[]"
    - "_applyData() rebuilds _maStateMachines from scratch and calls sm.reset(closes) to replay the full dataset"
    - "_flushBarUpdates() calls sm.push(lastClose) O(1) per machine — does NOT call sm.reset() or iterate all bars"
    - "When movingAverages attribute changes at runtime (different count), _maStateMachines is rebuilt in _applyData() so the count stays in sync"
    - "MA lines get distinct colors from --ui-chart-color-2 through --ui-chart-color-5 when MAConfig.color is omitted"
    - "_ohlcBuffer trimming at maxPoints also trims _maStateMachines[i]._values via sm.trim(maxPoints)"
  artifacts:
    - path: "packages/charts/src/candlestick/candlestick-chart.ts"
      provides: "LuiCandlestickChart with _maStateMachines[] field, _resolveMAColors(), incremental MA flush"
      contains: "_maStateMachines"
      min_lines: 150
  key_links:
    - from: "packages/charts/src/candlestick/candlestick-chart.ts"
      to: "packages/charts/src/shared/ma-state-machine.ts"
      via: "imports MAStateMachine, creates instances in _applyData()"
      pattern: "import.*MAStateMachine"
    - from: "packages/charts/src/candlestick/candlestick-chart.ts"
      to: "packages/charts/src/shared/candlestick-option-builder.ts"
      via: "passes maValueArrays and resolvedMAColors to buildCandlestickOption"
      pattern: "maValueArrays.*resolvedMAColors"
    - from: "LuiCandlestickChart._flushBarUpdates()"
      to: "MAStateMachine.push()"
      via: "incremental O(1) call per bar per machine"
      pattern: "sm\\.push\\(lastClose\\)"
---

<objective>
Wire MAStateMachine[] into LuiCandlestickChart to replace the current O(n) per-flush MA computation with the O(1) incremental state machine. Also add _resolveMAColors() for CSS token default color assignment (MA-02), and wire trim() calls so _maStateMachines._values stays aligned with _ohlcBuffer after maxPoints trimming.

Purpose: Without this wiring plan, the state machines from plan 01 and the type changes from plan 02 are unused — the chart still calls buildCandlestickOption with no maValueArrays. This plan is the integration step that makes all four MA requirements observable.

Output: Updated candlestick-chart.ts where _applyData() initializes _maStateMachines and _flushBarUpdates() calls incremental push() instead of rebuilding MA values from scratch.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/99-incremental-moving-average-state-machine/99-RESEARCH.md
@.planning/phases/99-incremental-moving-average-state-machine/99-01-SUMMARY.md
@.planning/phases/99-incremental-moving-average-state-machine/99-02-SUMMARY.md

<interfaces>
<!-- Contracts created by plans 01 and 02 — executor uses these directly without codebase exploration. -->

From packages/charts/src/shared/ma-state-machine.ts (created by plan 01):
```typescript
export class MAStateMachine {
  constructor(config: MAConfig): void
  /** Full reset + replay — O(n). Call only from _applyData(). */
  reset(closes: number[]): (number | null)[]
  /** Incremental O(1) push. Call from _flushBarUpdates(). */
  push(close: number): (number | null)[]
  /** Trim _values to maxLen — call after _ohlcBuffer is sliced. */
  trim(maxLen: number): void
  get values(): (number | null)[]
}
```

NOTE: If MAStateMachine does not have a trim() method from plan 01, add it:
```typescript
trim(maxLen: number): void {
  if (this._values.length > maxLen) {
    this._values = this._values.slice(-maxLen);
  }
}
```
Add to the MAStateMachine class in packages/charts/src/shared/ma-state-machine.ts if missing.

From packages/charts/src/shared/candlestick-option-builder.ts (updated by plan 02):
```typescript
export type MAConfig = {
  period: number;
  color?: string;       // now optional
  type?: 'sma' | 'ema';
  showType?: boolean;
};

export type CandlestickOptionProps = {
  bullColor?: string;
  bearColor?: string;
  showVolume?: boolean;
  movingAverages?: MAConfig[];
  maValueArrays?: (number | null)[][];      // NEW — pre-computed arrays
  resolvedMAColors?: string[];              // NEW — pre-resolved token colors
};
```

From packages/charts/src/base/base-chart-element.ts (updated by plan 02):
```typescript
protected readChartToken(name: string): string  // delegates to _themeBridge.readToken()
```

Current LuiCandlestickChart._applyData() (to be modified):
```typescript
protected override _applyData(): void {
  if (!this._chart) return;
  this._ohlcBuffer = this.data ? [...(this.data as CandlestickBarPoint[])] : [];
  const option = buildCandlestickOption(this._ohlcBuffer, {
    bullColor: this.bullColor ?? undefined,
    bearColor: this.bearColor ?? undefined,
    showVolume: this.showVolume,
    movingAverages: _parseMovingAverages(this.movingAverages),
  });
  this._chart.setOption(option, { notMerge: false });
}
```

Current LuiCandlestickChart._flushBarUpdates() (to be modified):
```typescript
private _flushBarUpdates(): void {
  if (!this._chart || this._ohlcBuffer.length === 0) return;
  const option = buildCandlestickOption(this._ohlcBuffer, {
    bullColor: this.bullColor ?? undefined,
    bearColor: this.bearColor ?? undefined,
    showVolume: this.showVolume,
    movingAverages: _parseMovingAverages(this.movingAverages),
  });
  this._chart.setOption(option, { lazyUpdate: true } as object);
}
```

Current LuiCandlestickChart.pushData() (partial — trim logic to modify):
```typescript
override pushData(point: unknown): void {
  const bar = point as CandlestickBarPoint;
  this._ohlcBuffer.push(bar);
  if (this._ohlcBuffer.length > this.maxPoints) {
    this._ohlcBuffer = this._ohlcBuffer.slice(-this.maxPoints);
  }
  // ... RAF scheduling unchanged ...
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add _maStateMachines field and _resolveMAColors() to LuiCandlestickChart</name>
  <files>packages/charts/src/candlestick/candlestick-chart.ts</files>
  <action>
    Add the import, field, and color resolution method — but do NOT yet modify _applyData() or _flushBarUpdates() (those come in Task 2).

    1. **Add import** at the top of the file alongside the existing candlestick-option-builder import:
    ```typescript
    import { MAStateMachine } from '../shared/ma-state-machine.js';
    ```

    2. **Add private field** alongside `_ohlcBuffer`:
    ```typescript
    // One MAStateMachine per MAConfig entry — rebuilt on every _applyData() call.
    // MA-01: provides O(1) incremental push() for streaming bars.
    private _maStateMachines: MAStateMachine[] = [];
    ```

    3. **Add private constant and method** below the `_ohlcBuffer` field:
    ```typescript
    // MA-02: Default color token sequence — starts at color-2 so MA lines don't clash with
    // the chart's primary data color (color-1 = #3b82f6 used by ECharts theme).
    private static readonly _MA_DEFAULT_COLOR_TOKENS = [
      '--ui-chart-color-2',
      '--ui-chart-color-3',
      '--ui-chart-color-4',
      '--ui-chart-color-5',
    ] as const;

    /**
     * MA-02: Resolve MA line colors — uses MAConfig.color when provided, otherwise
     * reads from CSS token sequence via readChartToken() (inherited from BaseChartElement).
     * Cycles through 4 tokens for >4 MA overlays.
     */
    private _resolveMAColors(mas: MAConfig[]): string[] {
      let defaultIndex = 0;
      return mas.map((ma) => {
        if (ma.color) return ma.color;
        const token = LuiCandlestickChart._MA_DEFAULT_COLOR_TOKENS[
          defaultIndex % LuiCandlestickChart._MA_DEFAULT_COLOR_TOKENS.length
        ];
        defaultIndex++;
        return this.readChartToken(token);
      });
    }
    ```

    Verify the file still compiles after this task before moving to Task 2.
  </action>
  <verify>
    <automated>cd /Users/sn0w/Documents/dev/lit-components && pnpm --filter @lit-ui/charts run build 2>&1 | tail -15</automated>
  </verify>
  <done>
    - MAStateMachine imported from '../shared/ma-state-machine.js'
    - _maStateMachines: MAStateMachine[] = [] field exists on LuiCandlestickChart
    - _MA_DEFAULT_COLOR_TOKENS static readonly array exists
    - _resolveMAColors(mas) method exists, returns string[]
    - Build passes with zero errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire incremental MA state machines into _applyData(), _flushBarUpdates(), and pushData()</name>
  <files>packages/charts/src/candlestick/candlestick-chart.ts</files>
  <action>
    Modify three methods to complete the incremental MA integration:

    **1. _applyData() — full reset path:**
    Replace the existing implementation with:
    ```typescript
    protected override _applyData(): void {
      if (!this._chart) return;
      this._ohlcBuffer = this.data ? [...(this.data as CandlestickBarPoint[])] : [];
      const mas = _parseMovingAverages(this.movingAverages);

      // MA-01: Rebuild state machines atomically with _ohlcBuffer reset.
      // Always rebuild from scratch — handles MA config count changes (Pitfall 3 from RESEARCH.md).
      this._maStateMachines = mas.map((ma) => new MAStateMachine(ma));

      // Replay all closes through state machines to build historical MA arrays.
      // O(n) here is unavoidable — this only runs on full data changes, not per-bar.
      const closes = this._ohlcBuffer.map((b) => b.ohlc[1]);
      const maValueArrays = this._maStateMachines.map((sm) => sm.reset(closes));
      const resolvedMAColors = this._resolveMAColors(mas);

      const option = buildCandlestickOption(this._ohlcBuffer, {
        bullColor: this.bullColor ?? undefined,
        bearColor: this.bearColor ?? undefined,
        showVolume: this.showVolume,
        movingAverages: mas,
        maValueArrays,
        resolvedMAColors,
      });
      this._chart.setOption(option, { notMerge: false });
    }
    ```

    **2. _flushBarUpdates() — incremental O(1) path:**
    Replace the existing implementation with:
    ```typescript
    private _flushBarUpdates(): void {
      if (!this._chart || this._ohlcBuffer.length === 0) return;
      const mas = _parseMovingAverages(this.movingAverages);

      // MA-01: Incremental push — O(1) per machine per bar.
      // Only the last bar's close is needed — state machines hold the running window.
      const lastClose = this._ohlcBuffer[this._ohlcBuffer.length - 1].ohlc[1];
      const maValueArrays = this._maStateMachines.map((sm) => sm.push(lastClose));
      const resolvedMAColors = this._resolveMAColors(mas);

      const option = buildCandlestickOption(this._ohlcBuffer, {
        bullColor: this.bullColor ?? undefined,
        bearColor: this.bearColor ?? undefined,
        showVolume: this.showVolume,
        movingAverages: mas,
        maValueArrays,
        resolvedMAColors,
      });
      // lazyUpdate: true — preserves DataZoom state while batching update to next render cycle.
      this._chart.setOption(option, { lazyUpdate: true } as object);
    }
    ```

    **3. pushData() — add trim() call for _maStateMachines after _ohlcBuffer trim:**
    Find the existing trim block in pushData():
    ```typescript
    if (this._ohlcBuffer.length > this.maxPoints) {
      this._ohlcBuffer = this._ohlcBuffer.slice(-this.maxPoints);
    }
    ```
    Add a parallel trim for state machine value arrays immediately after:
    ```typescript
    if (this._ohlcBuffer.length > this.maxPoints) {
      this._ohlcBuffer = this._ohlcBuffer.slice(-this.maxPoints);
      // Trim MA value arrays in parallel to keep indices aligned with _ohlcBuffer.
      this._maStateMachines.forEach((sm) => sm.trim(this.maxPoints));
    }
    ```

    IMPORTANT: Do NOT call sm.reset() inside _flushBarUpdates() — that would make computation O(n) again (Pitfall 2 from RESEARCH.md). Only call sm.push() in the flush path. Only call sm.reset() in _applyData().

    IMPORTANT: If MAStateMachine.trim() does not exist after plan 01 (check the import), add it to packages/charts/src/shared/ma-state-machine.ts:
    ```typescript
    /** Trim _values to match a trimmed _ohlcBuffer. Call after _ohlcBuffer.slice(-maxPoints). */
    trim(maxLen: number): void {
      if (this._values.length > maxLen) {
        this._values = this._values.slice(-maxLen);
      }
    }
    ```
  </action>
  <verify>
    <automated>cd /Users/sn0w/Documents/dev/lit-components && pnpm --filter @lit-ui/charts run build 2>&1 | tail -15</automated>
  </verify>
  <done>
    - _applyData() rebuilds _maStateMachines = mas.map(ma => new MAStateMachine(ma))
    - _applyData() calls sm.reset(closes) and passes maValueArrays + resolvedMAColors to buildCandlestickOption
    - _flushBarUpdates() calls sm.push(lastClose) — NOT sm.reset()
    - pushData() calls sm.trim(this.maxPoints) after _ohlcBuffer slice
    - Build passes with zero TypeScript errors
    - No circular imports (candlestick-chart.ts → ma-state-machine.ts → candlestick-option-builder.ts type-only is acyclic)
  </done>
</task>

</tasks>

<verification>
Full integration verification:
```bash
cd /Users/sn0w/Documents/dev/lit-components && pnpm --filter @lit-ui/charts run build 2>&1
```

Check compiled output confirms integration:
```bash
grep -n "MAStateMachine\|_maStateMachines\|resolvedMAColors\|maValueArrays\|readChartToken" \
  /Users/sn0w/Documents/dev/lit-components/packages/charts/src/candlestick/candlestick-chart.ts
```

Confirm all four requirements are addressable:
- MA-01: grep shows `sm.push(lastClose)` in _flushBarUpdates (O(1)), `sm.reset(closes)` in _applyData (O(n) full replay)
- MA-02: grep shows `_resolveMAColors` called in both paths, using `readChartToken`
- MA-03: NaN handling is inside MAStateMachine itself (plan 01) — verify by checking ma-state-machine.ts has NaN guard
- MA-04: _maLegendName() in candlestick-option-builder.ts handles showType — verify the option builder produces correct series names
</verification>

<success_criteria>
- LuiCandlestickChart._maStateMachines field: MAStateMachine[] = [] — rebuilt atomically in _applyData()
- _applyData() uses sm.reset(closes) for full replay; passes maValueArrays + resolvedMAColors to buildCandlestickOption
- _flushBarUpdates() uses sm.push(lastClose) — O(1) per machine
- pushData() calls sm.trim() after _ohlcBuffer slice to keep indices in sync
- _resolveMAColors() uses readChartToken(token) for MAs without explicit color (MA-02)
- pnpm --filter @lit-ui/charts run build exits 0 with zero errors
- No regressions: existing candlestick chart functionality (bull/bear colors, volume panel, DataZoom) unchanged
</success_criteria>

<output>
After completion, create .planning/phases/99-incremental-moving-average-state-machine/99-03-SUMMARY.md
</output>
