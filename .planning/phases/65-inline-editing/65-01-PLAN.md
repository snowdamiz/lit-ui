---
phase: 65-inline-editing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/data-table/src/types.ts
  - packages/data-table/src/inline-editing.ts
  - packages/data-table/src/index.ts
autonomous: true

must_haves:
  truths:
    - "EditType and editing meta properties exist on LitUIColumnMeta for column configuration"
    - "renderEditInput returns appropriate native HTML input for each edit type (text, number, select, date, checkbox)"
    - "CellEditEvent and RowEditEvent interfaces define the event payloads for edit commit/save"
    - "Edit cell renderers call stopPropagation on keyboard events to prevent grid navigation interference"
  artifacts:
    - path: "packages/data-table/src/types.ts"
      provides: "EditType, EditValidationResult, CellEditEvent, RowEditEvent, EditingCell, EditingRow types"
      contains: "EditType"
    - path: "packages/data-table/src/inline-editing.ts"
      provides: "renderEditInput function, isColumnEditable helper, renderEditableIndicator"
      exports: ["renderEditInput", "isColumnEditable", "renderEditableIndicator", "inlineEditingStyles"]
    - path: "packages/data-table/src/index.ts"
      provides: "Re-exports inline editing utilities"
      contains: "inline-editing"
  key_links:
    - from: "packages/data-table/src/inline-editing.ts"
      to: "packages/data-table/src/types.ts"
      via: "imports EditType, LitUIColumnMeta, CellEditEvent"
      pattern: "import.*types"
    - from: "packages/data-table/src/index.ts"
      to: "packages/data-table/src/inline-editing.ts"
      via: "re-export"
      pattern: "export.*inline-editing"
---

<objective>
Create the type definitions and inline editing module that provide the foundation for cell-level and row-level editing in the data table.

Purpose: Establish the type system (EditType, validation, event interfaces) and rendering utilities (renderEditInput for each input type) that Plans 02 and 03 will integrate into the DataTable component. This separates edit rendering logic from the main component for maintainability.

Output: Extended types.ts with editing types, new inline-editing.ts module with input renderers, updated index.ts exports.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/65-inline-editing/65-RESEARCH.md
@packages/data-table/src/types.ts
@packages/data-table/src/selection-column.ts
@packages/data-table/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend types.ts with editing type definitions</name>
  <files>packages/data-table/src/types.ts</files>
  <action>
Add the following types and interfaces to types.ts:

1. **EditType union type** (after FilterType):
```typescript
export type EditType = 'text' | 'number' | 'select' | 'date' | 'checkbox';
```

2. **EditValidationResult interface**:
```typescript
export interface EditValidationResult {
  valid: boolean;
  message?: string;
}
```

3. **Extend LitUIColumnMeta** with editing properties. Replace the commented-out editable/editComponent lines with real properties:
- `editable?: boolean | ((row: TData) => boolean)` -- Mark column as editable. Boolean for all rows, function for conditional editability per row.
- `editType?: EditType` -- Input type to render in edit mode. Defaults to 'text' if omitted and editable is true.
- `editOptions?: Array<{ label: string; value: string }>` -- Options for select-type edit inputs.
- `editValidate?: (value: unknown, row: TData) => EditValidationResult | boolean` -- Custom validation function called before commit. Return true/false or an EditValidationResult object.

4. **EditingCell interface** (for cell-level edit state tracking):
```typescript
export interface EditingCell {
  rowId: string;
  columnId: string;
  originalValue: unknown;
}
```

5. **EditingRow interface** (for row-level edit state tracking):
```typescript
export interface EditingRow {
  rowId: string;
  originalData: Record<string, unknown>;
  pendingValues: Record<string, unknown>;
  errors: Record<string, string>;
}
```

6. **CellEditEvent interface** (EDIT-06):
```typescript
export interface CellEditEvent<TData extends RowData = RowData> {
  row: TData;
  rowId: string;
  columnId: string;
  oldValue: unknown;
  newValue: unknown;
}
```

7. **RowEditEvent interface** (ROWEDIT-05):
```typescript
export interface RowEditEvent<TData extends RowData = RowData> {
  row: TData;
  rowId: string;
  oldValues: Record<string, unknown>;
  newValues: Record<string, unknown>;
}
```

Remove the commented-out editable/editComponent/filterComponent/pinnedPosition lines from LitUIColumnMeta since the real properties now replace them.
  </action>
  <verify>Run `npx tsc --noEmit -p packages/data-table/tsconfig.json` -- should compile with no errors.</verify>
  <done>types.ts exports EditType, EditValidationResult, EditingCell, EditingRow, CellEditEvent, RowEditEvent. LitUIColumnMeta has editable, editType, editOptions, editValidate properties.</done>
</task>

<task type="auto">
  <name>Task 2: Create inline-editing.ts module with edit renderers and helpers</name>
  <files>packages/data-table/src/inline-editing.ts, packages/data-table/src/index.ts</files>
  <action>
Create `packages/data-table/src/inline-editing.ts` with the following exports:

1. **`isColumnEditable(meta, row)` helper function**: Centralizes the `boolean | function` check from column meta.
```typescript
export function isColumnEditable<TData extends RowData>(
  meta: LitUIColumnMeta<TData> | undefined,
  row: TData
): boolean {
  if (!meta?.editable) return false;
  if (typeof meta.editable === 'function') return meta.editable(row);
  return meta.editable === true;
}
```

2. **`renderEditInput(editType, value, options, handlers)` function**: Renders the appropriate native HTML input for the given edit type. Each input type:
   - **text**: `<input type="text">` with .value binding, 32px height, full-width
   - **number**: `<input type="number">` with .value binding
   - **select**: `<select>` with `<option>` elements from editOptions
   - **date**: `<input type="date">` with .value binding
   - **checkbox**: `<input type="checkbox">` with .checked binding

   All inputs MUST:
   - Call `e.stopPropagation()` on keydown events (prevent grid navigation interference)
   - Handle Enter key -> call `handlers.onCommit(value)` (except checkbox which commits on change)
   - Handle Escape key -> call `handlers.onCancel()`
   - Handle blur -> call `handlers.onCommit(value)` with guard against double-commit
   - Auto-focus when rendered (use `@lit-labs/task` pattern or `requestAnimationFrame` + `setTimeout` after render to focus the input)
   - Have class `cell-edit-input` (or `cell-edit-select` / `cell-edit-checkbox`)

   The handlers parameter shape:
   ```typescript
   interface EditInputHandlers {
     onCommit: (value: unknown) => void;
     onCancel: () => void;
   }
   ```

   The options parameter shape:
   ```typescript
   interface EditInputOptions {
     editOptions?: Array<{ label: string; value: string }>;
     validationError?: string | null;
   }
   ```

   For the auto-focus behavior, use a Lit `ref` callback directive or add a `connectedCallback` approach. The simplest pattern: after the input is rendered, use `this.updateComplete.then(() => input.focus())` -- but since this is a standalone function not inside a component, use the following pattern:
   ```typescript
   // In the template, add a ref directive that focuses on first render
   const autoFocus = (el: Element | undefined) => {
     if (el instanceof HTMLElement) {
       requestAnimationFrame(() => el.focus());
     }
   };
   // Use: ${ref(autoFocus)} on the input element
   ```

3. **`renderEditableIndicator()` function**: Returns a small pencil SVG icon template (12x12px) for showing the editable hint on hover/focus (EDIT-01).
```typescript
export function renderEditableIndicator(): TemplateResult {
  return html`
    <span class="editable-indicator" aria-hidden="true">
      <svg viewBox="0 0 16 16" width="12" height="12" fill="currentColor">
        <path d="M12.1 1.9a1.5 1.5 0 0 1 2.1 2.1L5.6 12.6l-3.2.8.8-3.2L12.1 1.9z"/>
      </svg>
    </span>
  `;
}
```

4. **`inlineEditingStyles` CSS**: Export a `css` tagged template with styles for:
   - `.cell-edit-input`, `.cell-edit-select`: width:100%, height:32px, padding:4px 8px, font-size:inherit from data table font-size var, border:1px solid primary color, border-radius:4px, background from row bg var, color from text color var, outline:none, box-sizing:border-box
   - `.cell-edit-input:focus`, `.cell-edit-select:focus`: box-shadow: 0 0 0 2px rgba(59,130,246,0.25)
   - `.cell-edit-input.has-error`: border-color: var(--color-destructive, #ef4444)
   - `.cell-edit-checkbox`: width:18px, height:18px, accent-color: var(--color-primary, #3b82f6)
   - `.cell-edit-error`: position:absolute, bottom:-16px, left:0, font-size:11px, color:var(--color-destructive, #ef4444), white-space:nowrap, z-index:10, pointer-events:none
   - `.editable-indicator`: opacity:0, transition:opacity 0.15s, margin-left:4px, color:var(--color-muted-foreground, #71717a), flex-shrink:0
   - `.data-table-cell.editable:hover .editable-indicator`, `.data-table-cell.editable:focus-within .editable-indicator`: opacity:1
   - `.data-table-cell.editable:hover`: cursor:pointer, background:var(--ui-data-table-editable-hover-bg, rgba(59,130,246,0.04))
   - `.data-table-cell.editing`: position:relative, overflow:visible, padding:4px 8px (tighter padding for edit mode)
   - Dark mode overrides using `:host-context(.dark)`

Imports needed: `html`, `css`, `nothing`, `type TemplateResult` from 'lit'; `ref` from 'lit/directives/ref.js'; types from './types.js'.

Then update `packages/data-table/src/index.ts` to re-export:
```typescript
// Inline editing utilities
export { renderEditInput, isColumnEditable, renderEditableIndicator, inlineEditingStyles } from './inline-editing.js';
```
  </action>
  <verify>Run `npx tsc --noEmit -p packages/data-table/tsconfig.json` -- should compile with no errors. Verify inline-editing.ts exports `renderEditInput`, `isColumnEditable`, `renderEditableIndicator`, `inlineEditingStyles`.</verify>
  <done>inline-editing.ts module exists with renderEditInput (handles all 5 edit types with proper keyboard handling and auto-focus), isColumnEditable helper, renderEditableIndicator (pencil icon), and inlineEditingStyles. All re-exported from index.ts.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/data-table/tsconfig.json` compiles without errors
2. types.ts contains EditType, EditValidationResult, EditingCell, EditingRow, CellEditEvent, RowEditEvent
3. LitUIColumnMeta has editable, editType, editOptions, editValidate properties (no commented-out placeholders)
4. inline-editing.ts exports renderEditInput, isColumnEditable, renderEditableIndicator, inlineEditingStyles
5. renderEditInput handles all 5 types: text, number, select, date, checkbox
6. All edit inputs call e.stopPropagation() on keydown events
7. index.ts re-exports inline editing utilities
</verification>

<success_criteria>
- TypeScript compilation passes with no errors
- All editing type definitions and interfaces are properly exported
- renderEditInput renders correct native HTML input for each of the 5 EditType values
- Edit inputs prevent keyboard event propagation to avoid grid navigation conflicts
- inlineEditingStyles CSS provides compact 32px-height inputs that fit within 48px rows
</success_criteria>

<output>
After completion, create `.planning/phases/65-inline-editing/65-01-SUMMARY.md`
</output>
