---
phase: 65-inline-editing
plan: 03
type: execute
wave: 3
depends_on: ["65-02"]
files_modified:
  - packages/data-table/src/data-table.ts
  - packages/data-table/src/inline-editing.ts
autonomous: true

must_haves:
  truths:
    - "Row edit mode activates via pencil action button on each row (ROWEDIT-01)"
    - "All editable cells in the row become inputs simultaneously (ROWEDIT-02)"
    - "Save and Cancel icon buttons appear in the row during edit mode (ROWEDIT-03)"
    - "Save validates all editable fields before committing (ROWEDIT-04)"
    - "Save dispatches ui-row-edit event with complete row data including old/new values (ROWEDIT-05)"
    - "Only one row can be in edit mode at a time - activating another cancels the first (ROWEDIT-06)"
    - "Row edit and cell edit are mutually exclusive"
  artifacts:
    - path: "packages/data-table/src/data-table.ts"
      provides: "Row-level inline editing with _editingRow state, save/cancel, validation, events"
      contains: "_editingRow"
    - path: "packages/data-table/src/inline-editing.ts"
      provides: "renderRowEditActions function with pencil/save/cancel buttons, rowEditStyles"
      contains: "renderRowEditActions"
  key_links:
    - from: "packages/data-table/src/data-table.ts"
      to: "packages/data-table/src/inline-editing.ts"
      via: "imports renderRowEditActions"
      pattern: "renderRowEditActions"
    - from: "packages/data-table/src/data-table.ts"
      to: "packages/data-table/src/types.ts"
      via: "imports EditingRow, RowEditEvent"
      pattern: "EditingRow"
---

<objective>
Add row-level inline editing to the DataTable component, satisfying ROWEDIT-01 through ROWEDIT-06.

Purpose: Users can click a pencil icon on any row to enter row edit mode, where all editable cells become inputs simultaneously. Save validates all fields and dispatches an event with complete row data. Cancel reverts all changes. Only one row can be in edit mode at a time.

Output: Updated data-table.ts with row editing state management, renderRowEditActions in inline-editing.ts, modified renderRow/renderCell for row edit mode, and ui-row-edit event dispatch.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/65-inline-editing/65-RESEARCH.md
@.planning/phases/65-inline-editing/65-01-SUMMARY.md
@.planning/phases/65-inline-editing/65-02-SUMMARY.md
@packages/data-table/src/data-table.ts
@packages/data-table/src/types.ts
@packages/data-table/src/inline-editing.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add row edit actions renderer and styles to inline-editing.ts</name>
  <files>packages/data-table/src/inline-editing.ts</files>
  <action>
Add the following to inline-editing.ts:

**1. `renderRowEditActions(isEditing, handlers)` function:**
Renders either a pencil edit button (view mode) or save/cancel icon buttons (edit mode).

```typescript
interface RowEditActionHandlers {
  onEdit: () => void;
  onSave: () => void;
  onCancel: () => void;
}

export function renderRowEditActions(
  isEditing: boolean,
  handlers: RowEditActionHandlers
): TemplateResult {
  if (isEditing) {
    return html`
      <div class="row-edit-actions">
        <button
          type="button"
          class="row-edit-save"
          @click=${(e: MouseEvent) => { e.stopPropagation(); handlers.onSave(); }}
          aria-label="Save row changes"
          title="Save"
        >
          <svg viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="3 8 7 12 13 4"/>
          </svg>
        </button>
        <button
          type="button"
          class="row-edit-cancel"
          @click=${(e: MouseEvent) => { e.stopPropagation(); handlers.onCancel(); }}
          aria-label="Cancel row editing"
          title="Cancel"
        >
          <svg viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="4" y1="4" x2="12" y2="12"/>
            <line x1="12" y1="4" x2="4" y2="12"/>
          </svg>
        </button>
      </div>
    `;
  }

  return html`
    <button
      type="button"
      class="row-edit-trigger"
      @click=${(e: MouseEvent) => { e.stopPropagation(); handlers.onEdit(); }}
      aria-label="Edit this row"
      title="Edit row"
    >
      <svg viewBox="0 0 16 16" width="14" height="14" fill="currentColor">
        <path d="M12.1 1.9a1.5 1.5 0 0 1 2.1 2.1L5.6 12.6l-3.2.8.8-3.2L12.1 1.9z"/>
      </svg>
    </button>
  `;
}
```

**2. Add row edit styles to `inlineEditingStyles`:**
Append to the existing CSS in inlineEditingStyles:

```css
/* Row edit action buttons */
.row-edit-actions {
  display: flex;
  align-items: center;
  gap: 4px;
}

.row-edit-trigger,
.row-edit-save,
.row-edit-cancel {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--color-muted-foreground, #71717a);
  transition: background-color 0.15s, color 0.15s;
}

.row-edit-trigger:hover {
  background: var(--ui-data-table-row-hover-bg, #f4f4f5);
  color: var(--ui-data-table-text-color, #09090b);
}

.row-edit-save {
  color: var(--color-success, #22c55e);
}

.row-edit-save:hover {
  background: rgba(34, 197, 94, 0.1);
  color: var(--color-success, #16a34a);
}

.row-edit-cancel {
  color: var(--color-destructive, #ef4444);
}

.row-edit-cancel:hover {
  background: rgba(239, 68, 68, 0.1);
  color: var(--color-destructive, #dc2626);
}

.row-edit-trigger:focus-visible,
.row-edit-save:focus-visible,
.row-edit-cancel:focus-visible {
  outline: 2px solid var(--color-primary, #3b82f6);
  outline-offset: 1px;
}

/* Row in edit mode highlight */
.data-table-row.row-editing {
  background: var(--ui-data-table-editing-bg, rgba(59, 130, 246, 0.06));
}

/* Row edit validation errors */
.row-edit-errors {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
}

/* Dark mode overrides */
:host-context(.dark) .row-edit-trigger:hover {
  background: rgba(255, 255, 255, 0.1);
}

:host-context(.dark) .row-edit-save {
  color: #4ade80;
}

:host-context(.dark) .row-edit-cancel {
  color: #f87171;
}
```

**3. Update index.ts re-exports to include renderRowEditActions:**
```typescript
export { renderEditInput, isColumnEditable, renderEditableIndicator, renderRowEditActions, inlineEditingStyles } from './inline-editing.js';
```
  </action>
  <verify>Run `npx tsc --noEmit -p packages/data-table/tsconfig.json` -- should compile with no errors.</verify>
  <done>inline-editing.ts exports renderRowEditActions with pencil/save/cancel icon buttons and corresponding CSS styles. Re-exported from index.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Add row-level editing state, methods, and rendering to DataTable</name>
  <files>packages/data-table/src/data-table.ts</files>
  <action>
Add the following to data-table.ts:

**1. New imports:**
Add `renderRowEditActions` to the inline-editing.ts import.
Add `EditingRow` and `RowEditEvent` to the types.ts import.

**2. New property to enable row editing:**
```typescript
/**
 * Enable row-level edit mode with pencil/save/cancel action buttons.
 * When true, each row shows a pencil icon that activates edit mode for the entire row.
 * @default false
 */
@property({ type: Boolean, attribute: 'enable-row-editing' })
enableRowEditing = false;
```

**3. New reactive state properties:**
```typescript
// ==========================================================================
// Inline editing state (row level)
// ==========================================================================

/** Currently editing row state. Null when not in row edit mode. */
@state()
private _editingRow: EditingRow | null = null;
```

**4. Row editing methods (add in the inline editing section):**

`activateRowEdit(row: Row<TData>)` method:
- If `_editingCell` is set, cancel it first (`cancelCellEdit()`).
- If `_editingRow` is already set for a different row (ROWEDIT-06), cancel it first (`cancelRowEdit()`).
- If `_editingRow` is already set for THIS row, return (already editing).
- Collect originalData from all visible cells of the row: `Record<string, unknown>` mapping columnId to cell value.
- Set `_editingRow = { rowId: row.id, originalData, pendingValues: { ...originalData }, errors: {} }`.

`updateRowEditValue(columnId: string, value: unknown)` method:
- If `_editingRow` is null, return.
- Update `_editingRow.pendingValues[columnId] = value`.
- Clear any existing error for this column: `delete _editingRow.errors[columnId]`.
- Trigger re-render by reassigning: `this._editingRow = { ...this._editingRow }`.

`saveRowEdit()` method (ROWEDIT-04, ROWEDIT-05):
- If `_editingRow` is null, return.
- Get the table instance and find the row.
- Validate ALL editable fields:
  - For each column with `meta.editValidate`, call it with `(pendingValues[columnId], rowData)`.
  - If ANY validation fails, set `_editingRow.errors[columnId] = message` and trigger re-render. Return without saving.
- If all pass: dispatch `ui-row-edit` CustomEvent with detail:
  ```typescript
  {
    row: rowData,
    rowId: _editingRow.rowId,
    oldValues: _editingRow.originalData,
    newValues: _editingRow.pendingValues,
  } satisfies RowEditEvent<TData>
  ```
- Set `_editingRow = null`.

`cancelRowEdit()` method:
- Set `_editingRow = null`.

**5. Modify renderCell to support row edit mode:**
In the renderCell method (already modified in Plan 02), add a check for row edit mode BEFORE the cell edit check:

```typescript
// Check if this cell is part of a row in edit mode
const isRowEditing = this._editingRow?.rowId === cell.row.id;

if (isRowEditing && isEditable) {
  // Render edit input for row edit mode
  const editType = meta?.editType ?? 'text';
  const pendingValue = this._editingRow!.pendingValues[cell.column.id] ?? cell.getValue();
  const fieldError = this._editingRow!.errors[cell.column.id] ?? null;

  return html`
    <div
      role="gridcell"
      aria-colindex="${colIndex + 1}"
      class="${classes}"
      data-column-id="${cell.column.id}"
      tabindex="${isFocused ? '0' : '-1'}"
    >
      ${renderEditInput(editType, pendingValue, {
        editOptions: meta?.editOptions,
        validationError: fieldError,
      }, {
        onCommit: (value: unknown) => this.updateRowEditValue(cell.column.id, value),
        onCancel: () => {}, // No individual cancel in row mode - use row cancel button
      })}
      ${fieldError ? html`
        <span class="cell-edit-error" role="alert">${fieldError}</span>
      ` : nothing}
    </div>
  `;
}
```

Important: In row edit mode, the commit handler for individual inputs calls `updateRowEditValue` (updates pending state), NOT `commitCellEdit`. The cancel handler is a no-op for individual cells -- the user uses the row-level Cancel button instead. The blur handler on inputs in row edit mode should also call `updateRowEditValue` (save the current value to pending state) rather than committing. This means the onCommit callback in row edit mode just updates the pending value, not dispatches an event.

**6. Modify renderRow to include row edit actions:**
Update the `renderRow` method to include the row edit action buttons and the `row-editing` CSS class:

```typescript
private renderRow(row: Row<TData>, rowIndex: number): TemplateResult {
  const isSelected = row.getIsSelected();
  const isRowEditing = this._editingRow?.rowId === row.id;

  const rowClasses = [
    'data-table-row',
    isSelected ? 'selected' : '',
    isRowEditing ? 'row-editing' : '',
  ].filter(Boolean).join(' ');

  return html`
    <div
      role="row"
      aria-rowindex="${rowIndex + 2}"
      aria-selected="${isSelected}"
      class="${rowClasses}"
      data-row-id="${row.id}"
    >
      ${row.getVisibleCells().map((cell, colIndex) =>
        this.renderCell(cell, rowIndex, colIndex)
      )}
      ${this.enableRowEditing ? html`
        <div class="data-table-cell row-actions-cell" role="gridcell">
          ${renderRowEditActions(isRowEditing, {
            onEdit: () => this.activateRowEdit(row),
            onSave: () => this.saveRowEdit(),
            onCancel: () => this.cancelRowEdit(),
          })}
        </div>
      ` : nothing}
    </div>
  `;
}
```

**7. Update renderAllRows and renderVirtualizedBody to use renderRow:**
Both methods currently inline the row rendering. Refactor them to use the `renderRow` method consistently. For `renderAllRows`, replace the inline template with:
```typescript
${rows.map((row, rowIndex) => html`
  <div style="grid-template-columns: ${gridTemplateColumns};">
    ... // Actually, renderRow is already separate but the inline templates in renderAllRows and renderVirtualizedBody set grid-template-columns on the row div. The renderRow method needs to accept the gridTemplateColumns as a parameter, OR the grid-template-columns style should be set on the row from within renderRow.
  </div>
`)}
```

Actually, looking at the existing code, `renderAllRows` and `renderVirtualizedBody` set `grid-template-columns` on each row div directly, but `renderRow` creates its own div. The simplest fix: have renderRow not wrap in a div (return the cells as a fragment) and keep the wrapping div in the caller, OR modify renderRow to accept a style parameter. The cleanest approach: keep the existing pattern where the callers create the row div with positioning/grid styles, but extract the CONTENTS (cells + row actions) into renderRow.

Actually the simplest approach is to NOT use the existing renderRow method for renderAllRows/renderVirtualizedBody (they have different styling needs), but instead add the row edit action cell directly in the existing rendering templates in both methods. Add the row edit actions cell at the end of each row's cell mapping.

For `renderAllRows`:
After `${row.getVisibleCells().map((cell, colIndex) => this.renderCell(cell, rowIndex, colIndex))}`, add:
```typescript
${this.enableRowEditing ? html`
  <div class="data-table-cell row-actions-cell" role="gridcell">
    ${renderRowEditActions(this._editingRow?.rowId === row.id, {
      onEdit: () => this.activateRowEdit(row),
      onSave: () => this.saveRowEdit(),
      onCancel: () => this.cancelRowEdit(),
    })}
  </div>
` : nothing}
```
Same for `renderVirtualizedBody`.

Also add the `row-editing` class to the row div when `_editingRow?.rowId === row.id`.

**8. Update grid-template-columns for row edit action column:**
When `enableRowEditing` is true, append a fixed-width column for the actions:
- In `getGridTemplateColumns()`, if `this.enableRowEditing`, append ` 72px` to the result (enough for pencil button or save+cancel buttons).
- This ensures the action column has proper width in the grid layout.

**9. Update header to include empty header cell for row edit column:**
In `renderHeader`, when `enableRowEditing` is true, add an empty column header at the end:
```typescript
${this.enableRowEditing ? html`
  <div role="columnheader" class="data-table-header-cell" aria-label="Row actions">
  </div>
` : nothing}
```

**10. Update navigation bounds for row edit column:**
In the `updated` lifecycle, when calculating `colCount`, also account for the row edit actions column:
```typescript
let colCount = this.columns.length;
if (this.enableSelection) colCount += 1;
if (this.enableRowEditing) colCount += 1;
```

**11. Add keyboard shortcut for row edit save (Ctrl+Enter from within a row being edited):**
This is optional but good UX. In handleKeyDown, if a row is being edited and user presses Ctrl+Enter or Cmd+Enter, save the row edit. This is a stretch goal -- only implement if there's time. The core requirement is the Save button.

**12. Mutual exclusion between cell edit and row edit:**
- In `activateCellEdit`: add guard `if (this._editingRow) return;` at the top.
- In `activateRowEdit`: add `if (this._editingCell) this.cancelCellEdit();` at the top.
This ensures cell edit and row edit cannot be active simultaneously.
  </action>
  <verify>
1. `npx tsc --noEmit -p packages/data-table/tsconfig.json` compiles without errors
2. Check that _editingRow state exists and is used in rendering
3. Check that renderRowEditActions is called in both renderAllRows and renderVirtualizedBody
4. Check that saveRowEdit validates all fields before dispatching ui-row-edit event
5. Check mutual exclusion guards between cell edit and row edit
  </verify>
  <done>DataTable has enable-row-editing property, _editingRow state, activateRowEdit/saveRowEdit/cancelRowEdit methods, row action buttons (pencil/save/cancel), per-field validation on save, ui-row-edit event dispatch, and mutual exclusion with cell-level editing. All ROWEDIT-01 through ROWEDIT-06 requirements are addressed.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/data-table/tsconfig.json` compiles without errors
2. Row edit mode activates via pencil icon button (ROWEDIT-01)
3. All editable cells in the row become inputs when row edit is active (ROWEDIT-02)
4. Save and Cancel icon buttons appear during row edit mode (ROWEDIT-03)
5. Save validates all editable fields -- errors display inline on failing fields (ROWEDIT-04)
6. Save dispatches ui-row-edit event with row, rowId, oldValues, newValues (ROWEDIT-05)
7. Activating row edit on one row cancels any other row's edit mode (ROWEDIT-06)
8. Cell edit and row edit are mutually exclusive
9. Row edit action column has proper width in grid layout
10. Navigation bounds updated to account for row actions column
</verification>

<success_criteria>
- All row-level editing requirements ROWEDIT-01 through ROWEDIT-06 implemented
- TypeScript compilation passes
- Pencil icon triggers row edit mode on each row
- Save validates all editable fields before committing
- Cancel reverts to original values
- ui-row-edit event dispatched on successful save
- Only one row in edit mode at a time
- Cell edit and row edit cannot be active simultaneously
- Row edit works with both virtualized and non-virtualized rendering
</success_criteria>

<output>
After completion, create `.planning/phases/65-inline-editing/65-03-SUMMARY.md`
</output>
