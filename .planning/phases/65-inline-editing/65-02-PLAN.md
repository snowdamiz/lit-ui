---
phase: 65-inline-editing
plan: 02
type: execute
wave: 2
depends_on: ["65-01"]
files_modified:
  - packages/data-table/src/data-table.ts
autonomous: true

must_haves:
  truths:
    - "Editable cells show a pencil indicator on hover/focus (EDIT-01)"
    - "Clicking an already-focused editable cell activates edit mode with appropriate input (EDIT-02, EDIT-03)"
    - "Enter commits the edit, Escape cancels, blur commits (EDIT-04)"
    - "Validation errors display inline below the cell without changing row height (EDIT-05)"
    - "Cell edit dispatches ui-cell-edit event with rowId, columnId, oldValue, newValue (EDIT-06)"
    - "Enter/F2 on a focused editable cell activates edit mode via keyboard (EDIT-02)"
    - "Only one cell can be in edit mode at a time"
  artifacts:
    - path: "packages/data-table/src/data-table.ts"
      provides: "Cell-level inline editing with edit state, rendering, commit/cancel, validation, events"
      contains: "_editingCell"
  key_links:
    - from: "packages/data-table/src/data-table.ts"
      to: "packages/data-table/src/inline-editing.ts"
      via: "imports renderEditInput, isColumnEditable, renderEditableIndicator, inlineEditingStyles"
      pattern: "import.*inline-editing"
    - from: "packages/data-table/src/data-table.ts"
      to: "packages/data-table/src/types.ts"
      via: "imports EditingCell, CellEditEvent, EditValidationResult"
      pattern: "import.*EditingCell"
---

<objective>
Integrate cell-level inline editing into the DataTable component, satisfying EDIT-01 through EDIT-07.

Purpose: Users can click on editable cells to activate inline editing with the appropriate input type, commit via Enter/blur, cancel via Escape, see validation errors inline, and receive events with old/new values for persistence handling.

Output: Updated data-table.ts with cell editing state management, modified renderCell for edit mode, keyboard integration, and ui-cell-edit event dispatch.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/65-inline-editing/65-RESEARCH.md
@.planning/phases/65-inline-editing/65-01-SUMMARY.md
@packages/data-table/src/data-table.ts
@packages/data-table/src/types.ts
@packages/data-table/src/inline-editing.ts
@packages/data-table/src/keyboard-navigation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cell-level editing state and methods to DataTable</name>
  <files>packages/data-table/src/data-table.ts</files>
  <action>
Add the following to data-table.ts:

**1. New imports from inline-editing.ts and types.ts:**
```typescript
import { renderEditInput, isColumnEditable, renderEditableIndicator, inlineEditingStyles } from './inline-editing.js';
import type { EditingCell, CellEditEvent, EditValidationResult, LitUIColumnMeta } from './types.js';
```

**2. Add inlineEditingStyles to the static styles array:**
```typescript
static override styles = [
  ...tailwindBaseStyles,
  columnPickerStyles,
  inlineEditingStyles,  // ADD THIS
  css`...existing styles...`
];
```

**3. New reactive state properties (add in the section before lifecycle methods):**
```typescript
// ==========================================================================
// Inline editing state (cell level)
// ==========================================================================

/** Currently editing cell state. Null when not editing. */
@state()
private _editingCell: EditingCell | null = null;

/** Validation error for the currently editing cell. */
@state()
private _cellValidationError: string | null = null;

/** Guard flag to prevent double-commit from Enter + blur race condition. */
private _isCommitting = false;
```

**4. New methods for cell editing (add in a new section before render methods):**

`activateCellEdit(pos: GridPosition)` method:
- Get the cell's column and row from the table instance. To get the table, use the pattern from render() -- call `this.tableController.table(...)` with current state. However, since the table is created in render(), store a reference: add a private field `private _tableInstance?: Table<TData>` and set it in render() right after `const table = this.tableController.table(...)`. Then use `this._tableInstance` in edit methods.
- Check if the column at pos.col is editable using `isColumnEditable(meta, rowData)`.
- If not editable, return without action.
- If `_editingCell` is already set (another cell is being edited), commit the current edit first (call `commitCellEdit` with the current input value -- but since we may not have the DOM input yet, just cancel the current edit via `cancelCellEdit()`).
- If `_editingRow` is set, return (don't allow cell edit while row edit is active).
- Set `_editingCell = { rowId, columnId, originalValue }` where originalValue is from the cell's current value.
- Clear `_cellValidationError`.
- After requestUpdate, focus the edit input (the renderCell method will render it).

`commitCellEdit(newValue: unknown)` method:
- If `_isCommitting` or `_editingCell` is null, return.
- Set `_isCommitting = true`.
- Get column meta and row data from the table instance.
- If `meta.editValidate` exists, call it with `(newValue, rowData)`.
  - If result is `false` or `{ valid: false, message?: string }`:
    - Set `_cellValidationError` to the message or 'Invalid value'.
    - Set `_isCommitting = false`.
    - Return (stay in edit mode).
- If value hasn't changed (newValue === originalValue, using loose comparison for type coercion), just cancel edit silently.
- Dispatch `ui-cell-edit` CustomEvent with detail: `{ row: rowData, rowId, columnId, oldValue: originalValue, newValue }` satisfying CellEditEvent type.
- Set `_editingCell = null` and `_cellValidationError = null`.
- Set `_isCommitting = false`.
- Restore focus to the grid cell at the edit position.

`cancelCellEdit()` method:
- Set `_editingCell = null`.
- Set `_cellValidationError = null`.
- Set `_isCommitting = false`.
- Restore focus to the grid cell at the previous edit position.

**5. Modify handleKeyDown to support edit mode activation:**
Add BEFORE the existing `const newPos = this.navManager.handleKeyDown(e);` call:

```typescript
// Enter or F2 on a focused cell activates edit mode (EDIT-02)
if ((e.key === 'Enter' || e.key === 'F2') && !this._editingCell && !this._editingRow) {
  const pos = this.navManager.getPosition();
  this.activateCellEdit(pos);
  e.preventDefault();
  return;
}
```

The existing `isInteractiveElement` check at the top of handleKeyDown already prevents navigation keys from firing when an edit input is focused. This is sufficient -- no additional changes needed for EDIT-07 (arrow keys in edit inputs are handled natively by the input, and won't trigger grid nav because the input is an interactive element).

**6. Modify handleCellClick to support click-to-edit:**
In the existing `handleCellClick(rowIndex, colIndex)` method, add logic:
- If the clicked cell is already focused (`_focusedCell.row === rowIndex && _focusedCell.col === colIndex`), and the cell is editable, activate edit mode.
- This implements "click on already-focused cell to edit" pattern (avoids conflict with first click that sets focus).
- If a different cell was being edited, the activateCellEdit method handles canceling the previous edit.

```typescript
private handleCellClick(rowIndex: number, colIndex: number): void {
  const wasFocused = this._focusedCell.row === rowIndex && this._focusedCell.col === colIndex;

  this._focusedCell = { row: rowIndex, col: colIndex };
  this.navManager.setPosition(this._focusedCell);
  this.updateRovingTabindex(this._focusedCell);

  // Click on already-focused editable cell activates edit mode (EDIT-02)
  if (wasFocused && !this._editingCell && !this._editingRow) {
    this.activateCellEdit({ row: rowIndex, col: colIndex });
  }
}
```
  </action>
  <verify>Run `npx tsc --noEmit -p packages/data-table/tsconfig.json` -- should compile with no errors.</verify>
  <done>DataTable has _editingCell state, activateCellEdit, commitCellEdit, cancelCellEdit methods. handleKeyDown supports Enter/F2 to edit. handleCellClick supports click-on-focused-cell to edit. ui-cell-edit event is dispatched on commit.</done>
</task>

<task type="auto">
  <name>Task 2: Modify renderCell for edit mode rendering with validation display</name>
  <files>packages/data-table/src/data-table.ts</files>
  <action>
Modify the existing `renderCell` method to support edit mode and editable indicators:

**1. Update renderCell to detect edit mode and editable state:**

```typescript
private renderCell(
  cell: Cell<TData, unknown>,
  rowIndex: number,
  colIndex: number
): TemplateResult {
  const meta = cell.column.columnDef.meta as LitUIColumnMeta<TData> | undefined;
  const rowData = cell.row.original;
  const isEditable = isColumnEditable(meta, rowData);
  const isEditing = this._editingCell?.rowId === cell.row.id
    && this._editingCell?.columnId === cell.column.id;
  const isFocused = this._focusedCell.row === rowIndex && this._focusedCell.col === colIndex;

  // Build CSS class list
  const classes = [
    'data-table-cell',
    isEditable ? 'editable' : '',
    isEditing ? 'editing' : '',
  ].filter(Boolean).join(' ');

  if (isEditing) {
    // Render edit input instead of cell content
    const editType = meta?.editType ?? 'text';
    const currentValue = cell.getValue();
    return html`
      <div
        role="gridcell"
        aria-colindex="${colIndex + 1}"
        class="${classes}"
        data-column-id="${cell.column.id}"
        tabindex="${isFocused ? '0' : '-1'}"
      >
        ${renderEditInput(editType, currentValue, {
          editOptions: meta?.editOptions,
          validationError: this._cellValidationError,
        }, {
          onCommit: (value: unknown) => this.commitCellEdit(value),
          onCancel: () => this.cancelCellEdit(),
        })}
        ${this._cellValidationError ? html`
          <span class="cell-edit-error" role="alert">${this._cellValidationError}</span>
        ` : nothing}
      </div>
    `;
  }

  // Normal view mode
  const cellContent = flexRender(cell.column.columnDef.cell, cell.getContext());
  return html`
    <div
      role="gridcell"
      aria-colindex="${colIndex + 1}"
      class="${classes}"
      data-column-id="${cell.column.id}"
      tabindex="${isFocused ? '0' : '-1'}"
      @click=${() => this.handleCellClick(rowIndex, colIndex)}
    >
      ${cellContent}
      ${isEditable ? renderEditableIndicator() : nothing}
    </div>
  `;
}
```

Key considerations:
- The `editable` CSS class enables the hover pencil indicator (EDIT-01) via styles in inline-editing.ts.
- The `editing` CSS class changes cell padding and overflow for edit inputs.
- The `@click` handler is only on view-mode cells. Edit-mode cells handle their own events via input handlers.
- Validation error is rendered as an absolutely-positioned `<span>` below the cell (EDIT-05) without changing row height.
- The error span has `role="alert"` for screen reader announcement.

**2. Ensure renderCell in both renderAllRows and renderVirtualizedBody passes through correctly:**
Both `renderAllRows` and `renderVirtualizedBody` already call `this.renderCell(cell, rowIndex, colIndex)` -- no changes needed to those methods.

**3. Add the _tableInstance reference:**
In the render() method, right after `const table = this.tableController.table({...});`, add:
```typescript
this._tableInstance = table;
```
Add the private field near the top of the class:
```typescript
/** Reference to current table instance for use outside render(). */
private _tableInstance?: Table<TData>;
```

**4. Ensure the edit cell retains focus when re-rendered:**
When `_editingCell` state changes, Lit will re-render the cell. The `renderEditInput` function (from Plan 01) handles auto-focus via a ref callback using `requestAnimationFrame`. This ensures the input regains focus after render.

**5. Handle blur-commit with guard:**
The `commitCellEdit` method already has the `_isCommitting` guard flag. Ensure that when Enter triggers commit, the subsequent blur event finds `_editingCell === null` (since commitCellEdit clears it) and does nothing. The `renderEditInput` blur handler should check `_editingCell` is still set before committing -- but since the handlers are closures passed to renderEditInput, the onCommit callback (which calls `this.commitCellEdit`) already checks `_editingCell !== null` as its first line.
  </action>
  <verify>Run `npx tsc --noEmit -p packages/data-table/tsconfig.json` -- should compile with no errors. Verify that renderCell handles both view mode (with editable indicator) and edit mode (with renderEditInput).</verify>
  <done>renderCell renders editable cells with pencil indicator in view mode and appropriate edit input in edit mode. Validation errors display inline below the cell. Edit commit dispatches ui-cell-edit event. Click-on-focused-cell and Enter/F2 keyboard activation both work. All EDIT-01 through EDIT-07 requirements are addressed.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/data-table/tsconfig.json` compiles without errors
2. Editable cells show pencil icon on hover/focus (EDIT-01)
3. Click on already-focused editable cell activates edit mode (EDIT-02)
4. Enter/F2 on focused editable cell activates edit mode (EDIT-02)
5. Edit mode renders correct input type based on editType meta (EDIT-03)
6. Enter commits, Escape cancels, blur commits with guard (EDIT-04)
7. Validation errors show below cell without changing row height (EDIT-05)
8. ui-cell-edit event fires with row, rowId, columnId, oldValue, newValue (EDIT-06)
9. Arrow keys in edit input move cursor (not grid) because isInteractiveElement returns true for INPUT/SELECT (EDIT-07)
10. Only one cell can be in edit mode at a time
</verification>

<success_criteria>
- All cell-level editing requirements EDIT-01 through EDIT-07 implemented
- TypeScript compilation passes
- Edit state tracked in _editingCell reactive property
- Edit mode renders native HTML inputs via renderEditInput
- Validation errors display inline with absolute positioning
- ui-cell-edit event dispatched on successful commit
- Keyboard and click activation both functional
- No conflicts with existing grid navigation
</success_criteria>

<output>
After completion, create `.planning/phases/65-inline-editing/65-02-SUMMARY.md`
</output>
