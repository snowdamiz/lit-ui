---
phase: 58-tabs-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/tabs/package.json
  - packages/tabs/tsconfig.json
  - packages/tabs/vite.config.ts
  - packages/tabs/src/vite-env.d.ts
  - packages/tabs/src/tabs.ts
  - packages/tabs/src/tab-panel.ts
  - packages/tabs/src/index.ts
  - packages/tabs/src/jsx.d.ts
autonomous: true

must_haves:
  truths:
    - "User can click a tab to show its corresponding panel, hiding all other panels"
    - "Tabs container renders tab buttons from slotted TabPanel metadata (value, label)"
    - "Active tab state is manageable via value (controlled) or default-value (uncontrolled)"
    - "Adding or removing tab-panel elements dynamically updates the tab buttons"
    - "Switching tabs dispatches a ui-change event with the new value"
  artifacts:
    - path: "packages/tabs/src/tabs.ts"
      provides: "Tabs container element with tablist rendering and state management"
      min_lines: 80
    - path: "packages/tabs/src/tab-panel.ts"
      provides: "TabPanel child element with show/hide via active attribute"
      min_lines: 25
    - path: "packages/tabs/src/index.ts"
      provides: "Element registration and exports"
      exports: ["Tabs", "TabPanel"]
    - path: "packages/tabs/package.json"
      provides: "Package config with peer deps on lit and @lit-ui/core"
      contains: "@lit-ui/tabs"
  key_links:
    - from: "packages/tabs/src/tabs.ts"
      to: "packages/tabs/src/tab-panel.ts"
      via: "slotchange discovery, reads value/label/disabled attributes"
      pattern: "tagName.*LUI-TAB-PANEL"
    - from: "packages/tabs/src/tabs.ts"
      to: "@lit-ui/core"
      via: "TailwindElement base class, dispatchCustomEvent"
      pattern: "import.*TailwindElement.*@lit-ui/core"
---

<objective>
Create the @lit-ui/tabs package with `lui-tabs` container and `lui-tab-panel` child elements. The container discovers tab-panel children via slotchange, reads their `value` and `label` attributes, and renders tab buttons inside its shadow DOM tablist. Clicking a tab activates the corresponding panel. Supports controlled (value) and uncontrolled (default-value) modes.

Purpose: Establish the core tabs structure so Plan 02 can add keyboard navigation, activation modes, orientation, ARIA, disabled tabs, and CSS theming on top of a working foundation.
Output: Working package scaffold with clickable tabs that show/hide panels and dispatch ui-change events.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/58-tabs-core/58-RESEARCH.md

# Reference implementations (read these for exact patterns):
@packages/accordion/package.json
@packages/accordion/tsconfig.json
@packages/accordion/vite.config.ts
@packages/accordion/src/vite-env.d.ts
@packages/accordion/src/index.ts
@packages/accordion/src/jsx.d.ts
@packages/accordion/src/accordion.ts
@packages/accordion/src/accordion-item.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Package scaffold and TabPanel element</name>
  <files>
    packages/tabs/package.json
    packages/tabs/tsconfig.json
    packages/tabs/vite.config.ts
    packages/tabs/src/vite-env.d.ts
    packages/tabs/src/tab-panel.ts
  </files>
  <action>
    Create the @lit-ui/tabs package by copying the accordion package structure exactly:

    1. **package.json**: Copy from `packages/accordion/package.json`. Change name to `@lit-ui/tabs`, description to "Accessible tabs component built with Lit and Tailwind CSS", keyword "accordion" to "tabs". Everything else identical (peer deps, dev deps, exports, scripts, sideEffects).

    2. **tsconfig.json**: Identical to accordion's tsconfig.json.

    3. **vite.config.ts**: Identical to accordion's vite.config.ts (`createLibraryConfig({ entry: 'src/index.ts' })`).

    4. **src/vite-env.d.ts**: Identical (`/// <reference types="vite/client" />`).

    5. **src/tab-panel.ts**: Create the `lui-tab-panel` element — a minimal content wrapper. Pattern follows accordion-item but MUCH simpler since the container renders tab buttons, not the child.

    ```typescript
    // TabPanel is a simple show/hide wrapper. Container manages all behavior.
    // Properties: value (string), label (string), disabled (boolean), active (boolean, reflect)
    // When active is false, the host is display:none
    // The element dispatches 'ui-tab-panel-update' internal event when label or disabled changes
    //   so the container can re-render tab buttons
    // Styles: :host { display: block; } :host(:not([active])) { display: none; }
    // Render: just <slot></slot>
    ```

    Key details for tab-panel.ts:
    - Extend TailwindElement, import tailwindBaseStyles
    - `value` property: `@property({ type: String })` — identifier for this panel
    - `label` property: `@property({ type: String })` — text shown in the tab button
    - `disabled` property: `@property({ type: Boolean })` — skipped in keyboard nav
    - `active` property: `@property({ type: Boolean, reflect: true })` — set by container
    - In `updated()`, when `label` or `disabled` changes, dispatch `dispatchCustomEvent(this, 'ui-tab-panel-update', {})` so container re-renders tab buttons
    - Static styles: `:host { display: block; }` and `:host(:not([active])) { display: none; }`
    - render(): `html\`<slot></slot>\``
    - Generate unique ID: `private panelId = \`lui-tp-\${Math.random().toString(36).substr(2, 9)}\``

    Run `cd packages/tabs && pnpm install` to verify workspace resolution.
  </action>
  <verify>
    - `ls packages/tabs/src/tab-panel.ts packages/tabs/package.json packages/tabs/tsconfig.json packages/tabs/vite.config.ts` all exist
    - `grep "@lit-ui/tabs" packages/tabs/package.json` returns match
    - `grep "TailwindElement" packages/tabs/src/tab-panel.ts` returns match
    - `grep "display: none" packages/tabs/src/tab-panel.ts` returns match
  </verify>
  <done>
    Package scaffold exists with correct structure. TabPanel element is a minimal show/hide wrapper with value, label, disabled, and active properties. Internal update event dispatched when label/disabled changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tabs container with tablist rendering and active state management</name>
  <files>
    packages/tabs/src/tabs.ts
    packages/tabs/src/index.ts
    packages/tabs/src/jsx.d.ts
  </files>
  <action>
    Create the `lui-tabs` container element and supporting files.

    **src/tabs.ts** — The core container that renders the tablist and manages active tab state. Follow the accordion.ts pattern for structure but with these KEY DIFFERENCES:

    1. **Container-rendered tablist**: Unlike accordion (where each child renders its own trigger), tabs renders ALL tab buttons inside its own shadow DOM. This is required because role="tab" elements must be siblings under a single role="tablist".

    2. **Properties**:
       - `value`: string — active tab value (controlled mode)
       - `defaultValue`: string, attribute `default-value` — initial active tab (uncontrolled mode)
       - `disabled`: boolean, reflect — disable all tabs
       - `label`: string — aria-label for the tablist (optional, for when tablist lacks visible label)
       - `orientation`: `'horizontal' | 'vertical'` — defaults to `'horizontal'` (Plan 02 will add keyboard orientation logic; this plan just declares the property)
       - `activationMode`: `'automatic' | 'manual'` attribute `activation-mode` — defaults to `'automatic'` (Plan 02 will implement keyboard activation logic; this plan just declares the property)

    3. **Private state**:
       - `panels`: `TabPanel[]` — discovered child elements (NOT @state, just a class field; call `requestUpdate()` when it changes)
       - `tabsId`: unique ID string for ARIA associations: `lui-tabs-${Math.random().toString(36).substr(2, 9)}`

    4. **Child discovery** — `handleSlotChange(e: Event)`:
       - Get assigned elements from default slot, filter for tagName `LUI-TAB-PANEL`
       - Store as `this.panels`
       - Call `this.requestUpdate()` to re-render tab buttons
       - Call `this.syncPanelStates()` to update active state on panels
       - If `!this.value && this.panels.length > 0`, auto-select the first non-disabled panel

    5. **SSR slotchange workaround** — `firstUpdated()`:
       - Same pattern as accordion: manually dispatch slotchange on the default slot if `!isServer`

    6. **connectedCallback**: If `defaultValue` and no `value`, set `value = defaultValue`

    7. **updated(changedProperties)**: When `value` changes, call `syncPanelStates()`

    8. **Tab click handling** — `handleTabClick(panelValue: string, panelDisabled: boolean)`:
       - If disabled or panelDisabled, return
       - Set `this.value = panelValue`
       - Call `syncPanelStates()`
       - Dispatch `dispatchCustomEvent(this, 'ui-change', { value: this.value })`

    9. **Panel state sync** — `syncPanelStates()`:
       - For each panel in this.panels: `panel.active = (panel.value === this.value)`

    10. **Handle panel update events** — listen for `ui-tab-panel-update` on the wrapper div:
        - Call `this.requestUpdate()` to re-render tab buttons with fresh label/disabled values

    11. **render()**:
        ```
        <div class="tabs-wrapper" @ui-tab-panel-update=${() => this.requestUpdate()}>
          <div role="tablist" aria-orientation="${this.orientation}" aria-label="${this.label || nothing}">
            ${this.panels.map(panel => html`
              <button
                id="${this.tabsId}-tab-${panel.value}"
                role="tab"
                aria-selected="${panel.value === this.value ? 'true' : 'false'}"
                aria-controls="${this.tabsId}-panel-${panel.value}"
                aria-disabled="${panel.disabled ? 'true' : nothing}"
                tabindex="${panel.value === this.value ? '0' : '-1'}"
                class="tab-button ${panel.value === this.value ? 'tab-active' : ''}"
                @click=${() => this.handleTabClick(panel.value, panel.disabled)}
              >${panel.label}</button>
            `)}
          </div>
          <div class="panels-container">
            <slot @slotchange=${this.handleSlotChange}></slot>
          </div>
        </div>
        ```

    12. **Static styles** — Minimal structural CSS only (no theming tokens yet — Plan 02 adds those):
        ```css
        :host { display: block; }
        :host([disabled]) { opacity: 0.5; pointer-events: none; }
        .tab-button {
          border: none;
          background: transparent;
          cursor: pointer;
          font-family: inherit;
          font-size: inherit;
          padding: 0.5rem 1rem;
        }
        .tab-button:focus-visible { outline: 2px solid currentColor; outline-offset: -2px; }
        ```

    IMPORTANT for ARIA cross-boundary: Tab buttons are in shadow DOM. Panels are in light DOM (slotted). `aria-controls` on tab buttons references panel IDs that won't resolve cross-boundary. This is a known limitation accepted by most tabs implementations (Shoelace, Radix). The `role="tab"` + `aria-selected` semantics provide sufficient screen reader context. In Plan 02, the container will also set `role="tabpanel"` and `aria-labelledby` on the panel host elements programmatically (which ARE in light DOM and can reference shadow DOM IDs via `aria-labelledby` pointing to nothing — or better, the container sets these as informational attributes on the host).

    Actually — the RESEARCH recommends panels set `role="tabpanel"` on their own host. Do this in tab-panel.ts connectedCallback: `this.setAttribute('role', 'tabpanel')`. The container sets `id` and `aria-labelledby` on each panel host in `syncPanelStates()`:
    - `panel.id = \`${this.tabsId}-panel-${panel.value}\``
    - `panel.setAttribute('aria-labelledby', \`${this.tabsId}-tab-${panel.value}\`)`

    This way `aria-controls` on tab buttons (shadow DOM) points to panel IDs in light DOM, and `aria-labelledby` on panels (light DOM) points to tab button IDs in shadow DOM. The cross-boundary references are best-effort — modern screen readers handle `aria-selected` + role semantics regardless.

    **src/index.ts** — Follow accordion's index.ts pattern exactly:
    - Export Tabs and TabPanel classes
    - Re-export TailwindElement, isServer from @lit-ui/core
    - Register `lui-tabs` and `lui-tab-panel` custom elements with collision detection
    - Declare HTMLElementTagNameMap

    **src/jsx.d.ts** — Follow accordion's jsx.d.ts pattern:
    - LuiTabsAttributes: value, default-value, disabled, label, orientation, activation-mode
    - LuiTabPanelAttributes: value, label, disabled, active
    - React, Vue, Svelte declarations for both elements
    - Svelte event: `on:ui-change` on lui-tabs

    After creating all files, run `cd packages/tabs && pnpm build` to verify compilation.
  </action>
  <verify>
    - `cd packages/tabs && pnpm build` completes without errors
    - `ls packages/tabs/dist/index.js packages/tabs/dist/index.d.ts` exist
    - `grep "role=\"tablist\"" packages/tabs/src/tabs.ts` returns match
    - `grep "handleSlotChange" packages/tabs/src/tabs.ts` returns match
    - `grep "ui-change" packages/tabs/src/tabs.ts` returns match
    - `grep "customElements.define" packages/tabs/src/index.ts` returns 2 matches (lui-tabs, lui-tab-panel)
  </verify>
  <done>
    Tabs container renders tab buttons from slotted TabPanel metadata. Clicking a tab activates the corresponding panel and hides others. Controlled (value) and uncontrolled (default-value) modes work. ui-change event fires on tab switch. Dynamic panel add/remove handled via slotchange. Package builds successfully.
  </done>
</task>

</tasks>

<verification>
1. Package builds: `cd packages/tabs && pnpm build` succeeds
2. All source files exist: tabs.ts, tab-panel.ts, index.ts, jsx.d.ts
3. Tab buttons rendered from panel metadata (grep for role="tablist" and role="tab")
4. Active state management (grep for syncPanelStates, panel.active)
5. Event dispatching (grep for ui-change)
6. SSR workaround (grep for firstUpdated and slotchange)
</verification>

<success_criteria>
- @lit-ui/tabs package scaffold matches accordion package structure
- lui-tabs container renders tab buttons from slotted lui-tab-panel metadata
- Clicking a tab button activates the corresponding panel and hides others
- value and default-value properties control active tab
- ui-change event dispatched on tab switch
- Dynamic panel add/remove updates tab buttons via slotchange
- Package compiles and builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/58-tabs-core/58-01-SUMMARY.md`
</output>
