---
phase: 64-column-customization
plan: 03
type: execute
wave: 2
depends_on: ["64-01"]
files_modified:
  - packages/data-table/src/data-table.ts
autonomous: true

must_haves:
  truths:
    - "User can drag column header to reorder columns"
    - "Visual feedback shows during drag operation"
    - "First column stays fixed during horizontal scroll when sticky enabled"
  artifacts:
    - path: "packages/data-table/src/data-table.ts"
      provides: "Column reorder via drag-and-drop and sticky first column CSS"
      contains: "columnOrder"
  key_links:
    - from: "data-table.ts header cell"
      to: "HTML5 drag events"
      via: "draggable attribute and drag handlers"
      pattern: "dragstart|dragover|drop"
    - from: "data-table.ts sticky CSS"
      to: ":host([sticky-first-column])"
      via: "CSS position: sticky"
      pattern: "sticky-first-column"
---

<objective>
Implement column reordering via drag-and-drop and sticky first column support.

Purpose: Users need to arrange columns in their preferred order and keep key columns visible during horizontal scroll. Drag-and-drop provides intuitive reordering, while sticky columns ensure important data stays visible.

Output: Column reorder with visual drag feedback, sticky first column CSS.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/64-column-customization/64-RESEARCH.md
@.planning/phases/64-column-customization/64-01-SUMMARY.md
@packages/data-table/src/data-table.ts
@packages/data-table/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add column ordering state and TanStack integration</name>
  <files>packages/data-table/src/data-table.ts, packages/data-table/src/types.ts</files>
  <action>
1. In types.ts:
   - Verify ColumnOrderState is re-exported from @tanstack/lit-table

2. In data-table.ts:
   - Add @property columnOrder: ColumnOrderState = [] (string[] of column IDs)
   - Add @property enableColumnReorder = false (boolean to enable drag-and-drop)
   - Add @state _draggedColumnId: string | null = null (for visual feedback)
   - Add @state _dropTargetColumnId: string | null = null (for drop indicator)

3. Update tableController.table() options:
   - Add state: { columnOrder: this.columnOrder } (merge with existing)
   - Add onColumnOrderChange callback:
     ```typescript
     onColumnOrderChange: (updater) => {
       const newOrder = typeof updater === 'function'
         ? updater(this.columnOrder)
         : updater;
       this.columnOrder = newOrder;
       this.dispatchEvent(new CustomEvent('ui-column-order-change', {
         detail: { columnOrder: newOrder },
         bubbles: true,
         composed: true,
       }));
     }
     ```

NOTE: Empty columnOrder array means use default column definition order. TanStack handles this automatically.
  </action>
  <verify>
```bash
cd packages/data-table && pnpm build
```
  </verify>
  <done>
- columnOrder property accepts external order state
- TanStack table options include ordering configuration
- ui-column-order-change event fires on order changes
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement drag-and-drop column reorder in headers</name>
  <files>packages/data-table/src/data-table.ts</files>
  <action>
1. Add drag event handlers:
   ```typescript
   private handleDragStart(e: DragEvent, columnId: string): void {
     if (!this.enableColumnReorder) return;

     this._draggedColumnId = columnId;
     e.dataTransfer?.setData('text/plain', columnId);
     e.dataTransfer!.effectAllowed = 'move';

     // Add dragging class after a frame (prevents immediate cancel)
     requestAnimationFrame(() => {
       this.dataset.dragging = 'true';
     });
   }

   private handleDragOver(e: DragEvent, columnId: string): void {
     if (!this.enableColumnReorder || !this._draggedColumnId) return;
     if (columnId === this._draggedColumnId) return;

     e.preventDefault();
     e.dataTransfer!.dropEffect = 'move';
     this._dropTargetColumnId = columnId;
   }

   private handleDragLeave(e: DragEvent): void {
     // Only clear if leaving the header cell entirely
     const relatedTarget = e.relatedTarget as HTMLElement;
     if (!relatedTarget?.closest('.data-table-header-cell')) {
       this._dropTargetColumnId = null;
     }
   }

   private handleDrop(e: DragEvent, targetColumnId: string): void {
     e.preventDefault();
     if (!this._draggedColumnId || this._draggedColumnId === targetColumnId) {
       this.resetDragState();
       return;
     }

     // Get current column order (or default from visible columns)
     const table = this.tableController.table({...}); // Need table reference
     const currentOrder = this.columnOrder.length > 0
       ? [...this.columnOrder]
       : table.getAllLeafColumns().map(c => c.id);

     // Find indices
     const draggedIndex = currentOrder.indexOf(this._draggedColumnId);
     const targetIndex = currentOrder.indexOf(targetColumnId);

     if (draggedIndex === -1 || targetIndex === -1) {
       this.resetDragState();
       return;
     }

     // Reorder: remove dragged, insert at target position
     currentOrder.splice(draggedIndex, 1);
     currentOrder.splice(targetIndex, 0, this._draggedColumnId);

     // Update state via TanStack
     this.columnOrder = currentOrder;
     this.resetDragState();
   }

   private handleDragEnd(): void {
     this.resetDragState();
   }

   private resetDragState(): void {
     this._draggedColumnId = null;
     this._dropTargetColumnId = null;
     delete this.dataset.dragging;
   }
   ```

2. Update renderHeaderCell() to add drag attributes and handlers:
   - Add draggable="${this.enableColumnReorder && !isResizing}"
   - Add class for drop target: ${this._dropTargetColumnId === header.column.id ? 'drop-target' : ''}
   - Add class for dragging: ${this._draggedColumnId === header.column.id ? 'is-dragging' : ''}
   - Add @dragstart, @dragover, @dragleave, @drop, @dragend handlers
   - NOTE: Disable drag during resize (check header.column.getIsResizing())

3. Add drag feedback CSS:
   ```css
   .data-table-header-cell[draggable="true"] {
     cursor: grab;
   }

   .data-table-header-cell.is-dragging {
     opacity: 0.5;
     cursor: grabbing;
   }

   .data-table-header-cell.drop-target {
     background: var(--color-primary-100, rgba(59, 130, 246, 0.1));
     border-left: 2px solid var(--color-primary, #3b82f6);
   }

   :host([data-dragging]) {
     user-select: none;
   }

   :host([data-dragging]) .data-table-header-cell {
     cursor: grabbing;
   }
   ```

NOTE: Using separate drag handle conflicts with sort click - research recommends making entire header draggable with threshold or using drag handle icon. For simplicity, make header draggable only when enableColumnReorder=true. Sorting still works via click (drag requires movement threshold).
  </action>
  <verify>
Manual testing:
1. Set enableColumnReorder=true
2. Drag a column header
3. Drop on another column
4. Columns should reorder

```bash
cd packages/data-table && pnpm build
```
  </verify>
  <done>
- Headers are draggable when enableColumnReorder=true
- Visual feedback shows dragged and drop target columns
- Drop reorders columns via TanStack columnOrder state
- ui-column-order-change event fires after reorder
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement sticky first column</name>
  <files>packages/data-table/src/data-table.ts</files>
  <action>
1. Add sticky column property:
   - @property({ type: Boolean, attribute: 'sticky-first-column', reflect: true })
   - stickyFirstColumn = false

2. Add CSS for sticky first column using :host attribute selector:
   ```css
   /* Sticky first column */
   :host([sticky-first-column]) .data-table-cell:first-child,
   :host([sticky-first-column]) .data-table-header-cell:first-child {
     position: sticky;
     left: 0;
     background: inherit;
   }

   :host([sticky-first-column]) .data-table-cell:first-child {
     z-index: 2;
     background: var(--ui-data-table-row-bg);
   }

   :host([sticky-first-column]) .data-table-row:hover .data-table-cell:first-child {
     background: var(--ui-data-table-row-hover-bg);
   }

   :host([sticky-first-column]) .data-table-row.selected .data-table-cell:first-child {
     background: var(--ui-data-table-selected-bg);
   }

   :host([sticky-first-column]) .data-table-header-cell:first-child {
     z-index: 11; /* Above sticky header row z-index (10) */
     background: var(--ui-data-table-header-bg);
   }

   /* Shadow hint for sticky column edge */
   :host([sticky-first-column]) .data-table-cell:first-child::after,
   :host([sticky-first-column]) .data-table-header-cell:first-child::after {
     content: '';
     position: absolute;
     top: 0;
     right: -8px;
     bottom: 0;
     width: 8px;
     pointer-events: none;
     background: linear-gradient(
       to right,
       rgba(0, 0, 0, 0.06),
       transparent
     );
   }

   :host-context(.dark):host([sticky-first-column]) .data-table-cell:first-child::after,
   :host-context(.dark):host([sticky-first-column]) .data-table-header-cell:first-child::after {
     background: linear-gradient(
       to right,
       rgba(0, 0, 0, 0.2),
       transparent
     );
   }
   ```

3. Add position: relative to cells for ::after pseudo-element:
   - Ensure .data-table-cell and .data-table-header-cell have position: relative

4. Enable horizontal scroll on table body:
   - Update .data-table-body to overflow-x: auto
   - Ensure .data-table-header has overflow-x: auto for synchronized scroll
   - Add scroll synchronization if header and body scroll separately

NOTE: The z-index stacking is critical:
- Regular cells: z-index auto
- Sticky body cells: z-index 2
- Header cells: z-index in header container (via sticky header)
- Sticky header cell (intersection): z-index 11
  </action>
  <verify>
Manual testing:
1. Set sticky-first-column attribute
2. Add enough columns to require horizontal scroll
3. Scroll horizontally
4. First column should stay fixed with shadow edge

```bash
cd packages/data-table && pnpm build
```
  </verify>
  <done>
- sticky-first-column attribute enables sticky behavior
- First column stays fixed during horizontal scroll
- Shadow edge provides visual separation
- Z-index stacking prevents overlap issues
- Works correctly with dark mode
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Build succeeds: `cd packages/data-table && pnpm build`
2. Type check passes: `pnpm typecheck`
3. Column reorder works with drag-and-drop when enabled
4. Visual feedback shows during drag (opacity, drop indicator)
5. Sticky first column stays fixed during horizontal scroll
6. Z-index stacking is correct (no overlap issues)
7. Shadow edge visible on sticky column
</verification>

<success_criteria>
- COL-04: First column can be configured as fixed/sticky during horizontal scroll
- COL-06: Columns can be reordered via drag-and-drop in header
- Visual feedback during drag operation
- Shadow hint on sticky column edge
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/64-column-customization/64-03-SUMMARY.md`
</output>
