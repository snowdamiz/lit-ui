---
phase: 42-calendar-display-foundation
plan: 09
type: execute
wave: 4
depends_on: ["42-01", "42-02", "42-03", "42-04", "42-05", "42-06", "42-07", "42-08"]
files_modified:
  - packages/calendar/src/calendar.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User can navigate calendar grid with arrow keys, focus moves visibly between cells"
    - "Only one calendar cell is in tab order at a time (tabindex='0')"
    - "Focus remains on date cell when month changes (tabindex resets appropriately)"
    - "Tab and Shift+Tab enter/exit calendar at the focused cell"
  artifacts:
    - path: "packages/calendar/src/calendar.ts"
      provides: "Calendar with imperative roving tabindex via KeyboardNavigationManager"
      contains: "tabindex removed from renderDayCell template"
      contains: "updated() lifecycle calls navigationManager.setInitialFocus() after render"
      contains: "handleKeyDown() calls navigationManager.moveFocus() for DOM updates"
      contains: "focusedIndex as private property (not @state() decorator)"
  key_links:
    - from: "packages/calendar/src/calendar.ts"
      to: "packages/calendar/src/keyboard-nav.ts"
      via: "KeyboardNavigationManager.moveFocus() and setInitialFocus() for imperative tabindex"
      pattern: "navigationManager\\.(setInitialFocus|moveFocus)\\("
---

<objective>
Fix roving tabindex to use imperative DOM manipulation via KeyboardNavigationManager instead of declarative Lit template rendering.

Purpose: The current implementation mixes declarative template-based tabindex (`tabindex=${isFocused ? '0' : '-1'}`) with imperative DOM updates from KeyboardNavigationManager.moveFocus(). Lit's declarative rendering overwrites DOM tabindex updates on every render, creating a race condition. True roving tabindex requires fully imperative tabindex management outside the template.

Output: Calendar with roving tabindex managed imperatively via KeyboardNavigationManager in the updated() lifecycle, not in the render template.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-calendar-display-foundation/42-05-PLAN.md
@/Users/sn0w/Documents/dev/lit-components/packages/calendar/src/calendar.ts
@/Users/sn0w/Documents/dev/lit-components/packages/calendar/src/keyboard-nav.ts
</context>

<tasks>

<task type="auto">
  <name>Remove tabindex from renderDayCell template entirely</name>
  <files>packages/calendar/src/calendar.ts</files>
  <action>
    In packages/calendar/src/calendar.ts, remove the tabindex attribute from the renderDayCell method template.

    Current code (line ~646):
    ```typescript
    tabindex=${isFocused ? '0' : '-1'}
    ```

    Remove this line entirely from the template. The tabindex will be managed imperatively by KeyboardNavigationManager via the updated() lifecycle method.

    Keep the isFocused variable calculation for focus-visible styling, but do NOT use it for tabindex.

    IMPORTANT: Do NOT replace with any other tabindex logic in the template. The template must have NO tabindex attribute.

    Reference: packages/calendar/src/keyboard-nav.ts lines 143-146 show moveFocus() updates DOM tabindex directly.
  </action>
  <verify>grep "tabindex" packages/calendar/src/calendar.ts | grep -v "^\s*//" shows no tabindex in renderDayCell method</verify>
  <done>renderDayCell template has no tabindex attribute</done>
</task>

<task type="auto">
  <name>Convert focusedIndex from @state() to private property</name>
  <files>packages/calendar/src/calendar.ts</files>
  <action>
    In packages/calendar/src/calendar.ts, convert focusedIndex from a reactive @state() property to a regular private property.

    Find the declaration:
    ```typescript
    @state()
    private focusedIndex: number = 0;
    ```

    Change to:
    ```typescript
    private focusedIndex: number = 0;
    ```

    Remove the @state() decorator entirely. This prevents focusedIndex updates from triggering Lit re-renders, which would overwrite the imperative tabindex updates from KeyboardNavigationManager.

    The focusedIndex property will still track the current focused cell for keyboard navigation logic, but it will not trigger re-renders.

    WARNING: Do NOT add @state() back to focusedIndex or any other focus-tracking property. The render must NOT be triggered by focus changes.
  </action>
  <verify>grep -B 1 "focusedIndex:" packages/calendar/src/calendar.ts shows no @state() decorator</verify>
  <done>focusedIndex is a private property without @state() decorator</done>
</task>

<task type="auto">
  <name>Call navigationManager.setInitialFocus() in updated() after render</name>
  <files>packages/calendar/src/calendar.ts</files>
  <action>
    In packages/calendar/src/calendar.ts, update the updated() lifecycle method to call navigationManager.setInitialFocus() after Lit completes rendering.

    Current code at lines ~263-266:
    ```typescript
    // Reinitialize navigation manager when grid cells change (month change)
    if (changedProperties.has('currentMonth') && this.gridCells) {
      this.initializeNavigationManager();
    }
    ```

    The initializeNavigationManager() method (lines 208-243) already calls navigationManager.setInitialFocus() at line 242. However, this happens BEFORE the render completes.

    Change the logic to call setInitialFocus() AFTER the render completes by using requestAnimationFrame:

    ```typescript
    // Reinitialize navigation manager when grid cells change (month change)
    if (changedProperties.has('currentMonth') && this.gridCells) {
      this.initializeNavigationManager();

      // Set initial tabindex AFTER render completes via requestAnimationFrame
      requestAnimationFrame(() => {
        const initialIndex = this.focusedIndex;
        this.navigationManager?.setInitialFocus(initialIndex);
      });
    }
    ```

    This ensures:
    1. Lit completes its declarative render with NO tabindex in template
    2. KeyboardNavigationManager then sets tabindex imperatively on DOM elements
    3. Subsequent renders do NOT include tabindex, so DOM updates persist

    Reference: packages/calendar/src/keyboard-nav.ts setInitialFocus() method sets all cells to -1 except the initial index.
  </action>
  <verify>grep -A 5 "requestAnimationFrame" packages/calendar/src/calendar.ts shows setInitialFocus call after render</verify>
  <done>updated() lifecycle calls setInitialFocus() after render completes</done>
</task>

<task type="auto">
  <name>Verify handleKeyDown() uses navigationManager.moveFocus() correctly</name>
  <files>packages/calendar/src/calendar.ts</files>
  <action>
    In packages/calendar/src/calendar.ts, verify that handleKeyDown() already uses navigationManager.moveFocus() correctly for imperative tabindex updates.

    Current code (lines ~693-736) already calls navigationManager.moveFocus() for each direction:
    - ArrowRight: line 699
    - ArrowLeft: line 702
    - ArrowDown: line 705
    - ArrowUp: line 708
    - Home: line 711
    - End: line 714

    The navigationManager.moveFocus() method (see keyboard-nav.ts lines 143-146) already updates DOM tabindex directly:
    ```typescript
    this.focusableElements[fromIndex].setAttribute('tabindex', '-1');
    this.focusableElements[nextIndex].setAttribute('tabindex', '0');
    ```

    Since focusedIndex is now a private property (not @state()), updating it at line 734 will NOT trigger a re-render, so the DOM tabindex updates will persist.

    Verify the logic flow:
    1. User presses arrow key
    2. navigationManager.moveFocus() updates DOM tabindex imperatively
    3. this.focusedIndex = nextIndex updates tracking property (no re-render)
    4. nextElement?.focus() moves visible focus

    NO changes needed to handleKeyDown() - just verify this flow is correct and document it.

    Reference: packages/calendar/src/keyboard-nav.ts lines 143-146.
  </action>
  <verify>grep -A 2 "moveFocus" packages/calendar/src/calendar.ts | grep -E "(ArrowRight|ArrowLeft|ArrowDown|ArrowUp|Home|End)" shows all navigation keys use moveFocus()</verify>
  <done>handleKeyDown() correctly uses navigationManager.moveFocus() for imperative tabindex</done>
</task>

</tasks>

<verification>
After completing all tasks, verify:

1. renderDayCell has NO tabindex attribute in template (grep confirms)
2. focusedIndex is private property without @state() decorator
3. updated() lifecycle calls navigationManager.setInitialFocus() via requestAnimationFrame
4. handleKeyDown() calls navigationManager.moveFocus() for all navigation keys
5. focusedIndex updates do NOT trigger re-renders (no @state())
6. Test keyboard navigation: Arrow keys move focus, only one cell has tabindex='0'
7. Test month change: Tabindex resets to initial cell, focus persists
8. Test Tab key: Enters/exits calendar at currently focused cell
</verification>

<success_criteria>
1. Roving tabindex implemented imperatively via KeyboardNavigationManager
2. Tabindex managed in updated() lifecycle, not in render template
3. No @state() decorator on focus tracking (no re-render on focus change)
4. Keyboard navigation works with proper tabindex management
</success_criteria>

<output>
After completion, create `.planning/phases/42-calendar-display-foundation/42-09-SUMMARY.md`
</output>
