---
phase: 15-component-packages
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/button/src/index.ts
  - packages/button/src/button.ts
  - packages/button/package.json
autonomous: true

must_haves:
  truths:
    - "Consumer can import Button from @lit-ui/button"
    - "Button form participation works on client (skipped during SSR)"
    - "lui-button custom element is registered on import"
    - "TypeScript shows ButtonVariant, ButtonSize, ButtonType autocomplete"
  artifacts:
    - path: "packages/button/src/button.ts"
      provides: "Button component with SSR guards"
      contains: "isServer"
    - path: "packages/button/src/index.ts"
      provides: "Package exports with safe registration"
      exports: ["Button", "ButtonVariant", "ButtonSize", "ButtonType"]
  key_links:
    - from: "packages/button/src/button.ts"
      to: "@lit-ui/core"
      via: "extends TailwindElement"
      pattern: "extends TailwindElement"
    - from: "packages/button/src/button.ts"
      to: "lit"
      via: "isServer import"
      pattern: "import.*isServer.*from 'lit'"
---

<objective>
Migrate Button component to @lit-ui/button package with SSR compatibility

Purpose: Enable consumers to install @lit-ui/button and use the Button component with full form participation on client-side, gracefully degraded during SSR.

Output: Complete Button component with SSR guards, type exports, and safe custom element registration
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-component-packages/15-CONTEXT.md
@.planning/phases/15-component-packages/15-RESEARCH.md

# Source component to migrate
@src.old/components/button/button.ts

# Core package for imports
@packages/core/src/index.ts
@packages/core/src/tailwind-element.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Button Component with SSR Guards</name>
  <files>packages/button/src/button.ts</files>
  <action>
Migrate button.ts from src.old/components/button/button.ts with these changes:

1. Update imports:
   - Change `import { TailwindElement } from '../../base/tailwind-element'` to `import { TailwindElement } from '@lit-ui/core'`
   - Add `import { isServer } from 'lit'` for SSR guards

2. Add isServer guard for ElementInternals:
   - Change `private internals: ElementInternals` to `private internals: ElementInternals | null = null`
   - In constructor, wrap attachInternals() with isServer check:
     ```typescript
     constructor() {
       super();
       if (!isServer) {
         this.internals = this.attachInternals();
       }
     }
     ```

3. Update handleClick to guard internals access:
   - Check `this.internals?.form` instead of `this.internals.form`
   - Pattern: `if (this.internals?.form && this.type === 'submit')`

4. Remove the @customElement decorator - registration will be in index.ts

5. Change tag name reference in HTMLElementTagNameMap from 'ui-button' to 'lui-button'

6. Export the types (ButtonVariant, ButtonSize, ButtonType) from the class file

Keep all existing functionality: variants, sizes, loading state, spinner, icon slots, CSS custom properties.
  </action>
  <verify>
File exists at packages/button/src/button.ts with:
- `import { TailwindElement } from '@lit-ui/core'`
- `import { isServer } from 'lit'`
- `if (!isServer) { this.internals = this.attachInternals() }`
- No @customElement decorator
- `'lui-button': Button` in HTMLElementTagNameMap
  </verify>
  <done>Button component migrated with SSR-safe ElementInternals pattern</done>
</task>

<task type="auto">
  <name>Task 2: Create Package Entry Point with Safe Registration</name>
  <files>packages/button/src/index.ts</files>
  <action>
Replace the stub index.ts with full package exports and safe custom element registration:

```typescript
// @lit-ui/button - Button component with SSR support
import { isServer } from 'lit';

// Export component class and types
export { Button } from './button.js';
export type { ButtonVariant, ButtonSize, ButtonType } from './button.js';

// Re-export TailwindElement for convenience
export { TailwindElement, isServer } from '@lit-ui/core';

// Safe custom element registration with collision detection
import { Button } from './button.js';

if (!isServer && typeof customElements !== 'undefined') {
  if (!customElements.get('lui-button')) {
    customElements.define('lui-button', Button);
  } else if (process.env.NODE_ENV === 'development') {
    console.warn(
      '[lui-button] Custom element already registered. ' +
      'This may indicate duplicate imports or version conflicts.'
    );
  }
}

// TypeScript global type registration
declare global {
  interface HTMLElementTagNameMap {
    'lui-button': Button;
  }
}
```

Key patterns:
- Guard registration with !isServer check (no customElements during SSR)
- Check customElements.get() before define() to prevent collision errors
- Development warning for duplicate registration
- Re-export isServer and TailwindElement for consumer convenience
  </action>
  <verify>
File exists at packages/button/src/index.ts with:
- Export Button class and types
- isServer guard around customElements.define
- customElements.get() check before define
- HTMLElementTagNameMap declaration
  </verify>
  <done>Package entry point with safe custom element registration</done>
</task>

<task type="auto">
  <name>Task 3: Update Package.json Peer Dependencies</name>
  <files>packages/button/package.json</files>
  <action>
Update package.json to have @lit-ui/core as peer dependency (not regular dependency):

1. Move @lit-ui/core from dependencies to peerDependencies
2. Add @lit-ui/core to devDependencies as workspace:* for local development
3. Ensure lit is already in peerDependencies (it should be)

Final structure:
```json
{
  "peerDependencies": {
    "lit": "^3.0.0",
    "@lit-ui/core": "^0.0.1"
  },
  "devDependencies": {
    "@lit-ui/core": "workspace:*",
    // ... rest of dev deps
  }
}
```

Remove the dependencies field if it only had @lit-ui/core.

This ensures consumers don't get duplicate copies of core package.
  </action>
  <verify>
Run: `cat packages/button/package.json | grep -A5 peerDependencies`
Should show both "lit" and "@lit-ui/core" in peerDependencies
  </verify>
  <done>Package.json has correct peer dependency on @lit-ui/core</done>
</task>

</tasks>

<verification>
After all tasks:
1. `pnpm --filter @lit-ui/button build` succeeds without errors
2. `ls packages/button/dist/` shows index.js, index.d.ts, button.js, button.d.ts
3. `grep -l "isServer" packages/button/src/*.ts` shows button.ts and index.ts
4. `grep "lui-button" packages/button/src/index.ts` shows registration code
</verification>

<success_criteria>
- Button component has isServer guard for attachInternals()
- Safe custom element registration with collision detection
- @lit-ui/core is peer dependency, not regular dependency
- Build produces .js and .d.ts files
- No @customElement decorator (registration is in index.ts)
</success_criteria>

<output>
After completion, create `.planning/phases/15-component-packages/15-01-SUMMARY.md`
</output>
