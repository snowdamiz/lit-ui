---
phase: 05-framework-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/react/package.json
  - examples/react/src/App.tsx
  - examples/react/src/types.d.ts
  - examples/react/src/main.tsx
  - examples/react/vite.config.ts
  - examples/react/index.html
  - examples/react/tsconfig.json
autonomous: true

must_haves:
  truths:
    - "Button renders with all variants (primary, secondary, outline, ghost, destructive)"
    - "Button click events fire and can be handled with onClick"
    - "Dialog opens via open prop and closes via Escape key"
    - "Dialog close event fires with reason in event.detail"
    - "Slots render content correctly (dialog title, footer)"
    - "No console errors or warnings appear"
  artifacts:
    - path: "examples/react/src/App.tsx"
      provides: "React 19 component usage demonstration"
      min_lines: 50
    - path: "examples/react/src/types.d.ts"
      provides: "JSX.IntrinsicElements type declarations for custom elements"
      contains: "ui-button"
  key_links:
    - from: "examples/react/src/App.tsx"
      to: "src/components/button/button.ts"
      via: "npm link import"
      pattern: "import.*lit-ui"
---

<objective>
Create a React 19 test application that imports and uses the lit-ui Button and Dialog components, verifying that properties bind correctly, events fire, slots work, and no console errors appear.

Purpose: Validate React 19+ native web component support works with lit-ui components
Output: Fully functional React test app demonstrating all component features
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-framework-verification/05-RESEARCH.md

# Component sources for understanding API
@src/components/button/button.ts
@src/components/dialog/dialog.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create React 19 Vite app with lit-ui link</name>
  <files>
    examples/react/package.json
    examples/react/vite.config.ts
    examples/react/tsconfig.json
    examples/react/index.html
    examples/react/src/main.tsx
  </files>
  <action>
    Create React 19 test app in examples/react:

    1. Run: `npm create vite@latest examples/react -- --template react-ts`
    2. In examples/react, run: `npm install`
    3. Link the main lit-ui library: `npm link ..` (or use relative import path)

    Alternatively, use a simpler approach:
    - Create package.json with React 19, Vite, TypeScript
    - Add dependency on lit-ui via file reference: `"lit-ui": "file:../.."`
    - This avoids npm link complexity

    Create minimal vite.config.ts (no special config needed for React 19 custom elements).

    Create standard main.tsx with React.createRoot rendering App component.

    Create index.html with div#root and script type="module" pointing to main.tsx.

    tsconfig.json should extend react-ts defaults with strict mode.
  </action>
  <verify>
    Run `npm run dev` in examples/react - dev server starts without errors.
  </verify>
  <done>React 19 Vite app created and dev server runs</done>
</task>

<task type="auto">
  <name>Task 2: Add type declarations and App.tsx with full component demo</name>
  <files>
    examples/react/src/types.d.ts
    examples/react/src/App.tsx
  </files>
  <action>
    Create types.d.ts to augment JSX.IntrinsicElements with custom element types:

    ```typescript
    import type { Button, Dialog } from 'lit-ui';

    type CustomElement<T> = React.DetailedHTMLProps<
      React.HTMLAttributes<T>,
      T
    > & Partial<T>;

    declare global {
      namespace JSX {
        interface IntrinsicElements {
          'ui-button': CustomElement<Button>;
          'ui-dialog': CustomElement<Dialog>;
        }
      }
    }
    ```

    Create App.tsx demonstrating ALL component features from RESEARCH.md examples:

    - Import lit-ui via side-effect import (registers custom elements)
    - useState for dialogOpen and loading states
    - All 5 button variants (primary, secondary, outline, ghost, destructive)
    - All 3 button sizes (sm, md, lg)
    - Disabled button
    - Loading button with loading state toggle
    - Button with icon slots (icon-start, icon-end)
    - Dialog with open prop bound to state
    - Dialog close handler accessing event.detail.reason
    - Dialog with title slot, content, and footer slot with close button
    - Form with submit button to test form participation
    - Console.log calls to verify events fire

    Event naming: React 19 uses onClose for 'close' event (camelCase with on prefix).
  </action>
  <verify>
    - TypeScript compiles without errors: `npm run build`
    - App renders in browser with all variants visible
    - Clicking buttons logs to console
    - Opening/closing dialog works
    - No console errors or warnings
  </verify>
  <done>React app demonstrates all Button and Dialog features with proper TypeScript types</done>
</task>

</tasks>

<verification>
Full verification checklist:
1. `cd examples/react && npm run dev` - starts without errors
2. Open http://localhost:5173 in browser
3. All 5 button variants render with correct styling
4. All 3 button sizes render correctly
5. Disabled button shows disabled state
6. Click loading button - shows spinner, reverts after 2s
7. Click "Open Dialog" - dialog appears with animation
8. Press Escape - dialog closes, console shows close reason
9. Click backdrop - dialog closes with backdrop reason
10. Form submit button triggers form submission
11. No console errors or TypeScript warnings
</verification>

<success_criteria>
- React 19 test app runs without errors
- All button variants/sizes/states render correctly
- Button click events fire and log to console
- Dialog opens via open prop, closes via Escape/backdrop
- Dialog close event contains reason in detail
- Slots render content (dialog title, footer)
- Form participation works (submit button in form)
- TypeScript provides type checking for custom elements
- Zero console errors or warnings
</success_criteria>

<output>
After completion, create `.planning/phases/05-framework-verification/05-01-SUMMARY.md`
</output>
