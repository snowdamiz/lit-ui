---
phase: 103-candlestick-webgpu
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/charts/src/candlestick/candlestick-chart.ts
autonomous: true
requirements:
  - WEBGPU-CNDL-01

must_haves:
  truths:
    - "LuiCandlestickChart with enable-webgpu renders OHLC candles via ChartGPU GPU canvas when WebGPU is available"
    - "ECharts retains rendering of axes, MA overlay lines, volume bars, tooltip, DataZoom slider — ChartGPU renders candles only"
    - "Dragging DataZoom slider keeps ChartGPU canvas visually aligned with ECharts category axis labels"
    - "Removing the element from DOM calls gpuChart.dispose() and releaseGpuDevice() with no memory leak"
    - "On Canvas-fallback browsers, candlestick renders correctly with no JS errors"
    - "pushData() trim resets _gpuFlushedLength to 0 so GPU chart does not miss bars after buffer truncation"
  artifacts:
    - path: "packages/charts/src/candlestick/candlestick-chart.ts"
      provides: "LuiCandlestickChart with WebGPU two-layer canvas"
      contains: "_initWebGpuLayer"
    - path: "packages/charts/src/candlestick/candlestick-chart.ts"
      provides: "_GpuCandlestickInstance interface"
      contains: "appendData(seriesIndex: number, newPoints: ReadonlyArray<readonly [number, number, number, number, number]>)"
    - path: "packages/charts/src/candlestick/candlestick-chart.ts"
      provides: "Transparent ECharts candlestick when WebGPU active"
      contains: "_wasWebGpu ? 'transparent'"
  key_links:
    - from: "candlestick-chart.ts::_initChart()"
      to: "_initWebGpuLayer()"
      via: "if (this.renderer === 'webgpu') await this._initWebGpuLayer()"
      pattern: "_initWebGpuLayer"
    - from: "candlestick-chart.ts::_flushBarUpdates()"
      to: "_gpuChart.appendData()"
      via: "appendData(0, gpuPoints) after ECharts setOption"
      pattern: "appendData\\(0"
    - from: "candlestick-chart.ts::pushData()"
      to: "_gpuFlushedLength = 0"
      via: "reset after _ohlcBuffer trim"
      pattern: "_gpuFlushedLength = 0"
    - from: "candlestick-chart.ts::disconnectedCallback()"
      to: "releaseGpuDevice()"
      via: "void releaseGpuDevice() when _wasWebGpu"
      pattern: "releaseGpuDevice"
---

<objective>
Add WebGPU two-layer canvas rendering to LuiCandlestickChart, following the exact Phase 101 pattern established for LuiLineChart.

Purpose: Candlestick chart gains GPU-accelerated candle rendering when `enable-webgpu` is set. MA overlays, volume panel, axes, tooltip, and DataZoom remain in ECharts on the top canvas layer.

Output: `candlestick-chart.ts` with `_initWebGpuLayer()`, `_GpuCandlestickInstance` interface, `_gpuChart`/`_gpuResizeObserver`/`_wasWebGpu`/`_gpuFlushedLength` fields, `_initChart()` override, `_syncCoordinates()`, GPU flush in `_flushBarUpdates()`, trim handling in `pushData()`, and full `disconnectedCallback()` cleanup.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/103-candlestick-webgpu/103-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From packages/charts/src/candlestick/candlestick-chart.ts (current state — full file):
```typescript
// Key existing fields:
private _ohlcBuffer: CandlestickBarPoint[] = [];
private _maStateMachines: MAStateMachine[] = [];
private _barRafId?: number;

// Key existing methods:
protected override async _registerModules(): Promise<void>
override updated(changed: PropertyValues): void
protected override _applyData(): void
override pushData(point: unknown): void          // trims _ohlcBuffer to maxPoints
private _flushBarUpdates(): void                  // setOption(lazyUpdate:true)
override disconnectedCallback(): void             // cancels _barRafId, then super
```

From packages/charts/src/shared/webgpu-device.ts:
```typescript
export function getGpuDevice(): Promise<GPUDevice> | null;
export function getGpuAdapter(): GPUAdapter | null;
export async function releaseGpuDevice(): Promise<void>;
```

From packages/charts/src/line/line-chart.ts (Phase 101 pattern — replicate this):
```typescript
// Local interface:
interface _GpuChartInstance {
  resize(): void;
  dispose(): void;
  setZoomRange(start: number, end: number): void;
  appendData(seriesIndex: number, newPoints: ReadonlyArray<readonly [number, number]>): void;
}

// Fields:
private _gpuChart: _GpuChartInstance | null = null;
private _gpuResizeObserver?: ResizeObserver;
private _wasWebGpu = false;
private _gpuFlushedLengths: number[] = [];  // per-series for line; single number for candlestick

// _initChart override:
protected override async _initChart(): Promise<void> {
  await super._initChart();
  if (this.renderer === 'webgpu') { await this._initWebGpuLayer(); }
}

// _initWebGpuLayer:
private async _initWebGpuLayer(): Promise<void> {
  const devicePromise = getGpuDevice();
  if (!devicePromise) return;
  const device = await devicePromise;
  const adapter = getGpuAdapter();
  const { ChartGPU } = await import('chartgpu');
  const container = this.shadowRoot?.querySelector<HTMLDivElement>('#chart');
  if (!container) return;
  const gpuHost = document.createElement('div');
  gpuHost.style.cssText = 'position:absolute;inset:0;width:100%;height:100%;z-index:0;pointer-events:none;';
  container.insertBefore(gpuHost, container.firstChild);
  // adapter null guard + ChartGPU.create()
  this._wasWebGpu = true;
  this._gpuResizeObserver = new ResizeObserver(() => this._gpuChart?.resize());
  this._gpuResizeObserver.observe(container);
  this._chart!.on('dataZoom', () => this._syncCoordinates());
  this._chart!.on('rendered', () => this._syncCoordinates());
}

// _syncCoordinates:
private _syncCoordinates(): void {
  if (!this._chart || !this._gpuChart) return;
  const option = this._chart.getOption() as Record<string, unknown>;
  const dataZoom = (option['dataZoom'] as Array<Record<string, unknown>> | undefined)?.[0];
  if (!dataZoom) return;
  const start = (dataZoom['start'] as number) ?? 0;
  const end = (dataZoom['end'] as number) ?? 100;
  if (isNaN(start) || isNaN(end)) return;
  this._gpuChart.setZoomRange(start, end);
}

// disconnectedCallback (line chart order):
// 1. cancel _lineRafId
// 2. _gpuResizeObserver?.disconnect()
// 3. _gpuChart?.dispose() + null
// 4. if (_wasWebGpu) void releaseGpuDevice()
// 5. super.disconnectedCallback()
```

ChartGPU candlestick-specific types (from node_modules/chartgpu dist):
```typescript
// OHLCDataPointTuple: [timestamp/index, open, close, low, high]
// DIFFERENT from ECharts CandlestickBarPoint.ohlc = [open, close, low, high]
// Conversion: ChartGPU = [barIndex, ohlc[0], ohlc[1], ohlc[2], ohlc[3]]

// _GpuCandlestickInstance interface (define locally in candlestick-chart.ts):
interface _GpuCandlestickInstance {
  resize(): void;
  dispose(): void;
  setZoomRange(start: number, end: number): void;
  appendData(seriesIndex: number, newPoints: ReadonlyArray<readonly [number, number, number, number, number]>): void;
}

// ChartGPU init series config:
{
  series: [{
    type: 'candlestick' as const,
    data: [] as Array<readonly [number, number, number, number, number]>,
    itemStyle: {
      upColor: this.bullColor ?? '#26a69a',
      downColor: this.bearColor ?? '#ef5350',
      upBorderColor: this.bullColor ?? '#26a69a',
      downBorderColor: this.bearColor ?? '#ef5350',
    },
  }],
}
```

From packages/charts/src/shared/candlestick-option-builder.ts (used in _applyData/_flushBarUpdates):
```typescript
export function buildCandlestickOption(
  bars: CandlestickBarPoint[],
  opts: {
    bullColor?: string;
    bearColor?: string;
    showVolume?: boolean;
    movingAverages?: MAConfig[];
    maValueArrays?: (number | null)[][];
    resolvedMAColors?: string[];
  }
): EChartsOption;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WebGPU fields, interface, and _initWebGpuLayer to candlestick-chart.ts</name>
  <files>packages/charts/src/candlestick/candlestick-chart.ts</files>
  <action>
Add the following to `LuiCandlestickChart` in `packages/charts/src/candlestick/candlestick-chart.ts`:

**1. New import at top of file (after existing imports):**
```typescript
import {
  getGpuDevice,
  getGpuAdapter,
  releaseGpuDevice,
} from '../shared/webgpu-device.js';
```

**2. Local interface before the class (after existing imports, before export class):**
```typescript
// WEBGPU: Minimal ChartGPU instance interface for candlestick — avoids hard dependency on chartgpu types.
// Candlestick appendData uses 5-element tuples [index, open, close, low, high] (NOT [x,y] pairs).
interface _GpuCandlestickInstance {
  resize(): void;
  dispose(): void;
  setZoomRange(start: number, end: number): void;
  appendData(seriesIndex: number, newPoints: ReadonlyArray<readonly [number, number, number, number, number]>): void;
}
```

**3. New private fields on the class (after `private _barRafId?: number;`):**
```typescript
// WEBGPU: ChartGPU instance — null when WebGPU unavailable or before init.
private _gpuChart: _GpuCandlestickInstance | null = null;
// WEBGPU: Separate ResizeObserver for ChartGPU — base class observer only calls this._chart.resize().
private _gpuResizeObserver?: ResizeObserver;
// WEBGPU: Flag set to true when WebGPU path was active — gates releaseGpuDevice() in cleanup.
private _wasWebGpu = false;
// WEBGPU: Tracks how many bars have been pushed to ChartGPU — enables incremental appendData.
// Reset to 0 after _ohlcBuffer trim (see pushData() override).
private _gpuFlushedLength = 0;
```

**4. Override _initChart() (add before _registerModules):**
```typescript
protected override async _initChart(): Promise<void> {
  await super._initChart();
  if (this.renderer === 'webgpu') {
    await this._initWebGpuLayer();
  }
}
```

**5. Add _initWebGpuLayer() private method (after _initChart override):**
```typescript
private async _initWebGpuLayer(): Promise<void> {
  const devicePromise = getGpuDevice();
  if (!devicePromise) return;

  const device = await devicePromise;
  const adapter = getGpuAdapter();

  const { ChartGPU } = await import('chartgpu');
  const container = this.shadowRoot?.querySelector<HTMLDivElement>('#chart');
  if (!container) return;

  const gpuHost = document.createElement('div');
  gpuHost.style.cssText =
    'position:absolute;inset:0;width:100%;height:100%;z-index:0;pointer-events:none;';
  container.insertBefore(gpuHost, container.firstChild);

  const gpuSeries = {
    series: [{
      type: 'candlestick' as const,
      data: [] as Array<readonly [number, number, number, number, number]>,
      itemStyle: {
        upColor: this.bullColor ?? '#26a69a',
        downColor: this.bearColor ?? '#ef5350',
        upBorderColor: this.bullColor ?? '#26a69a',
        downBorderColor: this.bearColor ?? '#ef5350',
      },
    }],
  };

  if (!adapter) {
    this._gpuChart = (await ChartGPU.create(gpuHost, gpuSeries)) as unknown as _GpuCandlestickInstance;
  } else {
    this._gpuChart = (await ChartGPU.create(gpuHost, gpuSeries, { device, adapter })) as unknown as _GpuCandlestickInstance;
  }

  this._wasWebGpu = true;
  this._gpuResizeObserver = new ResizeObserver(() => this._gpuChart?.resize());
  this._gpuResizeObserver.observe(container);

  this._chart!.on('dataZoom', () => this._syncCoordinates());
  this._chart!.on('rendered', () => this._syncCoordinates());
}
```

**6. Add _syncCoordinates() private method (after _initWebGpuLayer):**
```typescript
private _syncCoordinates(): void {
  if (!this._chart || !this._gpuChart) return;
  const option = this._chart.getOption() as Record<string, unknown>;
  const dataZoom = (option['dataZoom'] as Array<Record<string, unknown>> | undefined)?.[0];
  if (!dataZoom) return;
  const start = (dataZoom['start'] as number) ?? 0;
  const end = (dataZoom['end'] as number) ?? 100;
  if (isNaN(start) || isNaN(end)) return;
  this._gpuChart.setZoomRange(start, end);
}
```

**7. Add _toGpuPoint() private helper (after _syncCoordinates):**
```typescript
// Converts CandlestickBarPoint.ohlc (ECharts [open,close,low,high]) to
// ChartGPU OHLCDataPointTuple [index, open, close, low, high].
// CRITICAL: These formats differ — do NOT pass ECharts ohlc directly to ChartGPU.
private _toGpuPoint(
  bar: CandlestickBarPoint,
  index: number
): readonly [number, number, number, number, number] {
  return [index, bar.ohlc[0], bar.ohlc[1], bar.ohlc[2], bar.ohlc[3]];
}
```
  </action>
  <verify>
    <automated>cd /Users/sn0w/Documents/dev/lit-components && npx tsc -p packages/charts/tsconfig.json --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>candlestick-chart.ts compiles without errors; _initWebGpuLayer, _syncCoordinates, _toGpuPoint, and all new fields are present; _initChart() override calls super then conditionally _initWebGpuLayer</done>
</task>

<task type="auto">
  <name>Task 2: Wire GPU flush into _applyData, _flushBarUpdates, pushData trim, and disconnectedCallback</name>
  <files>packages/charts/src/candlestick/candlestick-chart.ts</files>
  <action>
Modify the three existing methods to integrate the WebGPU data layer:

**Modify _applyData() — reset GPU flush counter on full data reload:**
After `this._ohlcBuffer = this.data ? [...(this.data as CandlestickBarPoint[])] : [];` add:
```typescript
// WEBGPU: Full data reset — rebuild GPU data from scratch on next flush.
this._gpuFlushedLength = 0;
```

Also in `_applyData()`, update the `buildCandlestickOption` call to pass transparent colors when WebGPU is active (prevents double-rendering of candles):
```typescript
const option = buildCandlestickOption(this._ohlcBuffer, {
  bullColor: this._wasWebGpu ? 'transparent' : (this.bullColor ?? undefined),
  bearColor: this._wasWebGpu ? 'transparent' : (this.bearColor ?? undefined),
  showVolume: this.showVolume,
  movingAverages: mas,
  maValueArrays,
  resolvedMAColors,
});
```

**Modify _flushBarUpdates() — also push new bars to ChartGPU:**
After the existing `this._chart.setOption(option, { lazyUpdate: true } as object);` line, add:
```typescript
// WEBGPU: Push incremental new bars to ChartGPU after ECharts update.
if (this._gpuChart) {
  const lastFlushed = this._gpuFlushedLength;
  const newBars = this._ohlcBuffer.slice(lastFlushed);
  if (newBars.length > 0) {
    const gpuPoints = newBars.map((bar, i) => this._toGpuPoint(bar, lastFlushed + i));
    this._gpuChart.appendData(0, gpuPoints);
    this._gpuFlushedLength = this._ohlcBuffer.length;
  }
}
```

Also update `buildCandlestickOption` call in `_flushBarUpdates()` to use transparent colors when WebGPU active (same as _applyData):
```typescript
const option = buildCandlestickOption(this._ohlcBuffer, {
  bullColor: this._wasWebGpu ? 'transparent' : (this.bullColor ?? undefined),
  bearColor: this._wasWebGpu ? 'transparent' : (this.bearColor ?? undefined),
  showVolume: this.showVolume,
  movingAverages: mas,
  maValueArrays,
  resolvedMAColors,
});
```

**Modify pushData() — reset _gpuFlushedLength after trim:**
After `this._ohlcBuffer = this._ohlcBuffer.slice(-this.maxPoints);` and after the `sm.trim()` call, add:
```typescript
// WEBGPU: After trim, _gpuFlushedLength must reset to 0.
// The next _flushBarUpdates() will use _ohlcBuffer.slice(0) = full trimmed buffer
// and send it all to ChartGPU, keeping the GPU chart consistent.
this._gpuFlushedLength = 0;
```

**Replace disconnectedCallback() entirely with the WebGPU-aware version:**
```typescript
override disconnectedCallback(): void {
  // 1. Cancel component's own RAF — must be first (base class only cancels _rafId, not _barRafId).
  if (this._barRafId !== undefined) {
    cancelAnimationFrame(this._barRafId);
    this._barRafId = undefined;
  }

  // 2. WEBGPU: Disconnect ChartGPU's resize observer before disposing.
  this._gpuResizeObserver?.disconnect();
  this._gpuResizeObserver = undefined;

  // 3. WEBGPU: Dispose ChartGPU — releases GPU buffers + removes WebGPU canvas.
  //    Does NOT destroy the shared GPUDevice (owned by webgpu-device.ts singleton).
  this._gpuChart?.dispose();
  this._gpuChart = null;

  // 4. WEBGPU: Release refcount — device.destroy() fires when last chart disconnects.
  if (this._wasWebGpu) {
    void releaseGpuDevice();
  }

  // 5. ECharts cleanup (base class) — MUST be last.
  super.disconnectedCallback();
}
```
  </action>
  <verify>
    <automated>cd /Users/sn0w/Documents/dev/lit-components && npx tsc -p packages/charts/tsconfig.json --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>TypeScript compiles without errors; _applyData and _flushBarUpdates pass transparent bull/bear when _wasWebGpu; _flushBarUpdates appends to _gpuChart after ECharts setOption; pushData resets _gpuFlushedLength after trim; disconnectedCallback cleans up GPU resources in correct reverse-init order before super</done>
</task>

</tasks>

<verification>
```bash
# TypeScript compilation — must pass clean
cd /Users/sn0w/Documents/dev/lit-components && npx tsc -p packages/charts/tsconfig.json --noEmit

# Verify all key patterns exist in the file
grep -n "_initWebGpuLayer\|_syncCoordinates\|_toGpuPoint\|_gpuFlushedLength\|_wasWebGpu\|releaseGpuDevice\|appendData(0" packages/charts/src/candlestick/candlestick-chart.ts
```
</verification>

<success_criteria>
- `candlestick-chart.ts` compiles cleanly with `tsc --noEmit`
- `_initWebGpuLayer()` creates ChartGPU with `{ type: 'candlestick', data: [], itemStyle: { upColor, downColor, ... } }` series
- `_GpuCandlestickInstance` interface defines 5-element tuple for `appendData`
- `_flushBarUpdates()` calls `this._gpuChart.appendData(0, gpuPoints)` after ECharts setOption
- `_toGpuPoint()` prepends bar index to ohlc: `[index, ohlc[0], ohlc[1], ohlc[2], ohlc[3]]`
- `_applyData()` and `_flushBarUpdates()` pass `bullColor: 'transparent'` when `_wasWebGpu`
- `disconnectedCallback()` order: `_barRafId cancel → gpuResizeObserver.disconnect → gpuChart.dispose → releaseGpuDevice → super`
- `pushData()` sets `_gpuFlushedLength = 0` after trim
</success_criteria>

<output>
After completion, create `.planning/phases/103-candlestick-webgpu/103-01-SUMMARY.md`
</output>
