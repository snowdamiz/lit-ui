---
phase: 44-date-picker-core
plan: 02
type: execute
wave: 2
depends_on: [44-01]
files_modified:
  - packages/date-picker/src/date-picker.ts
autonomous: true

must_haves:
  truths:
    - "User sees an input field with a calendar icon button to the right"
    - "User sees placeholder text showing expected date format"
    - "User can click the calendar icon or input to open a calendar popup"
    - "User can type a date and see it parsed and formatted on blur"
    - "User can click a date in the calendar popup to select it"
    - "User can clear the date with an X button"
    - "Component submits ISO 8601 (YYYY-MM-DD) form value via ElementInternals"
  artifacts:
    - path: "packages/date-picker/src/date-picker.ts"
      provides: "Main lui-date-picker component with input, popup, form integration"
      exports: ["DatePicker"]
      min_lines: 200
  key_links:
    - from: "packages/date-picker/src/date-picker.ts"
      to: "packages/date-picker/src/date-input-parser.ts"
      via: "import { parseDateInput, formatDateForDisplay, getPlaceholderText }"
      pattern: "import.*parseDateInput.*date-input-parser"
    - from: "packages/date-picker/src/date-picker.ts"
      to: "@lit-ui/calendar"
      via: "lui-calendar element in template"
      pattern: "<lui-calendar"
    - from: "packages/date-picker/src/date-picker.ts"
      to: "ElementInternals"
      via: "attachInternals() with isServer guard"
      pattern: "attachInternals"
---

<objective>
Create the main lui-date-picker component with input field rendering, calendar popup shell, calendar icon trigger, clear button, date selection handling, text input parsing, and ElementInternals form integration.

Purpose: This is the core component that composes an input field with lui-calendar inside a popup. It handles the primary user interactions: typing a date, clicking the calendar icon, selecting from the calendar, clearing the value, and submitting form values.
Output: date-picker.ts with the full component class (popup positioning and focus management are added in subsequent plans).
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-date-picker-core/44-RESEARCH.md
@.planning/phases/44-date-picker-core/44-01-SUMMARY.md

Reference patterns from:
@packages/input/src/input.ts (ElementInternals, validation, clear button, input rendering)
@packages/select/src/select.ts (popup open/close state, trigger button)
@packages/calendar/src/calendar.ts (change event detail shape, value property)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DatePicker component with input field, calendar popup, and form integration</name>
  <files>packages/date-picker/src/date-picker.ts</files>
  <action>
    Create `packages/date-picker/src/date-picker.ts` implementing the lui-date-picker component. Follow the structure from 44-RESEARCH.md code examples closely.

    **Class setup:**
    - Export class `DatePicker extends TailwindElement`
    - `static formAssociated = true`
    - Static styles: tailwindBaseStyles + component CSS (inline Tailwind classes in template)
    - Constructor: `if (!isServer) { this.internals = this.attachInternals(); }`

    **Properties (all @property):**
    - `value: string = ''` — ISO 8601 date (YYYY-MM-DD), reflects to attribute
    - `name: string = ''` — form field name
    - `locale: string = ''` — BCP 47 locale tag
    - `placeholder: string = ''` — custom placeholder (falls back to getPlaceholderText)
    - `helper-text: string = ''` — helper text below input (attribute: 'helper-text')
    - `min-date: string = ''` — minimum selectable date ISO string (attribute: 'min-date')
    - `max-date: string = ''` — maximum selectable date ISO string (attribute: 'max-date')
    - `required: boolean = false`
    - `disabled: boolean = false`
    - `error: string = ''` — external error message
    - `label: string = ''` — accessible label for the input

    **State (@state):**
    - `open: boolean = false` — popup visibility
    - `displayValue: string = ''` — formatted date for display in input
    - `inputValue: string = ''` — raw text being typed
    - `isEditing: boolean = false` — true when input is focused for typing
    - `touched: boolean = false` — true after first blur
    - `internalError: string = ''` — validation error message

    **Private fields:**
    - `internals: ElementInternals | null = null`
    - `inputId: string` — generated unique ID for label association
    - `triggerElement: HTMLElement | null = null` — for focus restoration (used in Plan 04)

    **Query refs:**
    - `@query('.input-container') inputContainerEl: HTMLElement`
    - `@query('.popup') popupEl: HTMLElement`
    - `@query('input') inputEl: HTMLInputElement`

    **Computed getter:**
    - `get effectiveLocale(): string` — returns `this.locale || (isServer ? 'en-US' : navigator.language)`
    - `get effectivePlaceholder(): string` — returns `this.placeholder || getPlaceholderText(this.effectiveLocale)`
    - `get hasError(): boolean` — returns `!!(this.error || this.internalError)`
    - `get errorMessage(): string` — returns `this.error || this.internalError`

    **Lifecycle:**
    - `updated(changedProps)`: If 'value' changed, update displayValue via formatDateForDisplay and call updateFormValue(). If value is empty, clear displayValue.

    **render() method — Template structure:**
    ```
    <div class="date-picker-wrapper relative inline-block w-full">
      <!-- Label -->
      ${this.label ? html`<label for="${this.inputId}" class="...">${this.label}</label>` : nothing}

      <!-- Input container -->
      <div class="input-container flex items-center border rounded-lg ...${error styles}...${disabled styles}">
        <!-- Text input -->
        <input
          id="${this.inputId}"
          type="text"
          .value="${this.isEditing ? this.inputValue : this.displayValue}"
          placeholder="${this.effectivePlaceholder}"
          ?disabled="${this.disabled}"
          ?required="${this.required}"
          aria-invalid="${this.hasError}"
          aria-describedby="${this.hasError ? `${this.inputId}-error` : this.helperText ? `${this.inputId}-helper` : nothing}"
          aria-haspopup="dialog"
          aria-expanded="${this.open}"
          autocomplete="off"
          @focus="${this.handleInputFocus}"
          @blur="${this.handleInputBlur}"
          @input="${this.handleInput}"
          @keydown="${this.handleInputKeydown}"
          class="flex-1 bg-transparent outline-none px-3 py-2 text-sm ..."
        />

        <!-- Clear button (shown when value exists and not disabled) -->
        ${this.value && !this.disabled ? html`
          <button
            type="button"
            class="p-1 mr-1 rounded hover:bg-gray-100 ..."
            aria-label="Clear date"
            @click="${this.handleClear}"
            tabindex="-1"
          >
            <!-- X SVG icon (match lui-input clear icon) -->
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        ` : nothing}

        <!-- Calendar icon button -->
        <button
          type="button"
          class="p-2 rounded-r-lg hover:bg-gray-100 ..."
          aria-label="${this.open ? 'Close calendar' : 'Open calendar'}"
          ?disabled="${this.disabled}"
          @click="${this.togglePopup}"
          tabindex="-1"
        >
          <!-- Calendar SVG icon -->
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="16" y1="2" x2="16" y2="6"></line>
            <line x1="8" y1="2" x2="8" y2="6"></line>
            <line x1="3" y1="10" x2="21" y2="10"></line>
          </svg>
        </button>
      </div>

      <!-- Helper text -->
      ${this.helperText && !this.hasError ? html`
        <p id="${this.inputId}-helper" class="mt-1 text-xs text-gray-500">${this.helperText}</p>
      ` : nothing}

      <!-- Error message -->
      ${this.hasError && this.touched ? html`
        <p id="${this.inputId}-error" class="mt-1 text-xs text-red-500" role="alert">${this.errorMessage}</p>
      ` : nothing}

      <!-- Calendar popup (positioning added in Plan 03) -->
      ${this.open ? html`
        <div
          class="popup absolute z-50 mt-1 bg-white rounded-lg shadow-lg border"
          role="dialog"
          aria-modal="true"
          aria-label="Choose date"
          @keydown="${this.handlePopupKeydown}"
        >
          <lui-calendar
            .value="${this.value}"
            .locale="${this.locale || nothing}"
            .minDate="${this.minDate || nothing}"
            .maxDate="${this.maxDate || nothing}"
            @change="${this.handleCalendarSelect}"
          ></lui-calendar>
        </div>
      ` : nothing}
    </div>
    ```

    Use CSS custom properties for theming: --ui-date-picker-border, --ui-date-picker-bg, --ui-date-picker-text, --ui-date-picker-error, etc. with sensible fallbacks using var(--ui-date-picker-border, var(--color-gray-300, #d1d5db)).

    Add :host-context(.dark) styles for dark mode following the established pattern.

    **Event handlers:**

    `handleInputFocus()`: Set isEditing=true. Set inputValue to the current displayValue (so user can edit). If displayValue is empty, inputValue stays empty.

    `handleInputBlur()`: Set isEditing=false, touched=true. Parse inputValue with parseDateInput(). If valid: set value to ISO format, update displayValue, clear errors. If invalid and non-empty: set internalError. If empty and required: set internalError.

    `handleInput(e)`: Update inputValue from e.target.value. Clear internalError while typing.

    `handleInputKeydown(e)`: On Enter: blur the input (triggers parse). On Escape: if popup open, close it; if not, blur input. On ArrowDown: open popup if not open.

    `togglePopup()`: Toggle this.open. If opening, store triggerElement.

    `handleCalendarSelect(e)`: Extract date from e.detail. Set value = e.detail.isoString. Set displayValue = formatDateForDisplay(e.detail.date, effectiveLocale). Set open = false. Clear errors. Dispatch change event from date picker.

    `handleClear()`: Set value='', displayValue='', inputValue='', internalError=''. Call updateFormValue(). Focus inputEl. Dispatch change event with null date.

    `handlePopupKeydown(e)`: On Escape: check if e.defaultPrevented (calendar might handle it for view drilling). If not prevented, close popup and restore focus. This prevents the Escape key conflict with calendar decade/century view navigation (Pitfall 6 from research).

    **Form integration methods:**

    `updateFormValue()`: Call this.internals?.setFormValue(this.value || null).

    `validate()`: If required and empty: setValidity({ valueMissing: true }, message, inputEl). If value and minDate and date < minDate: setValidity({ rangeUnderflow: true }, message, inputEl). If value and maxDate and date > maxDate: setValidity({ rangeOverflow: true }, message, inputEl). Otherwise: setValidity({}).

    `formResetCallback()`: Reset value, displayValue, inputValue, internalError, touched, open. Call updateFormValue().

    `formDisabledCallback(disabled)`: Set this.disabled = disabled.

    **Imports:**
    - `{ html, css, isServer, nothing, type PropertyValues, type CSSResultGroup } from 'lit'`
    - `{ property, state, query } from 'lit/decorators.js'`
    - `{ TailwindElement, tailwindBaseStyles, dispatchCustomEvent } from '@lit-ui/core'`
    - `{ parseDateInput, formatDateForDisplay, getPlaceholderText } from './date-input-parser.js'`
    - `{ parseISO, isBefore, isAfter } from 'date-fns'` (for validation)

    Do NOT import Floating UI yet — that's Plan 03.
    Do NOT implement focus trap yet — that's Plan 04.
    The popup uses `position: absolute` as a placeholder; Plan 03 upgrades to Floating UI `position: fixed`.
  </action>
  <verify>
    - `pnpm --filter @lit-ui/date-picker build` succeeds
    - `grep "class DatePicker" packages/date-picker/src/date-picker.ts` shows the component class
    - `grep "formAssociated" packages/date-picker/src/date-picker.ts` shows form integration
    - `grep "lui-calendar" packages/date-picker/src/date-picker.ts` shows calendar composition
    - `grep "handleCalendarSelect" packages/date-picker/src/date-picker.ts` shows date selection handler
    - `grep "handleClear" packages/date-picker/src/date-picker.ts` shows clear functionality
    - `grep "parseDateInput" packages/date-picker/src/date-picker.ts` shows parser integration
  </verify>
  <done>DatePicker component renders input field with calendar icon, clear button, calendar popup, text input parsing on blur, calendar date selection, and ElementInternals form value submission. Package builds cleanly.</done>
</task>

</tasks>

<verification>
- `pnpm --filter @lit-ui/date-picker build` completes without errors
- DatePicker class exports from date-picker.ts
- Template includes: input field, clear button, calendar icon button, lui-calendar in popup, error display, helper text
- Form integration: formAssociated, attachInternals, setFormValue, setValidity, formResetCallback
- Calendar selection updates value and closes popup
- Text input parsing on blur with locale awareness
- Clear button resets all state
</verification>

<success_criteria>
1. DatePicker component class exists with all properties and state
2. Input field renders with placeholder, clear button, and calendar icon
3. Calendar popup renders lui-calendar when open=true
4. Typing a date and blurring parses it via parseDateInput
5. Clicking a calendar date sets value and closes popup
6. Clear button resets value and dispatches change event
7. Form value submitted as ISO 8601 via ElementInternals
8. Escape key in popup respects calendar's defaultPrevented for view drilling
9. Package builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/44-date-picker-core/44-02-SUMMARY.md`
</output>
