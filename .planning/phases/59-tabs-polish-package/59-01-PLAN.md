---
phase: 59-tabs-polish-package
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/tabs/src/tabs.ts
  - packages/tabs/src/tab-panel.ts
  - packages/tabs/src/jsx.d.ts
  - packages/core/src/styles/tailwind.css
autonomous: true

must_haves:
  truths:
    - "Active tab indicator slides smoothly between tabs when selection changes"
    - "Indicator repositions correctly on window/container resize"
    - "Tab buttons have data-state='active' or data-state='inactive' attributes"
    - "Tab panels with lazy attribute render content only on first activation and preserve it after"
    - "Active panels without focusable children get tabindex='0'; panels with focusable children do not"
  artifacts:
    - path: "packages/tabs/src/tabs.ts"
      provides: "Animated indicator, data-state on buttons, ResizeObserver, conditional panel tabindex"
      contains: "tab-indicator"
    - path: "packages/tabs/src/tab-panel.ts"
      provides: "Lazy rendering with _hasBeenExpanded pattern"
      contains: "_hasBeenExpanded"
    - path: "packages/tabs/src/jsx.d.ts"
      provides: "lazy attribute type for LuiTabPanelAttributes"
      contains: "lazy"
    - path: "packages/core/src/styles/tailwind.css"
      provides: "Indicator CSS custom property tokens"
      contains: "--ui-tabs-indicator"
  key_links:
    - from: "packages/tabs/src/tabs.ts"
      to: "packages/tabs/src/tab-panel.ts"
      via: "syncPanelStates reads panel.lazy and calls panelHasFocusableContent"
      pattern: "panelHasFocusableContent"
    - from: "packages/tabs/src/tabs.ts"
      to: "packages/core/src/styles/tailwind.css"
      via: "Indicator div references --ui-tabs-indicator-* CSS vars"
      pattern: "--ui-tabs-indicator"
---

<objective>
Add the animated active indicator, data-state attributes on tab buttons, lazy panel rendering, and conditional panel tabindex to the tabs component.

Purpose: These features bring visual polish (sliding indicator), CSS-only styling hooks (data-state), performance optimization (lazy rendering), and W3C APG keyboard accessibility (conditional tabindex) to the tabs component.
Output: Updated tabs.ts with indicator + ResizeObserver + data-state + conditional tabindex, updated tab-panel.ts with lazy rendering, updated jsx.d.ts with lazy type, updated tailwind.css with indicator tokens.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/tabs/src/tabs.ts
@packages/tabs/src/tab-panel.ts
@packages/tabs/src/jsx.d.ts
@packages/core/src/styles/tailwind.css
@.planning/phases/59-tabs-polish-package/59-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Animated active indicator with ResizeObserver and data-state on tab buttons</name>
  <files>packages/tabs/src/tabs.ts, packages/core/src/styles/tailwind.css</files>
  <action>
In `packages/tabs/src/tabs.ts`:

1. Add import for `styleMap` from `lit/directives/style-map.js`.

2. Add private fields:
   - `_indicatorStyle: Record<string, string> = {}` - computed indicator position/size
   - `_indicatorReady = false` - prevents flash on first render
   - `resizeObserver: ResizeObserver | null = null` - tracks container resize

3. Add `updateIndicator()` method with `isServer` guard at top:
   - Query the active tab button by its ID: `#${this.tabsId}-tab-${this.value}`
   - Query the `.tablist` element
   - If either is null, set `_indicatorReady = false` and return
   - Use `getBoundingClientRect()` on both elements
   - For horizontal orientation: set `_indicatorStyle` to `{ transform: translateX(${buttonRect.left - tablistRect.left + tablist.scrollLeft}px), width: ${buttonRect.width}px }`
   - For vertical orientation: set `_indicatorStyle` to `{ transform: translateY(${buttonRect.top - tablistRect.top + tablist.scrollTop}px), height: ${buttonRect.height}px }`
   - Set `_indicatorReady = true`
   - Call `this.requestUpdate()`

4. Set up ResizeObserver in `firstUpdated()` (after existing SSR slotchange workaround):
   - Guard with `!isServer`
   - Query `.tablist`, create `new ResizeObserver(() => this.updateIndicator())`, observe the tablist
   - Also call `this.updateComplete.then(() => this.updateIndicator())` for initial positioning

5. Add `disconnectedCallback()` override: call `super.disconnectedCallback()`, disconnect and null the resizeObserver.

6. In `updated()`: after the existing `syncPanelStates()` call when value changes, add `this.updateComplete.then(() => this.updateIndicator())`.

7. In `handleSlotChange()`: after `this.requestUpdate()`, add `this.updateComplete.then(() => this.updateIndicator())`.

8. In the render template:
   - Add `data-state="${panel.value === this.value ? 'active' : 'inactive'}"` to each tab button element.
   - After the `this.panels.map(...)` block inside the `.tablist` div, add the indicator div:
     ```html
     <div
       class="tab-indicator"
       style=${styleMap({
         ...this._indicatorStyle,
         opacity: this._indicatorReady ? '1' : '0',
       })}
     ></div>
     ```

9. Add `.tablist { position: relative; }` to the existing `.tablist` CSS rule.

10. Add CSS for the indicator to `static override styles`:
    ```css
    .tab-indicator {
      position: absolute;
      bottom: 0;
      left: 0;
      height: var(--ui-tabs-indicator-height, 2px);
      background: var(--ui-tabs-indicator-color, var(--color-primary, var(--ui-color-primary)));
      border-radius: var(--ui-tabs-indicator-radius, 9999px);
      transition:
        transform var(--ui-tabs-indicator-transition, 200ms) ease,
        width var(--ui-tabs-indicator-transition, 200ms) ease,
        height var(--ui-tabs-indicator-transition, 200ms) ease,
        opacity 150ms ease;
      pointer-events: none;
    }

    :host([orientation="vertical"]) .tab-indicator {
      bottom: auto;
      top: 0;
      width: var(--ui-tabs-indicator-height, 2px) !important;
    }
    ```

11. Add reduced motion media query for indicator:
    ```css
    @media (prefers-reduced-motion: reduce) {
      .tab-indicator {
        transition-duration: 0ms;
      }
    }
    ```
    (Add inside the existing @media block.)

In `packages/core/src/styles/tailwind.css`:

12. Add indicator CSS custom properties in the `:root` block after the existing `--ui-tabs-transition` line:
    ```css
    --ui-tabs-indicator-color: var(--color-primary, var(--ui-color-primary));
    --ui-tabs-indicator-height: 2px;
    --ui-tabs-indicator-radius: 9999px;
    --ui-tabs-indicator-transition: 200ms;
    ```

13. Add indicator dark mode token in the `.dark` block after the existing tabs dark tokens:
    ```css
    --ui-tabs-indicator-color: var(--color-primary, var(--ui-color-primary));
    ```
  </action>
  <verify>
Run `cd /Users/sn0w/Documents/dev/lit-components && pnpm --filter @lit-ui/tabs build` and confirm zero build errors. Verify `tabs.ts` contains `tab-indicator` class, `styleMap` usage, `updateIndicator` method, `ResizeObserver`, `data-state` attribute on buttons. Verify tailwind.css contains `--ui-tabs-indicator-*` tokens.
  </verify>
  <done>
Tab buttons render data-state="active"/"inactive". An absolutely-positioned indicator div inside the tablist slides between tabs via CSS transition on transform/width. ResizeObserver repositions indicator on container resize. Indicator starts invisible (opacity:0) until first measurement to prevent flash. Indicator works for both horizontal and vertical orientations. Four new CSS custom properties are available for indicator theming.
  </done>
</task>

<task type="auto">
  <name>Task 2: Lazy panel rendering and conditional panel tabindex</name>
  <files>packages/tabs/src/tab-panel.ts, packages/tabs/src/tabs.ts, packages/tabs/src/jsx.d.ts</files>
  <action>
In `packages/tabs/src/tab-panel.ts`:

1. Add `nothing` to the import from `lit` (already has `html`, `css`, `isServer`).

2. Add `lazy` property:
   ```typescript
   @property({ type: Boolean })
   lazy = false;
   ```

3. Add private field (NOT @state):
   ```typescript
   private _hasBeenExpanded = false;
   ```

4. In the existing `updated()` method, after the `data-state` logic, add:
   ```typescript
   if (changedProperties.has('active') && this.active) {
     this._hasBeenExpanded = true;
   }
   ```

5. Update `render()` to conditionally render slot:
   ```typescript
   override render() {
     if (this.lazy && !this._hasBeenExpanded && !this.active) {
       return html``;
     }
     return html`<slot></slot>`;
   }
   ```

In `packages/tabs/src/tabs.ts`:

6. Add `panelHasFocusableContent()` private method:
   ```typescript
   private panelHasFocusableContent(panel: TabPanel): boolean {
     const focusableSelector =
       'a[href], button:not([disabled]), input:not([disabled]), ' +
       'select:not([disabled]), textarea:not([disabled]), ' +
       '[tabindex]:not([tabindex="-1"])';
     return panel.querySelector(focusableSelector) !== null;
   }
   ```

7. Update `syncPanelStates()` to use conditional tabindex instead of always setting tabindex="0" on active panels. Replace the current tabindex logic:
   ```typescript
   if (isActive) {
     if (this.panelHasFocusableContent(panel)) {
       panel.removeAttribute('tabindex');
     } else {
       panel.setAttribute('tabindex', '0');
     }
   } else {
     panel.removeAttribute('tabindex');
   }
   ```

   For lazy panels that are activating for the first time, the slot content may not be in the DOM yet. To handle this, after the syncPanelStates loop, for any active lazy panel, schedule a deferred re-check:
   ```typescript
   // After the for loop, handle lazy panel + TABS-22 timing
   const activePanel = this.panels.find(p => p.value === this.value);
   if (activePanel?.lazy) {
     requestAnimationFrame(() => {
       if (this.panelHasFocusableContent(activePanel)) {
         activePanel.removeAttribute('tabindex');
       } else {
         activePanel.setAttribute('tabindex', '0');
       }
     });
   }
   ```

In `packages/tabs/src/jsx.d.ts`:

8. Add `lazy?: boolean;` to the `LuiTabPanelAttributes` interface, after the `active` property.
  </action>
  <verify>
Run `cd /Users/sn0w/Documents/dev/lit-components && pnpm --filter @lit-ui/tabs build` and confirm zero build errors. Verify `tab-panel.ts` contains `lazy` property, `_hasBeenExpanded` field, conditional render. Verify `tabs.ts` contains `panelHasFocusableContent`, conditional tabindex logic. Verify `jsx.d.ts` has `lazy` in `LuiTabPanelAttributes`.
  </verify>
  <done>
Lazy panels render nothing until first activation, then preserve content. Active panels get tabindex="0" only when they have no focusable children (W3C APG). Lazy panel + tabindex interaction handled with deferred re-check. JSX types updated for lazy attribute.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @lit-ui/tabs build` succeeds with zero errors
2. `tabs.ts` has: indicator div with styleMap, updateIndicator() with getBoundingClientRect, ResizeObserver setup/teardown, data-state on tab buttons, panelHasFocusableContent, conditional tabindex
3. `tab-panel.ts` has: lazy property, _hasBeenExpanded flag, conditional slot render
4. `tailwind.css` has: --ui-tabs-indicator-color, --ui-tabs-indicator-height, --ui-tabs-indicator-radius, --ui-tabs-indicator-transition in both :root and .dark blocks
5. `jsx.d.ts` has: lazy in LuiTabPanelAttributes
</verification>

<success_criteria>
- Active tab indicator slides between tabs with CSS transition (no JS animation loop)
- Indicator repositions on container resize via ResizeObserver
- Indicator hidden until first measurement (no position flash)
- Tab buttons have data-state="active"/"inactive"
- Lazy panels render nothing until first activation, then preserve slot content
- Active panels: tabindex="0" only when no focusable children exist
- All code compiles and builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/59-tabs-polish-package/59-01-SUMMARY.md`
</output>
