---
phase: 49-time-picker-advanced
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/time-picker/src/time-range-slider.ts
autonomous: true

must_haves:
  truths:
    - "User can drag two thumbs to select a start and end time range on a horizontal track"
    - "Thumbs show formatted time labels that update during drag"
    - "Fill between thumbs indicates the selected range visually"
    - "Keyboard (arrow keys) adjusts each thumb by step interval"
    - "Component follows WAI-ARIA Slider pattern with proper aria attributes"
  artifacts:
    - path: "packages/time-picker/src/time-range-slider.ts"
      provides: "Dual-handle time range slider component"
      contains: "TimeRangeSlider"
  key_links:
    - from: "packages/time-picker/src/time-range-slider.ts"
      to: "Pointer Events API"
      via: "pointerdown/pointermove/pointerup on track element"
      pattern: "handlePointerDown"
---

<objective>
Create a dual-handle time range slider component for visual duration selection.

Purpose: Fulfills TP-18 (time range slider). Internal component composed by TimePicker when needed (wired in Plan 06).
Output: New time-range-slider.ts component with dual thumbs, pointer events, and ARIA slider pattern.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-time-picker-advanced/49-RESEARCH.md
@packages/time-picker/src/time-utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TimeRangeSlider component with dual handles and pointer events</name>
  <files>packages/time-picker/src/time-range-slider.ts</files>
  <action>
Create `lui-time-range-slider` internal component. Each thumb represents minutes since midnight (0-1440).

1. Import from Lit and @lit-ui/core. Import `TimeValue, formatTimeForDisplay` from `./time-utils.js`.

2. Define `TimeRangeSlider` extending `TailwindElement`:

   **Properties:**
   - `@property({ type: Number }) startMinutes = 540;` -- default 9:00 AM (9*60)
   - `@property({ type: Number }) endMinutes = 1020;` -- default 5:00 PM (17*60)
   - `@property({ type: Number }) step = 30;` -- step in minutes
   - `@property({ type: Boolean }) hour12 = false;`
   - `@property() locale = 'en-US';`
   - `@property({ type: Boolean, reflect: true }) disabled = false;`

   **Internal state:**
   - `@state() private _activeThumb: 'start' | 'end' | null = null;`

   **Private helper `_minutesToTimeValue(minutes: number): TimeValue`:**
   - `hour: Math.floor(minutes / 60) % 24`
   - `minute: minutes % 60`
   - `second: 0`

   **Private helper `_formatMinutes(minutes: number): string`:**
   - Convert to TimeValue, then call `formatTimeForDisplay(tv, this.locale, this.hour12)`.

   **Private helper `_snapToStep(minutes: number): number`:**
   - `Math.round(minutes / this.step) * this.step`
   - Clamp to [0, 1440].

   **Pointer event handlers on the track div:**

   `_handlePointerDown(e: PointerEvent)`:
   - If disabled, return.
   - `e.preventDefault();`
   - Determine which thumb is closer to click position by comparing percentage along track.
   - Set `_activeThumb` to 'start' or 'end'.
   - `(e.currentTarget as HTMLElement).setPointerCapture(e.pointerId);`
   - Call `_updateFromPointer(e)`.

   `_handlePointerMove(e: PointerEvent)`:
   - If `_activeThumb` is null, return.
   - Call `_updateFromPointer(e)`.

   `_handlePointerUp(e: PointerEvent)`:
   - If `_activeThumb` is null, return.
   - `(e.currentTarget as HTMLElement).releasePointerCapture(e.pointerId);`
   - `_activeThumb = null;`
   - Dispatch change event with start/end values.

   `_updateFromPointer(e: PointerEvent)`:
   - Get track element bounding rect.
   - Calculate percentage: `(e.clientX - rect.left) / rect.width` clamped to [0, 1].
   - Convert to minutes: `percentage * 1440`.
   - Snap to step.
   - If active thumb is 'start': set `startMinutes`, ensure `startMinutes <= endMinutes`.
   - If active thumb is 'end': set `endMinutes`, ensure `endMinutes >= startMinutes`.
   - Dispatch interim `ui-range-input` event.

   **Keyboard handler on each thumb div:**
   - ArrowRight/ArrowUp: increment by step
   - ArrowLeft/ArrowDown: decrement by step
   - Home: set to 0 (start thumb) or startMinutes (end thumb)
   - End: set to endMinutes (start thumb) or 1440 (end thumb)

   **Render:**
   ```html
   <div class="range-slider-wrapper">
     <div class="range-labels">
       <span class="range-label">${this._formatMinutes(this.startMinutes)}</span>
       <span class="range-duration">${Math.round((this.endMinutes - this.startMinutes) / 60)}h ${(this.endMinutes - this.startMinutes) % 60}m</span>
       <span class="range-label">${this._formatMinutes(this.endMinutes)}</span>
     </div>
     <div
       class="range-track"
       @pointerdown=${this._handlePointerDown}
       @pointermove=${this._handlePointerMove}
       @pointerup=${this._handlePointerUp}
     >
       <div class="range-fill" style="left: ${startPct}%; width: ${endPct - startPct}%"></div>
       <div
         class="range-thumb"
         role="slider"
         tabindex="0"
         aria-label="Start time"
         aria-valuemin="0"
         aria-valuemax="1440"
         aria-valuenow=${this.startMinutes}
         aria-valuetext=${this._formatMinutes(this.startMinutes)}
         style="left: ${startPct}%"
         @keydown=${(e: KeyboardEvent) => this._handleThumbKeydown(e, 'start')}
       ></div>
       <div
         class="range-thumb"
         role="slider"
         tabindex="0"
         aria-label="End time"
         aria-valuemin="0"
         aria-valuemax="1440"
         aria-valuenow=${this.endMinutes}
         aria-valuetext=${this._formatMinutes(this.endMinutes)}
         style="left: ${endPct}%"
         @keydown=${(e: KeyboardEvent) => this._handleThumbKeydown(e, 'end')}
       ></div>
     </div>
     ${this._renderTickMarks()}
   </div>
   ```

   **Tick marks:** Render small marks at every 3 hours (0, 180, 360, 540, 720, 900, 1080, 1260). Use `_formatMinutes` for labels under tick marks.

   **CSS styles:**
   ```css
   :host { display: block; padding: 0.5rem 0; }

   .range-slider-wrapper { position: relative; }

   .range-labels {
     display: flex;
     justify-content: space-between;
     align-items: center;
     margin-bottom: 0.5rem;
     font-size: 0.875rem;
   }

   .range-label {
     color: var(--ui-time-picker-text, #1f2937);
     font-variant-numeric: tabular-nums;
   }

   .range-duration {
     font-size: 0.75rem;
     color: var(--ui-time-picker-timezone-text, #6b7280);
   }

   .range-track {
     position: relative;
     height: 6px;
     background: var(--ui-time-picker-range-track-bg, #e5e7eb);
     border-radius: 3px;
     cursor: pointer;
     touch-action: none;
   }

   .range-fill {
     position: absolute;
     height: 100%;
     background: var(--ui-time-picker-primary, var(--ui-primary, #3b82f6));
     border-radius: 3px;
   }

   .range-thumb {
     position: absolute;
     top: 50%;
     width: 20px;
     height: 20px;
     background: white;
     border: 2px solid var(--ui-time-picker-primary, var(--ui-primary, #3b82f6));
     border-radius: 50%;
     transform: translate(-50%, -50%);
     cursor: grab;
     outline: none;
     z-index: 1;
   }

   .range-thumb:focus-visible {
     box-shadow: 0 0 0 3px var(--ui-time-picker-focus-ring, #3b82f6);
   }

   .range-thumb:active { cursor: grabbing; }

   .tick-marks {
     display: flex;
     justify-content: space-between;
     margin-top: 0.25rem;
     padding: 0 10px;
   }

   .tick-label {
     font-size: 0.625rem;
     color: var(--ui-time-picker-timezone-text, #9ca3af);
   }
   ```

   Dark mode styles with `:host-context(.dark)`:
   - Track bg: #374151
   - Thumb bg: #1f2937
   - Thumb border: primary
   - Labels: lighter colors (#e5e7eb, #9ca3af)

3. Dispatch `ui-time-range-change` CustomEvent with `{ startMinutes, endMinutes, startTime: TimeValue, endTime: TimeValue }`.

4. Safe custom element registration at bottom (same pattern as other internals).

**Key decisions:**
- Use Pointer Events (not Touch Events) per project convention.
- Minutes since midnight (0-1440) for internal representation; convert to TimeValue for display.
- Closer-thumb-to-click strategy for thumb activation (avoids thumb overlap issues from research pitfall 4).
  </action>
  <verify>
Build: `cd packages/time-picker && npx tsc --noEmit`. No type errors.
Verify file has dual-thumb slider with ARIA slider attributes and pointer event handlers.
  </verify>
  <done>TimeRangeSlider renders a dual-handle slider track with pointer event drag, keyboard support, formatted time labels, duration display, tick marks, and WAI-ARIA Slider pattern compliance.</done>
</task>

</tasks>

<verification>
1. `cd packages/time-picker && npx tsc --noEmit` passes
2. `grep -n 'role="slider"\|pointerdown\|aria-valuenow\|_snapToStep' packages/time-picker/src/time-range-slider.ts` confirms ARIA pattern and pointer events
3. Component dispatches `ui-time-range-change` event
</verification>

<success_criteria>
- Dual thumbs draggable via Pointer Events with snap-to-step
- Time labels update during drag
- Fill between thumbs shows selected range
- Keyboard arrows adjust by step increment
- WAI-ARIA Slider pattern with aria-valuenow/min/max/text
- Dark mode via :host-context(.dark)
</success_criteria>

<output>
After completion, create `.planning/phases/49-time-picker-advanced/49-03-SUMMARY.md`
</output>
