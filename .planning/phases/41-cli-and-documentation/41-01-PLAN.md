---
phase: 41-cli-and-documentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/cli/src/registry/registry.json
  - packages/cli/src/templates/index.ts
  - packages/cli/src/utils/install-component.ts
  - packages/cli/src/commands/list.ts
autonomous: true

must_haves:
  truths:
    - "Developer runs `npx lit-ui add checkbox` and gets checkbox + checkbox-group files"
    - "Developer runs `npx lit-ui add radio` and gets radio + radio-group files"
    - "Developer runs `npx lit-ui add switch` and gets switch file"
    - "Developer runs `npx lit-ui add checkbox --npm` and @lit-ui/checkbox is installed"
    - "Developer runs `lit-ui list` and sees checkbox, radio, switch under Form category"
  artifacts:
    - path: "packages/cli/src/registry/registry.json"
      provides: "Registry entries for checkbox, radio, switch"
      contains: '"name": "checkbox"'
    - path: "packages/cli/src/templates/index.ts"
      provides: "CHECKBOX_TEMPLATE, CHECKBOX_GROUP_TEMPLATE, RADIO_TEMPLATE, RADIO_GROUP_TEMPLATE, SWITCH_TEMPLATE"
      exports: ["CHECKBOX_TEMPLATE", "RADIO_TEMPLATE", "SWITCH_TEMPLATE"]
    - path: "packages/cli/src/utils/install-component.ts"
      provides: "NPM mode mapping for checkbox, radio, switch"
      contains: "checkbox: '@lit-ui/checkbox'"
    - path: "packages/cli/src/commands/list.ts"
      provides: "checkbox, radio, switch in Form category"
      contains: "'checkbox'"
  key_links:
    - from: "packages/cli/src/templates/index.ts"
      to: "COMPONENT_TEMPLATES map"
      via: "checkbox, radio, switch keys"
      pattern: "checkbox.*CHECKBOX_TEMPLATE"
    - from: "packages/cli/src/registry/registry.json"
      to: "CLI add command"
      via: "components array entries"
      pattern: '"name": "checkbox"'
---

<objective>
Add Checkbox, Radio, and Switch to CLI registry, templates, NPM mapping, and list categories.

Purpose: Enable developers to install all three new components via both copy-source and NPM modes, and see them in the component list.
Output: Updated CLI files with entries for checkbox, radio, and switch components.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/41-cli-and-documentation/41-RESEARCH.md

# Reference files
@packages/cli/src/registry/registry.json
@packages/cli/src/templates/index.ts
@packages/cli/src/utils/install-component.ts
@packages/cli/src/commands/list.ts

# Source components (for template content)
@packages/switch/src/switch.ts
@packages/checkbox/src/checkbox.ts
@packages/checkbox/src/checkbox-group.ts
@packages/radio/src/radio.ts
@packages/radio/src/radio-group.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add registry entries and NPM mappings</name>
  <files>
    packages/cli/src/registry/registry.json
    packages/cli/src/utils/install-component.ts
    packages/cli/src/commands/list.ts
  </files>
  <action>
**registry.json:** Add three entries to the `components` array after the "select" entry:

```json
{
  "name": "checkbox",
  "description": "Accessible checkbox with indeterminate state and CheckboxGroup with select-all",
  "files": [
    { "path": "components/checkbox/checkbox.ts", "type": "component" },
    { "path": "components/checkbox/checkbox-group.ts", "type": "component" }
  ],
  "dependencies": [],
  "registryDependencies": []
},
{
  "name": "radio",
  "description": "Accessible radio button with RadioGroup for mutual exclusion and arrow key navigation",
  "files": [
    { "path": "components/radio/radio.ts", "type": "component" },
    { "path": "components/radio/radio-group.ts", "type": "component" }
  ],
  "dependencies": [],
  "registryDependencies": []
},
{
  "name": "switch",
  "description": "Toggle switch with animated slide transition and form participation",
  "files": [
    { "path": "components/switch/switch.ts", "type": "component" }
  ],
  "dependencies": [],
  "registryDependencies": []
}
```

Note: Checkbox needs 2 files (checkbox.ts + checkbox-group.ts), Radio needs 2 files (radio.ts + radio-group.ts), Switch needs 1 file. This follows the Select pattern which has 3 files.

**install-component.ts:** Add three entries to the `componentToPackage` map:

```typescript
checkbox: '@lit-ui/checkbox',
radio: '@lit-ui/radio',
switch: '@lit-ui/switch',
```

Add these after the existing `select` entry.

**list.ts:** Update the Form category to include the new components:

```typescript
'Form': ['input', 'textarea', 'select', 'checkbox', 'radio', 'switch'],
```
  </action>
  <verify>
1. Read registry.json and confirm 8 components exist (button, dialog, input, textarea, select, checkbox, radio, switch)
2. Read install-component.ts and confirm checkbox, radio, switch entries exist in componentToPackage
3. Read list.ts and confirm Form category contains checkbox, radio, switch
  </verify>
  <done>
registry.json has 8 component entries. componentToPackage has 8 mappings. Form category lists all 6 form controls.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add copy-source templates for all three components</name>
  <files>packages/cli/src/templates/index.ts</files>
  <action>
Add template constants to templates/index.ts for the new components. Each template embeds the component source code as a template string, following the exact pattern used by BUTTON_TEMPLATE, INPUT_TEMPLATE, etc.

**Critical import path adjustment:** All templates must replace:
- `from '@lit-ui/core'` → `from '../../lib/lit-ui/tailwind-element'`
- `from '@lit-ui/core'` (for dispatchCustomEvent) → inline the helper function OR import from tailwind-element

**Check first:** Read `packages/cli/src/templates/index.ts` to see how existing templates (especially INPUT_TEMPLATE) handle the `dispatchCustomEvent` import. If the existing copy-source base file does NOT export `dispatchCustomEvent`, then inline it at the top of each template as:

```typescript
function dispatchCustomEvent(el: HTMLElement, name: string, detail?: unknown) {
  el.dispatchEvent(new CustomEvent(name, { detail, bubbles: true, composed: true }));
}
```

**Templates to create (5 total):**

1. `SWITCH_TEMPLATE` — Embed full switch.ts source with adjusted imports. Single file, simplest component.

2. `CHECKBOX_TEMPLATE` — Embed full checkbox.ts source with adjusted imports.

3. `CHECKBOX_GROUP_TEMPLATE` — Embed full checkbox-group.ts source with adjusted imports. Import path for checkbox should be `./checkbox` (relative within same directory).

4. `RADIO_TEMPLATE` — Embed full radio.ts source with adjusted imports.

5. `RADIO_GROUP_TEMPLATE` — Embed full radio-group.ts source with adjusted imports. Import path for radio should be `./radio` (relative within same directory).

**Then update the `COMPONENT_TEMPLATES` record** to add all entries. For multi-file components, the record needs to map correctly:

```typescript
// In COMPONENT_TEMPLATES record:
checkbox: CHECKBOX_TEMPLATE,
'checkbox-group': CHECKBOX_GROUP_TEMPLATE,
radio: RADIO_TEMPLATE,
'radio-group': RADIO_GROUP_TEMPLATE,
switch: SWITCH_TEMPLATE,
```

Wait — check how Select handles multiple templates in the COMPONENT_TEMPLATES record. Look at the existing SELECT_TEMPLATE pattern. The registry.json `files` array lists each file path, and the template system uses `getComponentTemplate(filename)` to look up templates. So the key in COMPONENT_TEMPLATES should match the file path pattern from registry.json.

Read the existing template lookup logic in `packages/cli/src/utils/` or `packages/cli/src/commands/add.ts` to understand how multi-file templates are resolved. The registry entry's `files[].path` like `components/checkbox/checkbox.ts` likely maps to template name `checkbox` somehow. Match the existing Select pattern exactly.

**Template string escaping:** Follow the exact escaping pattern from existing templates:
- Outer backticks for the template literal string
- `\`` for internal template literal backticks (css\`...\` and html\`...\`)
- `\${}` for lit template expressions inside the template
- Regular `${}` for JavaScript string interpolation in template literals within the embedded code

Read the existing BUTTON_TEMPLATE and INPUT_TEMPLATE carefully for the exact escaping conventions before writing.
  </action>
  <verify>
1. grep for SWITCH_TEMPLATE, CHECKBOX_TEMPLATE, RADIO_TEMPLATE in templates/index.ts — all should exist
2. grep for each template in COMPONENT_TEMPLATES record
3. Run type check: `pnpm --filter lit-ui exec tsc --noEmit` (or check for syntax errors)
4. Verify import paths use `../../lib/lit-ui/tailwind-element` not `@lit-ui/core`
  </verify>
  <done>
templates/index.ts exports SWITCH_TEMPLATE, CHECKBOX_TEMPLATE, CHECKBOX_GROUP_TEMPLATE, RADIO_TEMPLATE, RADIO_GROUP_TEMPLATE. All are included in COMPONENT_TEMPLATES. Import paths adjusted for copy-source mode. dispatchCustomEvent is either inlined or imported from local base.
  </done>
</task>

</tasks>

<verification>
1. registry.json has 8 components
2. install-component.ts has checkbox, radio, switch in componentToPackage
3. list.ts Form category has all 6 form components
4. templates/index.ts has 5 new template constants and all are in COMPONENT_TEMPLATES
5. All templates use local import paths (not @lit-ui/core)
6. TypeScript compiles: `pnpm --filter lit-ui exec tsc --noEmit`
</verification>

<success_criteria>
- `lit-ui add checkbox` works in both copy-source and NPM modes
- `lit-ui add radio` works in both modes
- `lit-ui add switch` works in both modes
- `lit-ui list` shows all three under Form category
- Copy-source templates compile without import errors
</success_criteria>

<output>
After completion, create `.planning/phases/41-cli-and-documentation/41-01-SUMMARY.md`
</output>
