---
phase: 32-core-single-select
plan: 02
type: execute
wave: 2
depends_on: ["32-01"]
files_modified:
  - packages/select/src/select.ts
autonomous: true

must_haves:
  truths:
    - "User navigates options with arrow keys without using mouse"
    - "User selects option with Enter key"
    - "User closes dropdown with Escape key"
    - "User types characters and focus moves to matching option"
    - "Home/End keys jump to first/last option"
  artifacts:
    - path: "packages/select/src/select.ts"
      provides: "Full keyboard navigation and type-ahead"
      contains: "handleKeydown"
  key_links:
    - from: "packages/select/src/select.ts"
      to: "W3C APG pattern"
      via: "Keyboard event handling"
      pattern: "ArrowDown|ArrowUp|Enter|Escape|Home|End"
---

<objective>
Implement comprehensive keyboard navigation following W3C APG combobox pattern including arrow keys, Enter/Space, Escape, Home/End, and type-ahead search.

Purpose: Enable full keyboard accessibility so users can operate the select without a mouse.
Output: Keyboard navigation that meets W3C APG select-only combobox specification.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-core-single-select/32-RESEARCH.md
@.planning/phases/32-core-single-select/32-01-SUMMARY.md
@packages/select/src/select.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add keyboard navigation state machine</name>
  <files>packages/select/src/select.ts</files>
  <action>
Add comprehensive keyboard handling to the Select component following W3C APG:

1. **Add keydown handler to component:**
```typescript
private handleKeydown(e: KeyboardEvent): void {
  const key = e.key;

  // Handle closed state
  if (!this.open) {
    switch (key) {
      case 'ArrowDown':
      case 'ArrowUp':
      case 'Enter':
      case ' ':
        e.preventDefault();
        this.openDropdown();
        if (key === 'ArrowUp') {
          this.focusLastEnabledOption();
        } else {
          this.focusFirstEnabledOption();
        }
        break;
      case 'Home':
        e.preventDefault();
        this.openDropdown();
        this.focusFirstEnabledOption();
        break;
      case 'End':
        e.preventDefault();
        this.openDropdown();
        this.focusLastEnabledOption();
        break;
      default:
        // Printable character - type-ahead
        if (this.isPrintableCharacter(key)) {
          e.preventDefault();
          this.openDropdown();
          this.handleTypeahead(key);
        }
    }
    return;
  }

  // Handle open state
  switch (key) {
    case 'ArrowDown':
      e.preventDefault();
      this.focusNextEnabledOption();
      break;
    case 'ArrowUp':
      e.preventDefault();
      this.focusPreviousEnabledOption();
      break;
    case 'Home':
      e.preventDefault();
      this.focusFirstEnabledOption();
      break;
    case 'End':
      e.preventDefault();
      this.focusLastEnabledOption();
      break;
    case 'Enter':
    case ' ':
      e.preventDefault();
      if (this.activeIndex >= 0) {
        this.selectOption(this.activeIndex);
      }
      break;
    case 'Escape':
      e.preventDefault();
      this.closeDropdown();
      break;
    case 'Tab':
      // Select current and close on Tab (don't prevent default - let Tab proceed)
      if (this.activeIndex >= 0) {
        this.selectOption(this.activeIndex);
      } else {
        this.closeDropdown();
      }
      break;
    default:
      // Printable character - type-ahead
      if (this.isPrintableCharacter(key)) {
        e.preventDefault();
        this.handleTypeahead(key);
      }
  }
}

private isPrintableCharacter(key: string): boolean {
  return key.length === 1 && !key.match(/[\x00-\x1f\x7f]/);
}
```

2. **Add focus navigation helpers:**
```typescript
private focusFirstEnabledOption(): void {
  const index = this.options.findIndex(o => !o.disabled);
  if (index >= 0) {
    this.setActiveIndex(index);
  }
}

private focusLastEnabledOption(): void {
  for (let i = this.options.length - 1; i >= 0; i--) {
    if (!this.options[i].disabled) {
      this.setActiveIndex(i);
      return;
    }
  }
}

private focusNextEnabledOption(): void {
  for (let i = this.activeIndex + 1; i < this.options.length; i++) {
    if (!this.options[i].disabled) {
      this.setActiveIndex(i);
      return;
    }
  }
  // Wrap to first if at end
  this.focusFirstEnabledOption();
}

private focusPreviousEnabledOption(): void {
  for (let i = this.activeIndex - 1; i >= 0; i--) {
    if (!this.options[i].disabled) {
      this.setActiveIndex(i);
      return;
    }
  }
  // Wrap to last if at beginning
  this.focusLastEnabledOption();
}

private setActiveIndex(index: number): void {
  this.activeIndex = index;
  // Scroll into view
  this.updateComplete.then(() => {
    const optionEl = this.shadowRoot?.getElementById(`${this.selectId}-option-${index}`);
    optionEl?.scrollIntoView({ block: 'nearest' });
  });
}
```

3. **Update trigger in render to include keydown:**
```typescript
@keydown=${this.handleKeydown}
```
  </action>
  <verify>
Build passes: `pnpm --filter @lit-ui/select build`
select.ts contains:
- handleKeydown method with ArrowDown, ArrowUp, Enter, Space, Escape, Home, End cases
- Both open and closed state handling
- scrollIntoView({ block: 'nearest' }) for active option
  </verify>
  <done>Arrow keys navigate options, Enter selects, Escape closes, Home/End jump to boundaries</done>
</task>

<task type="auto">
  <name>Task 2: Add type-ahead search</name>
  <files>packages/select/src/select.ts</files>
  <action>
Implement type-ahead search with debounced character concatenation:

1. **Add type-ahead state:**
```typescript
private typeaheadString = '';
private typeaheadTimeout: ReturnType<typeof setTimeout> | null = null;
private static readonly TYPEAHEAD_RESET_MS = 500;
```

2. **Add type-ahead handler:**
```typescript
private handleTypeahead(char: string): void {
  // Clear previous timeout
  if (this.typeaheadTimeout !== null) {
    clearTimeout(this.typeaheadTimeout);
  }

  // Append character to search string
  this.typeaheadString += char.toLowerCase();

  // Find matching option
  const matchIndex = this.findTypeaheadMatch(this.typeaheadString);
  if (matchIndex >= 0) {
    this.setActiveIndex(matchIndex);
  }

  // Set timeout to reset string after 500ms
  this.typeaheadTimeout = setTimeout(() => {
    this.typeaheadString = '';
    this.typeaheadTimeout = null;
  }, Select.TYPEAHEAD_RESET_MS);
}

private findTypeaheadMatch(searchString: string): number {
  // Get enabled options with their original indices
  const enabledOptions = this.options
    .map((opt, idx) => ({ opt, idx }))
    .filter(({ opt }) => !opt.disabled);

  if (enabledOptions.length === 0) return -1;

  // If repeating same character (e.g., "aaa"), cycle through matches
  const isRepeatedChar = searchString.length > 1 &&
    searchString.split('').every(c => c === searchString[0]);

  if (isRepeatedChar) {
    const char = searchString[0];
    const matches = enabledOptions.filter(({ opt }) =>
      (opt.label || opt.value).toLowerCase().startsWith(char)
    );

    if (matches.length > 0) {
      // Find current position in matches
      const currentMatchIdx = matches.findIndex(({ idx }) => idx === this.activeIndex);
      // Move to next match (wrap around)
      const nextMatchIdx = (currentMatchIdx + 1) % matches.length;
      return matches[nextMatchIdx].idx;
    }
    return -1;
  }

  // Otherwise find first match for full string
  const match = enabledOptions.find(({ opt }) =>
    (opt.label || opt.value).toLowerCase().startsWith(searchString)
  );

  return match?.idx ?? -1;
}
```

3. **Add cleanup in disconnectedCallback:**
```typescript
override disconnectedCallback(): void {
  super.disconnectedCallback();
  if (!isServer) {
    document.removeEventListener('click', this.handleDocumentClick);
    // Clear typeahead timeout
    if (this.typeaheadTimeout !== null) {
      clearTimeout(this.typeaheadTimeout);
      this.typeaheadTimeout = null;
    }
  }
}
```
  </action>
  <verify>
Build passes: `pnpm --filter @lit-ui/select build`
select.ts contains:
- typeaheadString and typeaheadTimeout state
- TYPEAHEAD_RESET_MS constant (500)
- findTypeaheadMatch with repeated char cycling
- Timeout cleanup in disconnectedCallback
  </verify>
  <done>Type-ahead focuses matching option, resets after 500ms, cycles through repeated chars</done>
</task>

<task type="auto">
  <name>Task 3: Add ARIA live region for screen reader announcements</name>
  <files>packages/select/src/select.ts</files>
  <action>
Add ARIA live region to announce option changes for VoiceOver compatibility (since aria-activedescendant has poor mobile support):

1. **Add helper to get active option label:**
```typescript
private getActiveOptionLabel(): string {
  if (this.activeIndex < 0 || this.activeIndex >= this.options.length) return '';
  const opt = this.options[this.activeIndex];
  return opt.label || opt.value;
}

private getEnabledOptionsCount(): number {
  return this.options.filter(o => !o.disabled).length;
}
```

2. **Add CSS for visually hidden:**
```css
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
```

3. **Add live region to render:**
Add at the end of render() return:
```typescript
<!-- ARIA live region for screen reader announcements -->
<div
  role="status"
  aria-live="polite"
  aria-atomic="true"
  class="visually-hidden"
>
  ${this.open && this.activeIndex >= 0
    ? `${this.getActiveOptionLabel()}, ${this.activeIndex + 1} of ${this.getEnabledOptionsCount()}`
    : ''}
</div>
```

This announces the current option and position when navigating with keyboard, compensating for poor aria-activedescendant support on mobile.
  </action>
  <verify>
Build passes: `pnpm --filter @lit-ui/select build`
select.ts contains:
- role="status" aria-live="polite" element
- visually-hidden CSS class
- Announcement includes option label and position
  </verify>
  <done>Screen readers announce option changes via live region</done>
</task>

</tasks>

<verification>
1. Build succeeds: `pnpm --filter @lit-ui/select build`
2. Keyboard navigation works:
   - ArrowDown opens dropdown and moves to next option
   - ArrowUp opens dropdown and moves to previous option
   - Enter/Space open dropdown when closed, select option when open
   - Escape closes dropdown
   - Home jumps to first enabled option
   - End jumps to last enabled option
   - Tab selects and closes, continues tab navigation
3. Type-ahead works:
   - Typing "a" focuses first option starting with "a"
   - Typing "ap" focuses first option starting with "ap"
   - After 500ms pause, typing "b" searches for "b" (not "apb")
   - Typing "aaa" cycles through all options starting with "a"
4. ARIA live region exists for VoiceOver compatibility
</verification>

<success_criteria>
- All keyboard shortcuts work per W3C APG specification
- Type-ahead search finds matching options
- Type-ahead resets after 500ms of inactivity
- Repeated character typing cycles through matches
- Options scroll into view when navigating
- Live region announces current option position
</success_criteria>

<output>
After completion, create `.planning/phases/32-core-single-select/32-02-SUMMARY.md`
</output>
