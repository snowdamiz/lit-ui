---
phase: 61-core-table-shell-virtualization
plan: 03
type: execute
wave: 3
depends_on: ["61-02"]
files_modified:
  - packages/data-table/src/data-table.ts
autonomous: true

must_haves:
  truths:
    - "User can scroll through 100K rows with smooth 60fps performance"
    - "User sees only visible rows plus buffer rendered in DOM"
    - "User's scroll position is preserved when data updates"
    - "User sees fixed header while scrolling body"
  artifacts:
    - path: "packages/data-table/src/data-table.ts"
      provides: "DataTable with VirtualizerController integration"
      contains: "VirtualizerController"
  key_links:
    - from: "packages/data-table/src/data-table.ts"
      to: "@tanstack/lit-virtual"
      via: "VirtualizerController import"
      pattern: "VirtualizerController"
    - from: "packages/data-table/src/data-table.ts"
      to: "scroll container"
      via: "getScrollElement callback"
      pattern: "getScrollElement"
---

<objective>
Add virtual scrolling to DataTable using TanStack Virtual's VirtualizerController.

Purpose: Enable rendering of 100K+ rows with 60fps scroll performance by only rendering visible rows plus a buffer. This is critical for admin dashboard use cases with large datasets.

Output:
- VirtualizerController integrated with DataTable
- Absolutely positioned virtual rows with transform translateY
- Scroll position preservation across data updates
- Fixed header above scrollable body
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/61-core-table-shell-virtualization/61-RESEARCH.md
@.planning/phases/61-core-table-shell-virtualization/61-02-SUMMARY.md
@packages/select/src/select.ts (lines 489-510, 1448-1470, 3011-3030 for VirtualizerController pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add VirtualizerController for row virtualization</name>
  <files>
    packages/data-table/src/data-table.ts
  </files>
  <action>
Integrate VirtualizerController following the pattern from Select component:

1. **Add imports**:
```typescript
import { VirtualizerController } from '@tanstack/lit-virtual';
import { Ref, createRef, ref } from 'lit/directives/ref.js';
```

2. **Add instance properties**:
```typescript
/** Reference to the scroll container for virtualization */
private scrollRef: Ref<HTMLDivElement> = createRef();

/** VirtualizerController manages which rows are visible */
private virtualizer?: VirtualizerController<HTMLDivElement, Element>;

/** Fixed row height for consistent virtualization */
private static readonly ROW_HEIGHT = 48;

/** Number of rows to render outside viewport */
private static readonly OVERSCAN = 5;
```

3. **Initialize virtualizer when data changes**:
In `updated()` lifecycle method:
```typescript
protected override updated(changedProperties: PropertyValues): void {
  if (changedProperties.has('data')) {
    this.initVirtualizer();
  }
}

private initVirtualizer(): void {
  if (isServer || this.data.length === 0) return;

  // Always recreate to handle count changes correctly
  this.virtualizer = new VirtualizerController(this, {
    getScrollElement: () => this.scrollRef.value ?? null,
    count: this.data.length,
    estimateSize: () => this.rowHeight || DataTable.ROW_HEIGHT,
    overscan: DataTable.OVERSCAN,
  });
}
```

4. **Update render to use virtual rows**:
Replace direct row rendering with virtual row rendering:

```typescript
private renderVirtualRows(table: Table<TData>) {
  if (!this.virtualizer) {
    // Fallback to non-virtual rendering for small datasets
    return this.renderAllRows(table);
  }

  const virtualizer = this.virtualizer.getVirtualizer();
  const virtualItems = virtualizer.getVirtualItems();
  const totalHeight = virtualizer.getTotalSize();
  const rows = table.getRowModel().rows;

  return html`
    <div
      class="data-table-body"
      role="rowgroup"
      ${ref(this.scrollRef)}
      style="height: 400px; overflow-y: auto;"
    >
      <div style="height: ${totalHeight}px; position: relative;">
        ${virtualItems.map(virtualRow => {
          const row = rows[virtualRow.index];
          return html`
            <div
              class="data-table-row"
              role="row"
              aria-rowindex="${virtualRow.index + 2}"
              style="
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: ${virtualRow.size}px;
                transform: translateY(${virtualRow.start}px);
              "
            >
              ${row.getVisibleCells().map((cell, colIndex) => html`
                <div
                  class="data-table-cell"
                  role="gridcell"
                  aria-colindex="${colIndex + 1}"
                >
                  ${flexRender(cell.column.columnDef.cell, cell.getContext())}
                </div>
              `)}
            </div>
          `;
        })}
      </div>
    </div>
  `;
}
```

5. **Add cleanup in disconnectedCallback**:
```typescript
override disconnectedCallback(): void {
  super.disconnectedCallback();
  this.virtualizer = undefined;
}
```

6. **Handle scroll position preservation**:
The VirtualizerController maintains scroll position automatically when data updates as long as you maintain the same instance. The key is updating count via setOptions rather than recreating:

```typescript
private updateVirtualizerCount(): void {
  if (!this.virtualizer) {
    this.initVirtualizer();
    return;
  }
  // Update count preserves scroll position
  // VirtualizerController handles this internally
}
```
  </action>
  <verify>
    pnpm --filter @lit-ui/data-table build succeeds
    No TypeScript errors
    VirtualizerController imported and used
  </verify>
  <done>
    VirtualizerController integrated with DataTable
    Virtual rows rendered with absolute positioning
    Scroll position preserved on data updates
  </done>
</task>

<task type="auto">
  <name>Task 2: Update scroll container and header layout</name>
  <files>
    packages/data-table/src/data-table.ts
  </files>
  <action>
Update CSS and layout for proper header/body scroll architecture:

1. **Update container structure**:
- Header in sticky position above scroll container
- Body is the scroll container with virtualized rows

```typescript
override render() {
  const table = this.tableController.table({
    columns: this.columns,
    data: this.data,
    getCoreRowModel: getCoreRowModel(),
  });

  const gridTemplateColumns = this.getGridTemplateColumns(table);

  return html`
    <div
      class="data-table-container"
      role="grid"
      aria-rowcount="${this.data.length + 1}"
      aria-colcount="${this.columns.length}"
      aria-label="${this.ariaLabel || 'Data table'}"
      aria-busy="${this.loading !== 'idle'}"
      style="--grid-template-columns: ${gridTemplateColumns};"
    >
      ${this.renderHeader(table)}
      ${this.renderBody(table)}
    </div>
  `;
}
```

2. **CSS updates for scroll architecture**:
```css
.data-table-container {
  display: flex;
  flex-direction: column;
  max-height: var(--ui-data-table-max-height, 600px);
}

.data-table-header {
  flex-shrink: 0;
  position: sticky;
  top: 0;
  z-index: 10;
}

.data-table-body {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
}

.data-table-row {
  display: grid;
  grid-template-columns: var(--grid-template-columns);
}
```

3. **Add maxHeight property**:
```typescript
/**
 * Maximum height of the table container. Body scrolls when content exceeds this.
 * @default '600px'
 */
@property({ type: String })
maxHeight = '600px';
```

4. **Grid template columns calculation**:
```typescript
private getGridTemplateColumns(table: Table<TData>): string {
  return table.getAllColumns()
    .map(col => col.getSize() ? `${col.getSize()}px` : '1fr')
    .join(' ');
}
```

5. **Ensure header and body columns align**:
Both header row and body rows use the same CSS variable `--grid-template-columns` for alignment.
  </action>
  <verify>
    pnpm --filter @lit-ui/data-table build succeeds
    Header stays fixed during body scroll
    Columns align between header and body
  </verify>
  <done>
    Header is sticky during vertical scroll
    Body scrolls independently with virtualization
    Column widths consistent between header and body
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @lit-ui/data-table build` succeeds
2. TypeScript compiles without errors
3. VirtualizerController is imported and used
4. Virtual rows use absolute positioning with transform
5. Header remains visible while body scrolls
6. Grid columns align between header and body
</verification>

<success_criteria>
- VIRT-01: Virtual scrolling renders only visible rows plus buffer (check DOM node count)
- VIRT-02: Smooth scrolling (no jank) - qualitative, will verify in later integration testing
- VIRT-03: Fixed row heights (48px default, configurable via rowHeight property)
- VIRT-04: Scroll position preserved during data updates
- CORE-02: Header row is fixed/sticky during vertical scroll
</success_criteria>

<output>
After completion, create `.planning/phases/61-core-table-shell-virtualization/61-03-SUMMARY.md`
</output>
