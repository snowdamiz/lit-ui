---
phase: 61-core-table-shell-virtualization
plan: 05
type: execute
wave: 4
depends_on: ["61-03"]
files_modified:
  - packages/data-table/src/data-table.ts
  - packages/data-table/src/keyboard-navigation.ts
autonomous: true

must_haves:
  truths:
    - "User can navigate between cells using arrow keys"
    - "User presses Home to go to first cell in row, End to go to last cell"
    - "User presses Ctrl+Home/End to go to first/last cell in table"
    - "User presses Tab to move between interactive elements within cells or exit grid"
    - "Screen reader announces correct row/column position via ARIA"
  artifacts:
    - path: "packages/data-table/src/data-table.ts"
      provides: "Keyboard event handling"
      contains: "handleKeyDown"
    - path: "packages/data-table/src/keyboard-navigation.ts"
      provides: "Keyboard navigation utility class"
      exports: ["KeyboardNavigationManager"]
  key_links:
    - from: "packages/data-table/src/data-table.ts"
      to: "packages/data-table/src/keyboard-navigation.ts"
      via: "import KeyboardNavigationManager"
      pattern: "KeyboardNavigationManager"
    - from: "packages/data-table/src/data-table.ts"
      to: "focus management"
      via: "roving tabindex pattern"
      pattern: "tabindex"
---

<objective>
Implement ARIA grid keyboard navigation for DataTable following W3C APG patterns.

Purpose: Enable full keyboard accessibility for the data table, allowing users to navigate cells with arrow keys, use Home/End for row navigation, and Tab to move between interactive elements. This satisfies WCAG keyboard accessibility requirements.

Output:
- Full arrow key navigation between cells
- Home/End navigation within rows
- Ctrl+Home/Ctrl+End for table boundaries
- PageUp/PageDown for viewport jumping
- Tab navigation for interactive cell content
- Roving tabindex focus management
- ARIA live region for announcements
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/61-core-table-shell-virtualization/61-RESEARCH.md
@.planning/phases/61-core-table-shell-virtualization/61-03-SUMMARY.md
@packages/tabs/src/tabs.ts (handleKeyDown pattern)
@packages/calendar/src/keyboard-navigation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KeyboardNavigationManager utility</name>
  <files>
    packages/data-table/src/keyboard-navigation.ts
  </files>
  <action>
Create a reusable keyboard navigation manager for grid navigation:

```typescript
/**
 * Keyboard navigation manager for ARIA grid pattern.
 * Handles arrow keys, Home/End, PageUp/PageDown per W3C APG.
 */
export interface GridPosition {
  row: number;
  col: number;
}

export interface GridBounds {
  rowCount: number;
  colCount: number;
  /** Number of visible rows for PageUp/PageDown */
  visibleRowCount: number;
}

export class KeyboardNavigationManager {
  private position: GridPosition = { row: 0, col: 0 };
  private bounds: GridBounds = { rowCount: 0, colCount: 0, visibleRowCount: 10 };

  /**
   * Update grid bounds when data or columns change.
   */
  setBounds(bounds: GridBounds): void {
    this.bounds = bounds;
    // Clamp position to new bounds
    this.position.row = Math.min(this.position.row, Math.max(0, bounds.rowCount - 1));
    this.position.col = Math.min(this.position.col, Math.max(0, bounds.colCount - 1));
  }

  /**
   * Get current focused position.
   */
  getPosition(): GridPosition {
    return { ...this.position };
  }

  /**
   * Set position directly (e.g., from click).
   */
  setPosition(pos: GridPosition): void {
    this.position = {
      row: Math.max(0, Math.min(pos.row, this.bounds.rowCount - 1)),
      col: Math.max(0, Math.min(pos.col, this.bounds.colCount - 1)),
    };
  }

  /**
   * Handle keyboard event and return new position if changed.
   * Returns null if key not handled.
   */
  handleKeyDown(e: KeyboardEvent): GridPosition | null {
    const { key, ctrlKey, metaKey } = e;
    const ctrl = ctrlKey || metaKey;
    let newPos: GridPosition | null = null;

    switch (key) {
      case 'ArrowRight':
        newPos = this.moveCol(1);
        break;
      case 'ArrowLeft':
        newPos = this.moveCol(-1);
        break;
      case 'ArrowDown':
        newPos = this.moveRow(1);
        break;
      case 'ArrowUp':
        newPos = this.moveRow(-1);
        break;
      case 'Home':
        newPos = ctrl ? this.moveToStart() : this.moveToRowStart();
        break;
      case 'End':
        newPos = ctrl ? this.moveToEnd() : this.moveToRowEnd();
        break;
      case 'PageDown':
        newPos = this.moveRow(this.bounds.visibleRowCount);
        break;
      case 'PageUp':
        newPos = this.moveRow(-this.bounds.visibleRowCount);
        break;
      default:
        return null;
    }

    if (newPos) {
      this.position = newPos;
    }
    return newPos;
  }

  private moveCol(delta: number): GridPosition {
    const newCol = Math.max(0, Math.min(this.position.col + delta, this.bounds.colCount - 1));
    return { row: this.position.row, col: newCol };
  }

  private moveRow(delta: number): GridPosition {
    const newRow = Math.max(0, Math.min(this.position.row + delta, this.bounds.rowCount - 1));
    return { row: newRow, col: this.position.col };
  }

  private moveToRowStart(): GridPosition {
    return { row: this.position.row, col: 0 };
  }

  private moveToRowEnd(): GridPosition {
    return { row: this.position.row, col: this.bounds.colCount - 1 };
  }

  private moveToStart(): GridPosition {
    return { row: 0, col: 0 };
  }

  private moveToEnd(): GridPosition {
    return { row: this.bounds.rowCount - 1, col: this.bounds.colCount - 1 };
  }
}
```

Export from index.ts:
```typescript
export { KeyboardNavigationManager, type GridPosition, type GridBounds } from './keyboard-navigation.js';
```
  </action>
  <verify>
    pnpm --filter @lit-ui/data-table build succeeds
    keyboard-navigation.ts compiles without errors
  </verify>
  <done>
    KeyboardNavigationManager class created
    Handles all grid navigation keys per W3C APG
    Exported from package index
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate keyboard navigation into DataTable</name>
  <files>
    packages/data-table/src/data-table.ts
  </files>
  <action>
Integrate KeyboardNavigationManager and implement focus management:

1. **Add imports and state**:
```typescript
import { KeyboardNavigationManager, type GridPosition } from './keyboard-navigation.js';

// In class:
/** Keyboard navigation manager */
private navManager = new KeyboardNavigationManager();

/** Current focused cell position */
@state()
private _focusedCell: GridPosition = { row: 0, col: 0 };
```

2. **Update bounds when data/columns change**:
```typescript
protected override updated(changedProperties: PropertyValues): void {
  super.updated(changedProperties);

  if (changedProperties.has('data') || changedProperties.has('columns')) {
    const visibleRowCount = Math.floor(400 / (this.rowHeight || 48)); // Approximate
    this.navManager.setBounds({
      rowCount: this.data.length,
      colCount: this.columns.length,
      visibleRowCount,
    });
  }
}
```

3. **Add keydown handler**:
```typescript
private handleKeyDown(e: KeyboardEvent): void {
  // Don't handle if target is interactive element within cell
  const target = e.target as HTMLElement;
  if (this.isInteractiveElement(target)) {
    return;
  }

  const newPos = this.navManager.handleKeyDown(e);
  if (newPos) {
    e.preventDefault();
    this._focusedCell = newPos;
    this.focusCell(newPos);

    // Scroll virtualized row into view
    if (this.virtualizer) {
      this.virtualizer.getVirtualizer().scrollToIndex(newPos.row, {
        align: 'auto',
        behavior: 'auto',
      });
    }
  }
}

private isInteractiveElement(el: HTMLElement): boolean {
  const interactiveTags = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA', 'A'];
  return interactiveTags.includes(el.tagName) || el.hasAttribute('contenteditable');
}
```

4. **Implement focus management**:
```typescript
private focusCell(pos: GridPosition): void {
  // Account for header row in aria-rowindex
  const ariaRow = pos.row + 2; // +1 for 1-indexed, +1 for header
  const ariaCol = pos.col + 1; // 1-indexed

  // Find cell by ARIA attributes
  const cell = this.shadowRoot?.querySelector(
    `[aria-rowindex="${ariaRow}"][aria-colindex="${ariaCol}"], ` +
    `[role="row"][aria-rowindex="${ariaRow}"] [aria-colindex="${ariaCol}"]`
  ) as HTMLElement | null;

  if (cell) {
    // Make this cell tabbable, others not
    this.updateRovingTabindex(pos);
    cell.focus();
  }
}

private updateRovingTabindex(activePos: GridPosition): void {
  // Remove tabindex from all cells
  const allCells = this.shadowRoot?.querySelectorAll('[role="gridcell"], [role="columnheader"]');
  allCells?.forEach(cell => cell.setAttribute('tabindex', '-1'));

  // Set tabindex=0 on active cell
  const ariaRow = activePos.row + 2;
  const ariaCol = activePos.col + 1;
  const activeCell = this.shadowRoot?.querySelector(
    `[role="row"][aria-rowindex="${ariaRow}"] [aria-colindex="${ariaCol}"]`
  );
  activeCell?.setAttribute('tabindex', '0');
}
```

5. **Handle cell click to update focus position**:
```typescript
private handleCellClick(rowIndex: number, colIndex: number): void {
  this._focusedCell = { row: rowIndex, col: colIndex };
  this.navManager.setPosition(this._focusedCell);
  this.updateRovingTabindex(this._focusedCell);
}
```

6. **Update cell rendering with tabindex and click handler**:
```typescript
// In cell render:
<div
  class="data-table-cell"
  role="gridcell"
  aria-colindex="${colIndex + 1}"
  tabindex="${this._focusedCell.row === rowIndex && this._focusedCell.col === colIndex ? '0' : '-1'}"
  @click=${() => this.handleCellClick(rowIndex, colIndex)}
  @keydown=${this.handleKeyDown}
>
```

7. **Add keydown to container**:
```typescript
// In container render:
<div
  class="data-table-container"
  role="grid"
  @keydown=${this.handleKeyDown}
>
```
  </action>
  <verify>
    pnpm --filter @lit-ui/data-table build succeeds
    handleKeyDown method exists and handles arrow keys
    Roving tabindex pattern implemented
  </verify>
  <done>
    Arrow keys navigate between cells
    Home/End navigate within rows
    Ctrl+Home/End go to table boundaries
    PageUp/PageDown jump by viewport
    Roving tabindex for focus management
    Click updates focus position
  </done>
</task>

<task type="auto">
  <name>Task 3: Add ARIA live region for announcements</name>
  <files>
    packages/data-table/src/data-table.ts
  </files>
  <action>
Add ARIA live region to announce cell position changes to screen readers:

1. **Add live region to render**:
```typescript
// At end of main render, inside container:
<div
  class="sr-only"
  role="status"
  aria-live="polite"
  aria-atomic="true"
>
  ${this._announcement}
</div>
```

2. **Add announcement state**:
```typescript
@state()
private _announcement = '';
```

3. **Announce on navigation**:
```typescript
private announcePosition(pos: GridPosition): void {
  const colHeader = this.columns[pos.col]?.header;
  const headerText = typeof colHeader === 'function' ? 'Column' : String(colHeader || 'Column');

  this._announcement = `Row ${pos.row + 1} of ${this.data.length}, ${headerText}, Column ${pos.col + 1} of ${this.columns.length}`;
}

// Update handleKeyDown to announce:
private handleKeyDown(e: KeyboardEvent): void {
  // ... existing code ...

  if (newPos) {
    e.preventDefault();
    this._focusedCell = newPos;
    this.focusCell(newPos);
    this.announcePosition(newPos);
    // ... scroll code ...
  }
}
```

4. **Add sr-only CSS**:
```css
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
```

5. **Update ARIA attributes on grid**:
Ensure these are present:
- `role="grid"` on container
- `aria-rowcount` = total rows + 1 (for header)
- `aria-colcount` = column count
- `aria-rowindex` on each row (1-indexed, header = 1, first data row = 2)
- `aria-colindex` on each cell (1-indexed)
  </action>
  <verify>
    pnpm --filter @lit-ui/data-table build succeeds
    aria-live region present in render
    ARIA row/col indices correct
  </verify>
  <done>
    ARIA live region announces cell position
    Screen reader users hear position on navigation
    All ARIA grid attributes correctly applied
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @lit-ui/data-table build` succeeds
2. TypeScript compiles without errors
3. KeyboardNavigationManager handles all grid navigation keys
4. Arrow keys move focus between cells
5. Home/End/Ctrl+Home/Ctrl+End work correctly
6. Roving tabindex pattern implemented
7. ARIA live region announces positions
8. ARIA grid attributes present and correct
</verification>

<success_criteria>
- CORE-07: Table uses role="grid" with proper ARIA attributes
- CORE-08: Arrow key navigation moves between cells
- CORE-09: Tab navigation moves between interactive elements within cells
- Screen reader announces row/column position on navigation
- Focus is visible and managed correctly
</success_criteria>

<output>
After completion, create `.planning/phases/61-core-table-shell-virtualization/61-05-SUMMARY.md`
</output>
