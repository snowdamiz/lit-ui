---
phase: 100-1m-streaming-infrastructure-for-line-area
plan: 02
type: execute
wave: 2
depends_on: [100-01]
files_modified:
  - packages/charts/src/line/line-chart.ts
autonomous: true
requirements: [STRM-01, STRM-02, STRM-03]

must_haves:
  truths:
    - "LuiLineChart.pushData(point, seriesIndex?) routes the point to the correct per-series buffer — the first series is not touched when seriesIndex:1 is passed"
    - "Streaming to LuiLineChart with maxPoints:500000 for 1M+ total points does not crash the tab — the chart disposes and reinitializes transparently when the buffer is full"
    - "LuiLineChart flushes buffers to ECharts via setOption({ series }, { lazyUpdate: true }) once per RAF frame regardless of how many pushData() calls fired that frame"
    - "LuiLineChart cancels its _lineRafId in disconnectedCallback() before calling super.disconnectedCallback()"
  artifacts:
    - path: "packages/charts/src/line/line-chart.ts"
      provides: "Full streaming override: per-series buffers, RAF flush, maxPoints truncation"
      contains: "_lineBuffers"
    - path: "packages/charts/src/line/line-chart.ts"
      provides: "seriesIndex routing in pushData override"
      contains: "seriesIndex = 0"
  key_links:
    - from: "packages/charts/src/line/line-chart.ts (pushData)"
      to: "packages/charts/src/line/line-chart.ts (_flushLineUpdates)"
      via: "requestAnimationFrame callback sets _lineRafId"
      pattern: "_lineRafId.*requestAnimationFrame"
    - from: "packages/charts/src/line/line-chart.ts (_flushLineUpdates)"
      to: "this._chart.setOption"
      via: "setOption with lazyUpdate:true, series array from _lineBuffers"
      pattern: "setOption.*lazyUpdate"
    - from: "packages/charts/src/line/line-chart.ts (_triggerReset)"
      to: "this._initChart()"
      via: "requestAnimationFrame after dispose+buffer-clear"
      pattern: "_initChart\\(\\)"
---

<objective>
Override pushData() in LuiLineChart to implement per-series ring buffer streaming with RAF coalescing, maxPoints-triggered dispose+reinit truncation, and seriesIndex routing.

Purpose: The current LuiLineChart uses the base class appendData path which accumulates unboundedly. ECharts has no removeData — long streaming sessions will crash the tab. This plan replaces the appendData path with a ring-buffer + setOption(lazyUpdate:true) pattern (identical to LuiCandlestickChart's proven approach), adds optional seriesIndex routing to pushData(), and adds maxPoints-triggered dispose+reinit truncation.

Output: Modified line-chart.ts with _lineBuffers, _lineRafId, _totalPoints fields; pushData(point, seriesIndex=0) override; _flushLineUpdates(); _triggerReset(); disconnectedCallback() RAF cancel.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/100-1m-streaming-infrastructure-for-line-area/100-RESEARCH.md
@.planning/phases/100-1m-streaming-infrastructure-for-line-area/100-01-SUMMARY.md

<interfaces>
<!-- Key contracts the executor needs. Extracted from codebase — do not re-explore. -->

From packages/charts/src/base/base-chart-element.ts (after Plan 01):
```typescript
export abstract class BaseChartElement extends TailwindElement {
  @property({ type: Number }) maxPoints = 1000;
  protected _chart: EChartsType | null = null;
  protected _streamingMode: 'appendData' | 'buffer' = 'buffer';

  // Plan 01 changed this from private to protected:
  protected async _initChart(): Promise<void>;

  // Base pushData — will be fully overridden (do NOT call super.pushData()):
  pushData(point: unknown): void;

  // Must call super.disconnectedCallback() AFTER cancelling own RAF:
  override disconnectedCallback(): void;
}
```

From packages/charts/src/candlestick/candlestick-chart.ts (proven override pattern to follow exactly):
```typescript
// Component's own RAF handle — cancel in disconnectedCallback() before super.disconnectedCallback()
private _barRafId?: number;

override pushData(point: unknown): void {
  // push to buffer, schedule RAF, return (never call super.pushData())
}

private _flushBarUpdates(): void {
  if (!this._chart || ...) return;
  this._chart.setOption(option, { lazyUpdate: true } as object);
}

override disconnectedCallback(): void {
  if (this._barRafId !== undefined) {
    cancelAnimationFrame(this._barRafId);
    this._barRafId = undefined;
  }
  super.disconnectedCallback();
}
```

From packages/charts/src/line/line-chart.ts (current state — what to change):
```typescript
export class LuiLineChart extends BaseChartElement {
  constructor() {
    super();
    // REMOVE THIS LINE — appendData mode is being replaced entirely:
    this._streamingMode = 'appendData';
  }
  // ... existing props: smooth, zoom, markLines ...
  // _applyData() calls buildLineOption() and this._chart.setOption() — KEEP AS IS
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add streaming fields and override pushData() with seriesIndex routing</name>
  <files>packages/charts/src/line/line-chart.ts</files>
  <action>
Make the following changes to line-chart.ts. All existing code (imports, properties, _registerModules, updated, _applyData) stays unchanged except the constructor.

**1. Remove the appendData constructor:**
Remove the entire constructor block:
```typescript
constructor() {
  super();
  this._streamingMode = 'appendData';
}
```
LuiLineChart will no longer use _streamingMode at all — pushData() is fully overridden.

**2. Add private streaming fields** after the existing `@property` declarations:
```typescript
// STRM-01 + STRM-03: Per-series ring buffers — index matches ECharts series index.
// Each element holds all accumulated points for one series.
private _lineBuffers: unknown[][] = [[]];

// STRM-02: Total points pushed across all series — triggers reset at maxPoints.
private _totalPoints = 0;

// Component's own RAF handle — must be cancelled in disconnectedCallback().
// Base class cancels its own _rafId but has no knowledge of _lineRafId.
private _lineRafId?: number;
```

**3. Override maxPoints default** — add immediately after the private fields:
```typescript
// STRM-02: Line/Area charts stream 1M+ points; base default of 1000 is for buffer-mode charts.
// Override to 500_000 — allows ~8 minutes of streaming at 1000 pts/sec before reset.
override maxPoints = 500_000;
```

**4. Add pushData override** — add after the maxPoints override (before updated()):
```typescript
/**
 * STRM-01 + STRM-02 + STRM-03: Ring-buffer streaming with seriesIndex routing.
 *
 * Overrides base pushData() entirely — NEVER call super.pushData().
 * super.pushData() routes to the base _pendingData accumulator which feeds the
 * appendData/buffer path — that path is bypassed entirely in Line/Area charts.
 *
 * Points are accumulated per-series and flushed once per RAF via _flushLineUpdates().
 * When _totalPoints >= maxPoints, the chart disposes and reinitializes (STRM-02).
 */
override pushData(point: unknown, seriesIndex = 0): void {
  // Grow buffer array on demand to accommodate the requested seriesIndex.
  while (this._lineBuffers.length <= seriesIndex) {
    this._lineBuffers.push([]);
  }
  this._lineBuffers[seriesIndex].push(point);
  this._totalPoints++;

  // STRM-02: Truncation — dispose+reinit when total points reach maxPoints.
  if (this._totalPoints >= this.maxPoints) {
    this._triggerReset();
    return;
  }

  // Schedule RAF flush — coalesces multiple pushData() calls in one frame.
  if (this._lineRafId === undefined) {
    this._lineRafId = requestAnimationFrame(() => {
      this._flushLineUpdates();
      this._lineRafId = undefined;
    });
  }
}
```

**5. Add _flushLineUpdates()** — add after pushData():
```typescript
/**
 * RAF flush — passes all buffered points to ECharts via setOption(lazyUpdate:true).
 *
 * _lineBuffers IS the source of truth — the full buffer is passed each flush.
 * ECharts handles the diff internally. lazyUpdate:true batches the render and
 * preserves DataZoom state without triggering a full re-render per call.
 *
 * Only updates series indices that exist in this.data to prevent ECharts from
 * receiving a seriesIndex referencing a series that was never registered.
 */
private _flushLineUpdates(): void {
  if (!this._chart || this._lineBuffers.every((b) => b.length === 0)) return;

  const seriesCount = Array.isArray(this.data) ? (this.data as unknown[]).length : 1;
  const seriesUpdates = this._lineBuffers
    .slice(0, seriesCount)
    .map((buf) => ({ data: buf }));

  this._chart.setOption(
    { series: seriesUpdates },
    { lazyUpdate: true } as object
  );
}
```

**6. Add _triggerReset()** — add after _flushLineUpdates():
```typescript
/**
 * STRM-02: Dispose + reinit when maxPoints is reached.
 *
 * dispose+reinit (not chart.clear()) is the officially recommended full-reset path.
 * chart.clear() leaves residue in ECharts 5.6. dispose() + _initChart() is clean.
 *
 * _initChart() is protected (Plan 01 change) — subclass access is valid.
 * The reinit is async (awaits module registration) — wrap in RAF to avoid blocking.
 */
private _triggerReset(): void {
  // 1. Cancel pending RAF — nothing to flush into a chart that's being disposed.
  if (this._lineRafId !== undefined) {
    cancelAnimationFrame(this._lineRafId);
    this._lineRafId = undefined;
  }
  // 2. Clear all buffers and reset counter — fresh start after reinit.
  this._lineBuffers = this._lineBuffers.map(() => []);
  this._totalPoints = 0;
  // 3. Dispose current ECharts instance.
  //    Set _chart = null immediately — disconnectedCallback() guards on null.
  if (this._chart) {
    this._chart.dispose();
    this._chart = null;
  }
  // 4. Reinit in next frame — _initChart() awaits _registerModules() internally.
  requestAnimationFrame(() => this._initChart());
}
```

**7. Add disconnectedCallback override** — add after _triggerReset():
```typescript
/**
 * Cancel component's own RAF before base class disposes the chart.
 * Base class cancels its own _rafId but has no knowledge of _lineRafId.
 * Failing to cancel causes a setOption call on a disposed chart instance.
 */
override disconnectedCallback(): void {
  if (this._lineRafId !== undefined) {
    cancelAnimationFrame(this._lineRafId);
    this._lineRafId = undefined;
  }
  super.disconnectedCallback();
}
```

**Critical pitfalls to avoid:**
- Do NOT call `super.pushData()` — it adds the point to `_pendingData` which routes through the old appendData/buffer path.
- Do NOT keep `this._streamingMode = 'appendData'` — it is removed with the constructor.
- The `_flushLineUpdates()` slice to `seriesCount` prevents ECharts errors when a pushData(point, 1) arrives before _applyData() has registered a second series.
- `{ lazyUpdate: true } as object` cast is required — ECharts setOption overloads don't expose lazyUpdate in the TypeScript types; the cast is the established pattern from candlestick-chart.ts.
  </action>
  <verify>
    <automated>cd /Users/sn0w/Documents/dev/lit-components && npx tsc -p packages/charts/tsconfig.json --noEmit 2>&1 | tail -10</automated>
  </verify>
  <done>TypeScript compilation exits 0 with no errors. line-chart.ts contains _lineBuffers, _lineRafId, _totalPoints, override pushData(point, seriesIndex=0), _flushLineUpdates(), _triggerReset(), override disconnectedCallback(). The constructor with this._streamingMode='appendData' is gone.</done>
</task>

</tasks>

<verification>
Run TypeScript compilation:
```
cd /Users/sn0w/Documents/dev/lit-components && npx tsc -p packages/charts/tsconfig.json --noEmit
```
Must exit 0.

Grep checks:
```bash
grep -n "_lineBuffers\|_lineRafId\|_totalPoints\|seriesIndex\|_triggerReset\|_flushLineUpdates" \
  /Users/sn0w/Documents/dev/lit-components/packages/charts/src/line/line-chart.ts
grep -n "_streamingMode" /Users/sn0w/Documents/dev/lit-components/packages/charts/src/line/line-chart.ts
# Last grep must return nothing (appendData mode removed)
```
</verification>

<success_criteria>
- `LuiLineChart.pushData(point, seriesIndex=0)` exists and routes to `_lineBuffers[seriesIndex]`
- `_triggerReset()` calls `this._chart.dispose()` then `this._initChart()` in a RAF callback
- `disconnectedCallback()` cancels `_lineRafId` before calling `super.disconnectedCallback()`
- `this._streamingMode = 'appendData'` constructor line is gone
- `override maxPoints = 500_000` is set as class field default
- TypeScript compilation passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/100-1m-streaming-infrastructure-for-line-area/100-02-SUMMARY.md`
</output>
