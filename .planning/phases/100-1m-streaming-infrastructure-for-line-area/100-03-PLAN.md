---
phase: 100-1m-streaming-infrastructure-for-line-area
plan: 03
type: execute
wave: 2
depends_on: [100-01]
files_modified:
  - packages/charts/src/area/area-chart.ts
autonomous: true
requirements: [STRM-01, STRM-02, STRM-03]

must_haves:
  truths:
    - "LuiAreaChart.pushData(point, seriesIndex?) routes the point to the correct per-series buffer — the first series is not touched when seriesIndex:1 is passed"
    - "Streaming to LuiAreaChart with maxPoints:500000 for 1M+ total points does not crash the tab — the chart disposes and reinitializes transparently when the buffer is full"
    - "LuiAreaChart flushes buffers to ECharts via setOption({ series }, { lazyUpdate: true }) once per RAF frame regardless of how many pushData() calls fired that frame"
    - "LuiAreaChart cancels its _lineRafId in disconnectedCallback() before calling super.disconnectedCallback()"
    - "Each series buffer is converted to Float32Array before being passed to setOption — satisfying the STRM-01 TypedArray requirement"
  artifacts:
    - path: "packages/charts/src/area/area-chart.ts"
      provides: "Full streaming override: per-series buffers, RAF flush, maxPoints truncation"
      contains: "_lineBuffers"
    - path: "packages/charts/src/area/area-chart.ts"
      provides: "seriesIndex routing in pushData override"
      contains: "seriesIndex = 0"
  key_links:
    - from: "packages/charts/src/area/area-chart.ts (pushData)"
      to: "packages/charts/src/area/area-chart.ts (_flushLineUpdates)"
      via: "requestAnimationFrame callback sets _lineRafId"
      pattern: "_lineRafId.*requestAnimationFrame"
    - from: "packages/charts/src/area/area-chart.ts (_flushLineUpdates)"
      to: "this._chart.setOption"
      via: "setOption with lazyUpdate:true, Float32Array-converted series data from _lineBuffers"
      pattern: "setOption.*lazyUpdate"
    - from: "packages/charts/src/area/area-chart.ts (_triggerReset)"
      to: "this._initChart()"
      via: "requestAnimationFrame after dispose+buffer-clear"
      pattern: "_initChart\\(\\)"
---

<objective>
Override pushData() in LuiAreaChart to implement per-series ring buffer streaming with RAF coalescing, maxPoints-triggered dispose+reinit truncation, and seriesIndex routing — identical pattern to Plan 02 (LuiLineChart). Each buffer is converted to Float32Array before being handed to ECharts, satisfying STRM-01's TypedArray requirement.

Purpose: LuiAreaChart uses the same ECharts module (registerLineModules) and the same buildLineOption builder as LuiLineChart, and has the same unbounded appendData problem. Both charts require identical streaming infrastructure. This plan applies the same override pattern to area-chart.ts, including the Float32Array conversion in _flushLineUpdates().

Output: Modified area-chart.ts with _lineBuffers, _lineRafId, _totalPoints fields; pushData(point, seriesIndex=0) override; _flushLineUpdates() with Float32Array conversion; _triggerReset(); disconnectedCallback() RAF cancel.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/100-1m-streaming-infrastructure-for-line-area/100-RESEARCH.md
@.planning/phases/100-1m-streaming-infrastructure-for-line-area/100-01-SUMMARY.md

<interfaces>
<!-- Key contracts the executor needs. Extracted from codebase — do not re-explore. -->

From packages/charts/src/base/base-chart-element.ts (after Plan 01):
```typescript
export abstract class BaseChartElement extends TailwindElement {
  @property({ type: Number }) maxPoints = 1000;
  protected _chart: EChartsType | null = null;
  protected _streamingMode: 'appendData' | 'buffer' = 'buffer';

  // Plan 01 changed this from private to protected:
  protected async _initChart(): Promise<void>;

  // Base pushData — will be fully overridden (do NOT call super.pushData()):
  pushData(point: unknown): void;

  // Must call super.disconnectedCallback() AFTER cancelling own RAF:
  override disconnectedCallback(): void;
}
```

From packages/charts/src/area/area-chart.ts (current state — what to change):
```typescript
export class LuiAreaChart extends BaseChartElement {
  constructor() {
    super();
    // REMOVE THIS LINE — appendData mode is being replaced entirely:
    this._streamingMode = 'appendData';
  }
  // Existing props to KEEP: smooth, stacked, zoom, labelPosition
  // _registerModules(), updated(), _applyData() — KEEP AS IS
}
```

The implementation is IDENTICAL to what Plan 02 adds to LuiLineChart, including the Float32Array
conversion in _flushLineUpdates(). Reference the completed 100-02-SUMMARY.md for the exact code shape.
The field names (_lineBuffers, _lineRafId, _totalPoints), method names
(_flushLineUpdates, _triggerReset), and override signatures (pushData, disconnectedCallback)
are identical. The only difference is the file being modified (area-chart.ts vs line-chart.ts).
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add streaming fields and override pushData() in LuiAreaChart</name>
  <files>packages/charts/src/area/area-chart.ts</files>
  <action>
Apply the identical streaming override to area-chart.ts that Plan 02 applied to line-chart.ts. All existing code (imports, properties, _registerModules, updated, _applyData) stays unchanged except the constructor.

**1. Remove the appendData constructor:**
Remove the entire constructor block:
```typescript
constructor() {
  super();
  this._streamingMode = 'appendData';
}
```

**2. Add private streaming fields** after the existing `@property` declarations:
```typescript
// STRM-01 + STRM-03: Per-series accumulation buffers — index matches ECharts series index.
// Each element holds all accumulated points for one series as plain JS arrays.
// Points are converted to Float32Array at flush time (STRM-01 TypedArray requirement).
private _lineBuffers: unknown[][] = [[]];

// STRM-02: Total points pushed across all series — triggers reset at maxPoints.
private _totalPoints = 0;

// Component's own RAF handle — must be cancelled in disconnectedCallback().
private _lineRafId?: number;
```

**3. Override maxPoints default:**
```typescript
// STRM-02: Area charts stream 1M+ points; base default of 1000 is for buffer-mode charts.
override maxPoints = 500_000;
```

**4. Add pushData override:**
```typescript
/**
 * STRM-01 + STRM-02 + STRM-03: Ring-buffer streaming with seriesIndex routing.
 *
 * Overrides base pushData() entirely — NEVER call super.pushData().
 */
override pushData(point: unknown, seriesIndex = 0): void {
  while (this._lineBuffers.length <= seriesIndex) {
    this._lineBuffers.push([]);
  }
  this._lineBuffers[seriesIndex].push(point);
  this._totalPoints++;

  if (this._totalPoints >= this.maxPoints) {
    this._triggerReset();
    return;
  }

  if (this._lineRafId === undefined) {
    this._lineRafId = requestAnimationFrame(() => {
      this._flushLineUpdates();
      this._lineRafId = undefined;
    });
  }
}
```

**5. Add _flushLineUpdates():**
```typescript
/**
 * RAF flush — passes all buffered points to ECharts via setOption(lazyUpdate:true).
 *
 * STRM-01: Each series buffer is converted to Float32Array before being passed to
 * setOption. This satisfies the TypedArray ring-buffer requirement literally:
 * ECharts receives Float32Array data, not plain JS arrays.
 *
 * Only updates series indices that exist in this.data to prevent ECharts errors.
 */
private _flushLineUpdates(): void {
  if (!this._chart || this._lineBuffers.every((b) => b.length === 0)) return;

  const seriesCount = Array.isArray(this.data) ? (this.data as unknown[]).length : 1;
  const seriesUpdates = this._lineBuffers
    .slice(0, seriesCount)
    .map((buf) => ({ data: new Float32Array(buf as number[]) }));

  this._chart.setOption(
    { series: seriesUpdates },
    { lazyUpdate: true } as object
  );
}
```

**6. Add _triggerReset():**
```typescript
/**
 * STRM-02: Dispose + reinit when maxPoints is reached.
 * _initChart() is protected (Plan 01 change) — subclass access is valid.
 */
private _triggerReset(): void {
  if (this._lineRafId !== undefined) {
    cancelAnimationFrame(this._lineRafId);
    this._lineRafId = undefined;
  }
  this._lineBuffers = this._lineBuffers.map(() => []);
  this._totalPoints = 0;
  if (this._chart) {
    this._chart.dispose();
    this._chart = null;
  }
  requestAnimationFrame(() => this._initChart());
}
```

**7. Add disconnectedCallback override:**
```typescript
/**
 * Cancel component's own RAF before base class disposes the chart.
 */
override disconnectedCallback(): void {
  if (this._lineRafId !== undefined) {
    cancelAnimationFrame(this._lineRafId);
    this._lineRafId = undefined;
  }
  super.disconnectedCallback();
}
```

**Critical pitfalls to avoid:**
- Do NOT call `super.pushData()` — same reason as line-chart.ts.
- Do NOT keep `this._streamingMode = 'appendData'` — remove with the constructor.
- `{ lazyUpdate: true } as object` cast is required (same TypeScript quirk as candlestick-chart.ts and line-chart.ts).
- The `_flushLineUpdates()` slice to `seriesCount` prevents ECharts errors on out-of-range series indices.
- The `new Float32Array(buf as number[])` conversion assumes numeric point values. If points are [x, y] tuples (2-element arrays), use `Float32Array.from((buf as number[][]).flat())` instead — check what _applyData() / buildLineOption() expects for the series data shape.
  </action>
  <verify>
    <automated>cd /Users/sn0w/Documents/dev/lit-components && npx tsc -p packages/charts/tsconfig.json --noEmit 2>&1 | tail -10</automated>
  </verify>
  <done>TypeScript compilation exits 0 with no errors. area-chart.ts contains _lineBuffers, _lineRafId, _totalPoints, override pushData(point, seriesIndex=0), _flushLineUpdates() with Float32Array conversion (new Float32Array(...)), _triggerReset(), override disconnectedCallback(). The constructor with this._streamingMode='appendData' is gone.</done>
</task>

</tasks>

<verification>
Run TypeScript compilation:
```
cd /Users/sn0w/Documents/dev/lit-components && npx tsc -p packages/charts/tsconfig.json --noEmit
```
Must exit 0.

Grep checks:
```bash
grep -n "_lineBuffers\|_lineRafId\|_totalPoints\|seriesIndex\|_triggerReset\|_flushLineUpdates\|Float32Array" \
  /Users/sn0w/Documents/dev/lit-components/packages/charts/src/area/area-chart.ts
grep -n "_streamingMode" /Users/sn0w/Documents/dev/lit-components/packages/charts/src/area/area-chart.ts
# Last grep must return nothing (appendData mode removed)
```
</verification>

<success_criteria>
- `LuiAreaChart.pushData(point, seriesIndex=0)` exists and routes to `_lineBuffers[seriesIndex]`
- `_flushLineUpdates()` converts each buffer to `Float32Array` before passing to `setOption` (STRM-01 TypedArray requirement satisfied)
- `_triggerReset()` calls `this._chart.dispose()` then `this._initChart()` in a RAF callback
- `disconnectedCallback()` cancels `_lineRafId` before calling `super.disconnectedCallback()`
- `this._streamingMode = 'appendData'` constructor line is gone
- `override maxPoints = 500_000` is set as class field default
- TypeScript compilation passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/100-1m-streaming-infrastructure-for-line-area/100-03-SUMMARY.md`
</output>
