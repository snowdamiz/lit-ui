---
phase: 04-cli
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - packages/cli/src/registry/registry.json
  - packages/cli/src/utils/registry.ts
autonomous: true

must_haves:
  truths:
    - "Registry JSON lists button and dialog components with their files"
    - "Registry utility can resolve component dependencies recursively"
    - "Base class files are defined in registry for init command"
  artifacts:
    - path: "packages/cli/src/registry/registry.json"
      provides: "Component metadata"
      contains: '"button"'
    - path: "packages/cli/src/utils/registry.ts"
      provides: "Registry operations"
      exports: ["getRegistry", "getComponent", "resolveDependencies"]
  key_links:
    - from: "packages/cli/src/utils/registry.ts"
      to: "packages/cli/src/registry/registry.json"
      via: "JSON import"
      pattern: "registry\\.json"
---

<objective>
Create component registry JSON and utilities for component discovery and dependency resolution.

Purpose: Registry is the source of truth for what components exist and how to install them.
Output: Registry JSON with button/dialog metadata, plus utility functions.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-cli/04-RESEARCH.md
@.planning/phases/04-cli/04-01-SUMMARY.md
@src/index.ts
@src/components/button/button.ts
@src/components/dialog/dialog.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create registry JSON</name>
  <files>packages/cli/src/registry/registry.json</files>
  <action>
Create registry.json following shadcn pattern:

```json
{
  "$schema": "./registry-schema.json",
  "name": "lit-ui",
  "base": {
    "files": [
      { "path": "base/tailwind-element.ts", "type": "base" },
      { "path": "styles/tailwind.css", "type": "style" },
      { "path": "styles/host-defaults.css", "type": "style" }
    ],
    "dependencies": ["lit"]
  },
  "components": [
    {
      "name": "button",
      "description": "A customizable button with variants, sizes, loading state, and form participation",
      "files": [
        { "path": "components/button/button.ts", "type": "component" }
      ],
      "dependencies": [],
      "registryDependencies": []
    },
    {
      "name": "dialog",
      "description": "Accessible modal dialog with focus trapping, animations, and nested dialog support",
      "files": [
        { "path": "components/dialog/dialog.ts", "type": "component" }
      ],
      "dependencies": [],
      "registryDependencies": []
    }
  ]
}
```

Note: Dialog does NOT depend on button in registry (though demo uses both). This keeps components independent.
  </action>
  <verify>JSON is valid</verify>
  <done>registry.json contains button and dialog components with correct file paths</done>
</task>

<task type="auto">
  <name>Task 2: Create registry utility</name>
  <files>packages/cli/src/utils/registry.ts</files>
  <action>
Create registry.ts with:

1. Types:
   ```typescript
   interface RegistryFile {
     path: string;
     type: 'component' | 'base' | 'style';
   }

   interface RegistryComponent {
     name: string;
     description: string;
     files: RegistryFile[];
     dependencies: string[];      // npm packages
     registryDependencies: string[];  // other components
   }

   interface Registry {
     name: string;
     base: { files: RegistryFile[]; dependencies: string[] };
     components: RegistryComponent[];
   }
   ```

2. Functions:
   - `getRegistry(): Registry` - import and return registry.json
   - `getComponent(name: string): RegistryComponent | undefined` - find component by name
   - `listComponents(): RegistryComponent[]` - return all components
   - `resolveDependencies(componentName: string): string[]` - recursively resolve registryDependencies
   - `getBaseFiles(): RegistryFile[]` - return base class files
   - `getBaseDependencies(): string[]` - return base npm dependencies

For resolveDependencies, build transitive closure:
- If dialog depends on button, adding dialog should suggest adding button too
- Return array of all component names needed (including the requested one)
  </action>
  <verify>TypeScript compiles</verify>
  <done>Registry utility exports all functions for component discovery</done>
</task>

<task type="auto">
  <name>Task 3: Build and verify registry loads</name>
  <files>packages/cli/tsup.config.ts</files>
  <action>
1. Update tsup.config.ts to handle JSON imports:
   - Ensure JSON files are bundled or copied
   - May need to add loader config for .json

2. Build the CLI: `npm run build`

3. Verify the registry can be loaded:
   - The registry utility should import registry.json correctly
   - Build should succeed without JSON import errors

If needed, use createRequire pattern for JSON import in ESM:
```typescript
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
const registry = require('../registry/registry.json');
```

Or use TypeScript's resolveJsonModule.
  </action>
  <verify>cd packages/cli && npm run build succeeds</verify>
  <done>Registry loads correctly at runtime</done>
</task>

</tasks>

<verification>
- registry.json exists with button and dialog entries
- registry.ts exports getRegistry, getComponent, resolveDependencies
- CLI builds without errors
</verification>

<success_criteria>
Registry system complete with component metadata and utility functions
</success_criteria>

<output>
After completion, create `.planning/phases/04-cli/04-03-SUMMARY.md`
</output>
