---
phase: 36-async-loading
plan: 02
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - packages/select/src/select.ts
autonomous: true

must_haves:
  truths:
    - "Developer can pass Promise<SelectOption[]> to options prop and component shows loading state until resolved"
    - "User sees error state with retry button when async options fail to load"
    - "Clicking retry re-fetches the options"
    - "Selection is cleared when error occurs"
    - "Developer can customize error content via error slot"
  artifacts:
    - path: "packages/select/src/select.ts"
      provides: "Promise-based options with loading/error states"
      contains: "Task"
    - path: "packages/select/src/select.ts"
      provides: "Error state with retry"
      contains: "handleRetry"
  key_links:
    - from: "packages/select/src/select.ts"
      to: "@lit/task"
      via: "Task controller for async state"
      pattern: "new Task\\("
---

<objective>
Implement Promise-based options loading with loading and error states using @lit/task.

Purpose: Enable developers to provide async options (via Promise) and have the Select component handle loading states, error recovery, and retry functionality automatically. This is the foundational async capability (ASYNC-01, ASYNC-02, ASYNC-03).

Output: Select component accepts Promise<SelectOption[]> for options prop, shows skeleton loading during pending state, shows error state with retry on failure.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-async-loading/36-RESEARCH.md
@.planning/phases/36-async-loading/36-01-SUMMARY.md
@packages/select/src/select.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Promise-based options with Task controller</name>
  <files>packages/select/src/select.ts</files>
  <action>
Extend the Select component to accept Promise-based options using @lit/task.

1. Add import for Task:
```typescript
import { Task, TaskStatus } from '@lit/task';
```

2. Update the options property type to accept Promise:
```typescript
/**
 * Array of options to display in the dropdown.
 * Can be a static array OR a Promise that resolves to options.
 * When a Promise is provided, component shows loading state until resolved.
 * @default []
 */
@property({ attribute: false })
options: SelectOption[] | Promise<SelectOption[]> = [];
```

NOTE: Change from `@property({ type: Array })` to `@property({ attribute: false })` because Promise cannot be serialized to/from attribute.

3. Add private state for loaded options from async source:
```typescript
/**
 * Options loaded from async source (Promise).
 * Used internally to track resolved async options.
 */
@state()
private _loadedAsyncOptions: SelectOption[] | null = null;
```

4. Add state to track async loading status:
```typescript
/**
 * Whether async options are currently loading.
 */
@state()
private _asyncLoading = false;

/**
 * Error from async options loading.
 */
@state()
private _asyncError: Error | null = null;
```

5. Add a Task controller for managing async options:
```typescript
/**
 * Task controller for loading async options.
 * Handles Promise-based options with proper state management.
 */
private _optionsTask = new Task(this, {
  task: async ([optionsProp], { signal }) => {
    // Sync array - return immediately
    if (Array.isArray(optionsProp)) {
      this._loadedAsyncOptions = null;
      this._asyncLoading = false;
      this._asyncError = null;
      return optionsProp;
    }

    // Promise - track loading state
    this._asyncLoading = true;
    this._asyncError = null;

    try {
      const resolved = await optionsProp;
      signal.throwIfAborted();
      this._loadedAsyncOptions = resolved;
      this._asyncLoading = false;
      return resolved;
    } catch (err) {
      if ((err as Error).name === 'AbortError') {
        throw err; // Let Task handle abort
      }
      this._asyncLoading = false;
      this._asyncError = err as Error;
      // Clear selection on error (per CONTEXT.md decision)
      if (this.multiple) {
        this.selectedValues.clear();
      } else {
        this._value = '';
      }
      this.updateFormValue();
      throw err;
    }
  },
  args: () => [this.options] as const,
});
```

6. Update the effectiveOptions getter to use loaded async options:
```typescript
/**
 * Get the effective options list.
 * Priority: async loaded options > sync options prop > slotted options.
 * Returns array of objects with value, label, disabled.
 */
private get effectiveOptions(): SelectOption[] {
  // Async loaded options take precedence when available
  if (this._loadedAsyncOptions !== null) {
    return this._loadedAsyncOptions;
  }
  // Sync options property
  if (Array.isArray(this.options) && this.options.length > 0) {
    return this.options;
  }
  // Slotted options fallback
  return this.slottedOptions.map((opt) => ({
    value: opt.value,
    label: opt.getLabel(),
    disabled: opt.disabled,
  }));
}
```

7. Add helper to check if in async mode:
```typescript
/**
 * Check if component is in async options mode.
 */
private get _isAsyncMode(): boolean {
  return this.options instanceof Promise || this._loadedAsyncOptions !== null;
}
```
  </action>
  <verify>
Build with `pnpm --filter @lit-ui/select build` to verify Task import and controller setup compiles correctly.
  </verify>
  <done>
Task controller created for async options. Options prop accepts Promise. Loading/error states tracked. effectiveOptions updated to use async loaded options.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement error state with retry functionality</name>
  <files>packages/select/src/select.ts</files>
  <action>
Add error state rendering with retry button and error slot for customization.

1. Add CSS for error state styling (in static styles):
```css
/* Error state styling */
.error-state {
  padding: var(--ui-select-option-padding-y, 0.5rem)
    var(--ui-select-option-padding-x, 0.75rem);
  text-align: center;
}

.error-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  color: var(--ui-select-text-error, var(--color-destructive));
}

.error-message {
  font-size: 0.875em;
}

.retry-link {
  color: var(--color-primary);
  background: none;
  border: none;
  cursor: pointer;
  font-size: 0.875em;
  text-decoration: underline;
  padding: 0;
}

.retry-link:hover {
  text-decoration: none;
}

.retry-link:focus-visible {
  outline: 2px solid var(--ui-select-ring);
  outline-offset: 2px;
  border-radius: var(--radius-sm, 0.25rem);
}
```

2. Add retry handler method:
```typescript
/**
 * Handle retry button click to re-fetch async options.
 */
private handleRetry(): void {
  this._asyncError = null;
  this._asyncLoading = true;
  this._optionsTask.run();
}
```

3. Add error state rendering method:
```typescript
/**
 * Render error state with retry action.
 * Supports error slot for full customization.
 */
private renderErrorState() {
  return html`
    <div class="error-state" role="alert">
      <slot name="error">
        <div class="error-content">
          <span class="error-message">Failed to load options</span>
          <button
            type="button"
            class="retry-link"
            @click=${this.handleRetry}
          >
            Try again
          </button>
        </div>
      </slot>
    </div>
  `;
}
```

4. Update the render method to handle async states. Find the listbox rendering section and modify to conditionally render loading/error/options:

In the render() method, update the listbox content rendering to check async states:

```typescript
<!-- Dropdown listbox -->
<div
  id=${listboxId}
  class="listbox"
  role="listbox"
  aria-labelledby=${this.selectId}
  aria-multiselectable=${this.multiple ? 'true' : nothing}
  ?hidden=${!this.open}
>
  ${this.renderSelectAllActions()}
  ${this._asyncLoading
    ? this.renderSkeletonOptions(4)
    : this._asyncError
      ? this.renderErrorState()
      : optionsToRender.length > 0
        ? optionsToRender.map((filterMatch, index) =>
            this.renderOption(filterMatch, index)
          )
        : this.searchable && this.filterQuery
          ? this.renderEmptyState()
          : nothing}
  <!-- Always render slot to keep it in DOM, hide when rendering programmatic options -->
  <div style=${optionsToRender.length > 0 || (this.searchable && this.filterQuery) || this._asyncLoading || this._asyncError ? 'display:none' : ''}>
    <slot @slotchange=${this.handleSlotChange}></slot>
  </div>
  ${this.renderCreateOption()}
</div>
```

NOTE: The key changes are:
- Check `this._asyncLoading` first, render skeletons
- Check `this._asyncError` next, render error state
- Otherwise render options normally
- Update the slot visibility condition to include async states
  </action>
  <verify>
Build with `pnpm --filter @lit-ui/select build`. Test manually by creating a demo page with:
```html
<lui-select id="async-demo"></lui-select>
<script>
  const select = document.querySelector('#async-demo');
  // Test loading state
  select.options = new Promise(resolve => setTimeout(() => resolve([
    {value: '1', label: 'Option 1'},
    {value: '2', label: 'Option 2'}
  ]), 2000));
</script>
```
  </verify>
  <done>
Error state renders with "Failed to load options" message and "Try again" link. Error slot available for customization. Retry button triggers re-fetch. Selection cleared on error.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @lit-ui/select build` succeeds
2. Options prop accepts Promise<SelectOption[]>
3. Loading state shows skeleton placeholders
4. Error state shows message with retry link
5. Error slot allows customization
6. Retry button re-fetches options
7. Selection cleared when error occurs
</verification>

<success_criteria>
- Task controller properly manages async options lifecycle
- Loading state displays 4 skeleton placeholders
- Error state displays error message with retry link
- Error slot enables full customization of error content
- handleRetry method re-runs the task
- Selection is cleared on async error
- Package builds without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/36-async-loading/36-02-SUMMARY.md`
</output>
