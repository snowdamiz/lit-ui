---
phase: 36-async-loading
plan: 03
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - packages/select/src/select.ts
autonomous: true

must_haves:
  truths:
    - "User types in async combobox and API is called after debounce period"
    - "Debounce delay is developer configurable via prop"
    - "Minimum character threshold is developer configurable via prop"
    - "Skeleton placeholders shown during async search loading"
    - "Clearing search input re-fetches default options"
    - "Race conditions prevented via AbortController"
  artifacts:
    - path: "packages/select/src/select.ts"
      provides: "Async search with debounce"
      contains: "asyncSearch"
    - path: "packages/select/src/select.ts"
      provides: "Debounce configuration"
      contains: "debounceDelay"
    - path: "packages/select/src/select.ts"
      provides: "Minimum search length"
      contains: "minSearchLength"
  key_links:
    - from: "packages/select/src/select.ts"
      to: "AbortController"
      via: "async search cancellation"
      pattern: "_searchAbortController"
---

<objective>
Implement async search functionality with configurable debounce delay and minimum character threshold.

Purpose: Enable combobox/searchable select to fetch options from an API as the user types, with proper debouncing to prevent excessive API calls and AbortController to prevent race conditions (ASYNC-04).

Output: Select component supports asyncSearch function prop that is called with debounced search queries, shows skeleton loading during search, and properly handles cancellation.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-async-loading/36-RESEARCH.md
@.planning/phases/36-async-loading/36-01-SUMMARY.md
@packages/select/src/select.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add async search props and state</name>
  <files>packages/select/src/select.ts</files>
  <action>
Add the configuration props and internal state for async search functionality.

1. Add new properties for async search configuration:

```typescript
/**
 * Debounce delay in milliseconds for async search.
 * Only applies when asyncSearch is provided.
 * @default 300
 */
@property({ type: Number })
debounceDelay = 300;

/**
 * Minimum characters before triggering async search.
 * Below this threshold, shows default/empty options.
 * @default 0
 */
@property({ type: Number })
minSearchLength = 0;

/**
 * Async search function. Called with search query and returns Promise of options.
 * When provided, enables async search mode for searchable selects.
 * The AbortSignal should be used to cancel in-flight requests.
 *
 * @example
 * ```typescript
 * asyncSearch={(query, signal) =>
 *   fetch(`/api/search?q=${query}`, { signal })
 *     .then(res => res.json())
 * }
 * ```
 */
@property({ attribute: false })
asyncSearch?: (query: string, signal: AbortSignal) => Promise<SelectOption[]>;
```

2. Add internal state for async search:

```typescript
/**
 * Timeout handle for search debounce.
 */
private _searchDebounceTimeout?: ReturnType<typeof setTimeout>;

/**
 * AbortController for cancelling in-flight search requests.
 */
private _searchAbortController?: AbortController;

/**
 * Whether async search is currently loading.
 */
@state()
private _searchLoading = false;

/**
 * Error from async search.
 */
@state()
private _searchError: Error | null = null;

/**
 * Options loaded from async search.
 */
@state()
private _searchResults: SelectOption[] | null = null;
```

3. Add helper to check if in async search mode:

```typescript
/**
 * Check if component is in async search mode.
 */
private get _isAsyncSearchMode(): boolean {
  return this.searchable && !!this.asyncSearch;
}
```
  </action>
  <verify>
Build with `pnpm --filter @lit-ui/select build` to verify props compile correctly.
  </verify>
  <done>
debounceDelay, minSearchLength, and asyncSearch props added. Internal state for search timeout, AbortController, loading, error, and results added.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement debounced async search with AbortController</name>
  <files>packages/select/src/select.ts</files>
  <action>
Implement the async search logic with debouncing and race condition prevention.

1. Add method to execute async search:

```typescript
/**
 * Execute async search with debounce and AbortController.
 * Cancels previous requests to prevent race conditions.
 */
private async executeAsyncSearch(query: string): Promise<void> {
  // Clear previous debounce timeout
  if (this._searchDebounceTimeout) {
    clearTimeout(this._searchDebounceTimeout);
    this._searchDebounceTimeout = undefined;
  }

  // Abort previous request
  if (this._searchAbortController) {
    this._searchAbortController.abort();
    this._searchAbortController = undefined;
  }

  // Check minimum length threshold
  if (query.length < this.minSearchLength) {
    // Below threshold - clear search results and show default options
    this._searchResults = null;
    this._searchLoading = false;
    this._searchError = null;
    this.requestUpdate();
    return;
  }

  // Show loading immediately for user feedback
  this._searchLoading = true;
  this._searchError = null;
  this.requestUpdate();

  // Debounce the actual API call
  this._searchDebounceTimeout = setTimeout(async () => {
    this._searchAbortController = new AbortController();

    try {
      const results = await this.asyncSearch!(
        query,
        this._searchAbortController.signal
      );

      // Update results only if not aborted
      this._searchResults = results;
      this._searchLoading = false;

      // Reset active index to first enabled result
      if (results.length > 0) {
        const firstEnabled = results.findIndex((o) => !o.disabled);
        this.activeIndex = firstEnabled >= 0 ? firstEnabled : 0;
      } else {
        this.activeIndex = -1;
      }

      this.requestUpdate();
    } catch (err) {
      // Ignore AbortError - expected when request is cancelled
      if ((err as Error).name === 'AbortError') {
        return;
      }

      // Handle actual errors
      this._searchError = err as Error;
      this._searchLoading = false;
      this._searchResults = null;
      this.requestUpdate();
    }
  }, this.debounceDelay);
}
```

2. Add method to fetch default options (when clearing search):

```typescript
/**
 * Fetch default options when search is cleared.
 * Calls asyncSearch with empty string if provided.
 */
private async fetchDefaultOptions(): Promise<void> {
  if (!this.asyncSearch) return;

  // Abort any pending search
  if (this._searchAbortController) {
    this._searchAbortController.abort();
    this._searchAbortController = undefined;
  }

  // Clear debounce
  if (this._searchDebounceTimeout) {
    clearTimeout(this._searchDebounceTimeout);
    this._searchDebounceTimeout = undefined;
  }

  this._searchLoading = true;
  this._searchError = null;
  this._searchAbortController = new AbortController();

  try {
    const results = await this.asyncSearch('', this._searchAbortController.signal);
    this._searchResults = results;
    this._searchLoading = false;
    this.requestUpdate();
  } catch (err) {
    if ((err as Error).name !== 'AbortError') {
      this._searchError = err as Error;
      this._searchLoading = false;
    }
    this.requestUpdate();
  }
}
```

3. Update the handleInput method to use async search when available:

Find the existing `handleInput` method and update it:

```typescript
/**
 * Handle input events in searchable mode.
 * Applies filter and updates dropdown.
 * Uses async search when asyncSearch prop is provided.
 */
private handleInput(e: InputEvent): void {
  const input = e.target as HTMLInputElement;
  const query = input.value;

  // Update filter query for display
  this.filterQuery = query;

  // Use async search if available
  if (this._isAsyncSearchMode) {
    this.executeAsyncSearch(query);
    return;
  }

  // Otherwise use local filtering (existing behavior)
  this.applyFilter(query);
}
```

4. Update effectiveOptions to include search results:

Update the effectiveOptions getter to prioritize search results when in async search mode:

```typescript
/**
 * Get the effective options list.
 * Priority: async search results > async loaded options > sync options prop > slotted options.
 * Returns array of objects with value, label, disabled.
 */
private get effectiveOptions(): SelectOption[] {
  // Async search results take highest precedence
  if (this._searchResults !== null) {
    return this._searchResults;
  }
  // Async loaded options (from Promise-based options prop)
  if (this._loadedAsyncOptions !== null) {
    return this._loadedAsyncOptions;
  }
  // Sync options property
  if (Array.isArray(this.options) && this.options.length > 0) {
    return this.options;
  }
  // Slotted options fallback
  return this.slottedOptions.map((opt) => ({
    value: opt.value,
    label: opt.getLabel(),
    disabled: opt.disabled,
  }));
}
```

5. Clean up async search state in disconnectedCallback:

Add to the existing disconnectedCallback:

```typescript
// In disconnectedCallback, add:
// Clear search debounce timeout
if (this._searchDebounceTimeout) {
  clearTimeout(this._searchDebounceTimeout);
  this._searchDebounceTimeout = undefined;
}

// Abort pending search request
if (this._searchAbortController) {
  this._searchAbortController.abort();
  this._searchAbortController = undefined;
}
```

6. Clear search state when dropdown closes:

Update closeDropdown method to clear search results when closing:

```typescript
// In closeDropdown method, add after setting open = false:
// Clear async search state when closing
if (this._isAsyncSearchMode) {
  this._searchResults = null;
  this._searchLoading = false;
  this._searchError = null;
}
```
  </action>
  <verify>
Build with `pnpm --filter @lit-ui/select build`. Test with a demo:
```html
<lui-select searchable debounce-delay="500" min-search-length="2"></lui-select>
<script>
  const select = document.querySelector('lui-select');
  select.asyncSearch = async (query, signal) => {
    const res = await fetch(`/api/search?q=${query}`, { signal });
    return res.json();
  };
</script>
```
  </verify>
  <done>
executeAsyncSearch method debounces API calls. AbortController cancels previous requests. Search loading shows skeletons. Default options re-fetched when clearing search. State cleaned up on disconnect and dropdown close.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update render method for async search states</name>
  <files>packages/select/src/select.ts</files>
  <action>
Update the render method to show appropriate states during async search.

1. Update the dropdown content rendering to handle async search loading state:

In the render() method's listbox section, update the conditional rendering to include search loading:

```typescript
${this._asyncLoading || this._searchLoading
  ? this.renderSkeletonOptions(4)
  : this._asyncError || this._searchError
    ? this.renderErrorState()
    : optionsToRender.length > 0
      ? optionsToRender.map((filterMatch, index) =>
          this.renderOption(filterMatch, index)
        )
      : this.searchable && this.filterQuery
        ? this.renderEmptyState()
        : nothing}
```

Key changes:
- `this._asyncLoading || this._searchLoading` - show skeletons for either async mode
- `this._asyncError || this._searchError` - show error for either async mode

2. Update the slot visibility condition:

```typescript
<div style=${optionsToRender.length > 0 || (this.searchable && this.filterQuery) || this._asyncLoading || this._asyncError || this._searchLoading || this._searchError ? 'display:none' : ''}>
  <slot @slotchange=${this.handleSlotChange}></slot>
</div>
```

3. Ensure error state handles both async types:

Update renderErrorState to handle search errors:

```typescript
/**
 * Render error state with retry action.
 * Handles both options loading errors and search errors.
 * Supports error slot for full customization.
 */
private renderErrorState() {
  const errorMessage = this._asyncError?.message || this._searchError?.message || 'Failed to load options';

  return html`
    <div class="error-state" role="alert">
      <slot name="error">
        <div class="error-content">
          <span class="error-message">${errorMessage}</span>
          <button
            type="button"
            class="retry-link"
            @click=${this._searchError ? this.handleSearchRetry : this.handleRetry}
          >
            Try again
          </button>
        </div>
      </slot>
    </div>
  `;
}
```

4. Add search retry handler:

```typescript
/**
 * Handle retry for async search error.
 */
private handleSearchRetry(): void {
  this._searchError = null;
  this.executeAsyncSearch(this.filterQuery);
}
```

5. Update filteredOptions getter to bypass local filtering in async search mode:

```typescript
/**
 * Get filtered options based on filterQuery.
 * Returns FilterMatch[] with match indices for highlighting.
 * In async search mode, returns effectiveOptions directly (server filters).
 */
private get filteredOptions(): FilterMatch[] {
  const options = this.effectiveOptions;

  // In async search mode, server handles filtering - return all options
  if (this._isAsyncSearchMode && this._searchResults !== null) {
    return options.map((option, index) => ({
      option,
      originalIndex: index,
      matchIndices: [], // No highlighting for async results (server filtered)
    }));
  }

  // Return all options with empty matchIndices if not searchable or filter is empty
  if (!this.searchable || !this.filterQuery) {
    return options.map((option, index) => ({
      option,
      originalIndex: index,
      matchIndices: [],
    }));
  }

  // ... rest of existing local filtering logic
```
  </action>
  <verify>
Build with `pnpm --filter @lit-ui/select build`. Verify:
1. Typing in async search shows skeleton loading
2. Error state shows when asyncSearch rejects
3. Retry re-executes the search
4. Server-filtered results display correctly
  </verify>
  <done>
Async search shows skeleton during loading. Search errors display in error state. Retry button re-executes search. Server-filtered results bypass local filtering.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @lit-ui/select build` succeeds
2. asyncSearch prop accepts function signature
3. debounceDelay configures debounce timing (default 300ms)
4. minSearchLength configures minimum characters before search
5. Skeleton loading shown during search
6. AbortController cancels previous requests
7. Error state with retry shown on search failure
8. Clearing search re-fetches default options
</verification>

<success_criteria>
- asyncSearch prop added with (query: string, signal: AbortSignal) => Promise<SelectOption[]> signature
- debounceDelay prop defaults to 300ms
- minSearchLength prop defaults to 0
- executeAsyncSearch implements debounce with setTimeout
- AbortController cancels previous in-flight requests
- Search loading shows skeleton placeholders
- Search error shows error state with retry
- State properly cleaned up on disconnect
- Package builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/36-async-loading/36-03-SUMMARY.md`
</output>
