---
phase: 36-async-loading
plan: 04
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - packages/select/src/select.ts
autonomous: true

must_haves:
  truths:
    - "Developer with 1000+ options enables virtual scrolling and dropdown remains performant"
    - "Virtual scrolling is always enabled for async selects"
    - "Keyboard navigation works seamlessly with virtualized options"
    - "Arrow keys navigate all options, scroll follows focus"
  artifacts:
    - path: "packages/select/src/select.ts"
      provides: "Virtual scrolling integration"
      contains: "VirtualizerController"
    - path: "packages/select/src/select.ts"
      provides: "Virtualized option rendering"
      contains: "renderVirtualizedOptions"
  key_links:
    - from: "packages/select/src/select.ts"
      to: "@tanstack/lit-virtual"
      via: "VirtualizerController import"
      pattern: "import.*@tanstack/lit-virtual"
---

<objective>
Implement virtual scrolling for large option lists using @tanstack/lit-virtual.

Purpose: Enable performant scrolling through thousands of options by only rendering visible items in the DOM. Always enabled for async selects per CONTEXT.md decision (ASYNC-06).

Output: Select component uses VirtualizerController for async modes, maintains 60fps scroll performance, and seamlessly integrates keyboard navigation with scrollToIndex.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-async-loading/36-RESEARCH.md
@.planning/phases/36-async-loading/36-01-SUMMARY.md
@packages/select/src/select.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up VirtualizerController integration</name>
  <files>packages/select/src/select.ts</files>
  <action>
Integrate @tanstack/lit-virtual's VirtualizerController with the Select component.

1. Add imports for virtual scrolling:
```typescript
import { VirtualizerController } from '@tanstack/lit-virtual';
import { Ref, createRef, ref } from 'lit/directives/ref.js';
```

2. Add ref for the scroll container and virtualizer controller:
```typescript
/**
 * Reference to the listbox scroll container for virtual scrolling.
 */
private _listboxRef: Ref<HTMLDivElement> = createRef();

/**
 * VirtualizerController for rendering large option lists efficiently.
 * Only initialized in async mode where virtual scrolling is always enabled.
 */
private _virtualizer?: VirtualizerController<HTMLDivElement, Element>;

/**
 * Whether virtualization is currently active.
 */
private get _isVirtualized(): boolean {
  return this._isAsyncMode || this._isAsyncSearchMode;
}

/**
 * Standard option height in pixels for virtualizer estimation.
 */
private static readonly OPTION_HEIGHT = 36;

/**
 * Number of extra items to render outside visible area.
 */
private static readonly VIRTUALIZER_OVERSCAN = 5;
```

3. Add method to initialize or update the virtualizer:
```typescript
/**
 * Initialize or update the virtualizer based on current options count.
 * Called when options change or async mode becomes active.
 */
private updateVirtualizer(): void {
  if (!this._isVirtualized) {
    this._virtualizer = undefined;
    return;
  }

  const scrollElement = this._listboxRef.value;
  if (!scrollElement) return;

  const optionCount = this.effectiveOptions.length;

  if (!this._virtualizer) {
    // Create new virtualizer
    this._virtualizer = new VirtualizerController(this, {
      getScrollElement: () => this._listboxRef.value ?? null,
      count: optionCount,
      estimateSize: () => Select.OPTION_HEIGHT,
      overscan: Select.VIRTUALIZER_OVERSCAN,
    });
  } else {
    // Update existing virtualizer count
    this._virtualizer.getVirtualizer().setOptions({
      count: optionCount,
    });
  }
}
```

4. Update the updated lifecycle to initialize/update virtualizer:
```typescript
override updated(changedProperties: PropertyValues): void {
  super.updated(changedProperties);

  // Start observing tag container for overflow (existing code)
  if (this.multiple && this.selectedValues.size > 0) {
    const tagContainer = this.shadowRoot?.querySelector('.tag-container');
    if (tagContainer && this.resizeObserver) {
      this.resizeObserver.observe(tagContainer);
    }
  }

  // Initialize or update virtualizer when options change or dropdown opens
  if (this._isVirtualized && this.open) {
    this.updateVirtualizer();
  }
}
```

5. Clean up virtualizer in disconnectedCallback:
```typescript
// In disconnectedCallback, add:
// Clean up virtualizer
this._virtualizer = undefined;
```
  </action>
  <verify>
Build with `pnpm --filter @lit-ui/select build` to verify imports and controller setup compile correctly.
  </verify>
  <done>
VirtualizerController imported from @tanstack/lit-virtual. Ref created for scroll container. updateVirtualizer method manages controller lifecycle. Virtualizer cleaned up on disconnect.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement virtualized option rendering</name>
  <files>packages/select/src/select.ts</files>
  <action>
Add method to render options using virtual scrolling.

1. Add CSS for virtualized listbox container:
```css
/* Virtualized listbox container */
.listbox-virtual {
  position: relative;
  overflow-y: auto;
}

.listbox-virtual-content {
  position: relative;
  width: 100%;
}

.option-virtual {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
}
```

2. Add method to render virtualized options:
```typescript
/**
 * Render options using virtual scrolling.
 * Only renders visible items plus overscan for smooth scrolling.
 */
private renderVirtualizedOptions(): TemplateResult {
  if (!this._virtualizer) {
    return html``;
  }

  const virtualizer = this._virtualizer.getVirtualizer();
  const virtualItems = virtualizer.getVirtualItems();
  const totalSize = virtualizer.getTotalSize();
  const options = this.effectiveOptions;

  return html`
    <div
      class="listbox-virtual-content"
      style="height: ${totalSize}px;"
    >
      ${virtualItems.map((virtualItem) => {
        const option = options[virtualItem.index];
        if (!option) return nothing;

        // Create FilterMatch for consistency with existing renderOption
        const filterMatch: FilterMatch = {
          option,
          originalIndex: virtualItem.index,
          matchIndices: [],
        };

        const isActive = virtualItem.index === this.activeIndex;
        const isSelected = this.multiple
          ? this.selectedValues.has(option.value)
          : option.value === this._value;
        const classes = ['option', 'option-virtual'];
        if (isActive) classes.push('option-active');
        if (isSelected) classes.push('option-selected');
        if (option.disabled) classes.push('option-disabled');

        return html`
          <div
            id="${this.selectId}-option-${virtualItem.index}"
            role="option"
            aria-selected=${isSelected ? 'true' : 'false'}
            aria-disabled=${option.disabled ? 'true' : 'false'}
            class=${classes.join(' ')}
            style="transform: translateY(${virtualItem.start}px); height: ${virtualItem.size}px;"
            @click=${(e: MouseEvent) => this.handleOptionClick(e, virtualItem.index)}
          >
            ${this.renderSelectionIndicator(isSelected)}
            <span>${option.label || option.value}</span>
          </div>
        `;
      })}
    </div>
  `;
}
```

NOTE: Import `TemplateResult` from 'lit' if needed for return type.

3. Update setActiveIndex to use virtualizer scrollToIndex:
```typescript
/**
 * Set the active option index and scroll into view.
 * Uses virtualizer.scrollToIndex when virtualized, otherwise native scrollIntoView.
 */
private setActiveIndex(index: number): void {
  this.activeIndex = index;
  // Clear create option active when selecting a regular option
  this.createOptionActive = false;

  // Use virtualizer scrollToIndex when virtualized
  if (this._isVirtualized && this._virtualizer) {
    this._virtualizer.getVirtualizer().scrollToIndex(index, {
      align: 'auto',
      behavior: 'auto',
    });
    return;
  }

  // Sync active state for slotted options
  if (this.isSlottedMode) {
    this.syncSlottedActiveState();
    // Scroll slotted option into view
    const opt = this.slottedOptions[index];
    opt?.scrollIntoView({ block: 'nearest' });
  } else {
    // Scroll property-based option into view
    this.updateComplete.then(() => {
      const optionEl = this.shadowRoot?.getElementById(
        `${this.selectId}-option-${index}`
      );
      optionEl?.scrollIntoView({ block: 'nearest' });
    });
  }
}
```
  </action>
  <verify>
Build with `pnpm --filter @lit-ui/select build`. Verify virtualized rendering compiles and scrollToIndex integration is correct.
  </verify>
  <done>
renderVirtualizedOptions method renders only visible items. CSS positions virtual items absolutely. scrollToIndex used for keyboard navigation scroll.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update render method to use virtualized rendering</name>
  <files>packages/select/src/select.ts</files>
  <action>
Update the main render method to conditionally use virtualized rendering.

1. Update the listbox rendering in the render method:

Find the listbox div and update it to use ref directive and conditional virtualized rendering:

```typescript
<!-- Dropdown listbox -->
<div
  id=${listboxId}
  class="listbox ${this._isVirtualized ? 'listbox-virtual' : ''}"
  role="listbox"
  aria-labelledby=${this.selectId}
  aria-multiselectable=${this.multiple ? 'true' : nothing}
  ?hidden=${!this.open}
  ${this._isVirtualized ? ref(this._listboxRef) : nothing}
>
  ${this.renderSelectAllActions()}
  ${this._asyncLoading || this._searchLoading
    ? this.renderSkeletonOptions(4)
    : this._asyncError || this._searchError
      ? this.renderErrorState()
      : this._isVirtualized && optionsToRender.length > 0
        ? this.renderVirtualizedOptions()
        : optionsToRender.length > 0
          ? optionsToRender.map((filterMatch, index) =>
              this.renderOption(filterMatch, index)
            )
          : this.searchable && this.filterQuery
            ? this.renderEmptyState()
            : nothing}
  <!-- Always render slot to keep it in DOM, hide when rendering programmatic options -->
  <div style=${optionsToRender.length > 0 || (this.searchable && this.filterQuery) || this._asyncLoading || this._asyncError || this._searchLoading || this._searchError || this._isVirtualized ? 'display:none' : ''}>
    <slot @slotchange=${this.handleSlotChange}></slot>
  </div>
  ${this.renderCreateOption()}
</div>
```

Key changes:
- Add `listbox-virtual` class when virtualized
- Apply ref directive when virtualized: `${this._isVirtualized ? ref(this._listboxRef) : nothing}`
- Check `this._isVirtualized && optionsToRender.length > 0` to use virtualized rendering
- Update slot visibility to include `this._isVirtualized`

2. Ensure virtualizer is updated when options load:

Add to the Task completion handler (in the _optionsTask success path):

```typescript
// In _optionsTask, after setting _loadedAsyncOptions:
// Schedule virtualizer update after render
this.updateComplete.then(() => {
  if (this._isVirtualized && this.open) {
    this.updateVirtualizer();
  }
});
```

Similarly, update the async search success handler in executeAsyncSearch:

```typescript
// After setting _searchResults:
// Update virtualizer with new options count
this.updateComplete.then(() => {
  if (this._isVirtualized && this.open) {
    this.updateVirtualizer();
  }
});
```

3. Handle dropdown opening with virtualization:

Update openDropdown to initialize virtualizer:

```typescript
// In openDropdown, after setting open = true and before requestUpdate:
// Initialize virtualizer for async mode
if (this._isVirtualized) {
  this.updateComplete.then(() => {
    this.updateVirtualizer();
  });
}
```
  </action>
  <verify>
Build with `pnpm --filter @lit-ui/select build`. Test with large dataset:
```html
<lui-select id="virtual-demo"></lui-select>
<script>
  const select = document.querySelector('#virtual-demo');
  select.options = new Promise(resolve => {
    const options = Array.from({length: 10000}, (_, i) => ({
      value: String(i),
      label: `Option ${i + 1}`
    }));
    resolve(options);
  });
</script>
```
Verify smooth scrolling and keyboard navigation.
  </verify>
  <done>
Render method conditionally uses virtualized rendering for async modes. Virtualizer initialized when dropdown opens. Options update triggers virtualizer count update. Keyboard navigation uses scrollToIndex.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @lit-ui/select build` succeeds
2. VirtualizerController from @tanstack/lit-virtual is used
3. Virtualization automatically enabled for Promise-based options
4. Virtualization automatically enabled for async search mode
5. Scroll performance remains smooth (60fps) with 10,000+ options
6. Keyboard navigation (Arrow keys) works correctly with scrollToIndex
7. Active option always scrolls into view when navigating
</verification>

<success_criteria>
- VirtualizerController integrated with Select component
- Virtual scrolling enabled for all async modes (Promise options, async search)
- Only visible options + overscan rendered in DOM
- scrollToIndex used for keyboard navigation
- Smooth 60fps scrolling with large datasets
- Package builds without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/36-async-loading/36-04-SUMMARY.md`
</output>
