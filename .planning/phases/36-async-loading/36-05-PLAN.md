---
phase: 36-async-loading
plan: 05
type: execute
wave: 3
depends_on: ["36-04"]
files_modified:
  - packages/select/src/select.ts
autonomous: true

must_haves:
  truths:
    - "User scrolls to bottom of long option list and next page of options loads automatically"
    - "Load more triggers at 80% scroll (near bottom, not at bottom)"
    - "Loading more shows skeleton rows appended to list"
    - "Infinite scroll integrates with virtual scrolling"
  artifacts:
    - path: "packages/select/src/select.ts"
      provides: "Infinite scroll pagination"
      contains: "loadMore"
    - path: "packages/select/src/select.ts"
      provides: "IntersectionObserver for scroll detection"
      contains: "IntersectionObserver"
  key_links:
    - from: "packages/select/src/select.ts"
      to: "IntersectionObserver"
      via: "sentinel element observation"
      pattern: "_loadMoreObserver"
---

<objective>
Implement infinite scroll pagination for loading additional options when scrolling near the bottom.

Purpose: Enable paginated API endpoints to load options incrementally as the user scrolls, avoiding large initial payloads while providing seamless data loading experience (ASYNC-05).

Output: Select component supports loadMore callback prop that triggers at 80% scroll position, shows skeleton loading indicators, and integrates with virtual scrolling.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-async-loading/36-RESEARCH.md
@.planning/phases/36-async-loading/36-04-SUMMARY.md
@packages/select/src/select.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add infinite scroll props and state</name>
  <files>packages/select/src/select.ts</files>
  <action>
Add the configuration prop and internal state for infinite scroll functionality.

1. Add loadMore callback property:
```typescript
/**
 * Callback to load more options for infinite scroll.
 * Called when user scrolls near the bottom of the option list.
 * Return additional options to append, or empty array when no more data.
 *
 * @example
 * ```typescript
 * let page = 1;
 * loadMore={async () => {
 *   const res = await fetch(`/api/options?page=${++page}`);
 *   return res.json();
 * }}
 * ```
 */
@property({ attribute: false })
loadMore?: () => Promise<SelectOption[]>;
```

2. Add internal state for infinite scroll:
```typescript
/**
 * Whether there are more options to load.
 * Set to false when loadMore returns empty array.
 */
@state()
private _hasMore = true;

/**
 * Whether currently loading more options.
 */
@state()
private _loadingMore = false;

/**
 * Reference to the load-more sentinel element.
 */
private _sentinelRef: Ref<HTMLDivElement> = createRef();

/**
 * IntersectionObserver for infinite scroll trigger.
 */
private _loadMoreObserver?: IntersectionObserver;
```

3. Add helper to check if infinite scroll is enabled:
```typescript
/**
 * Check if infinite scroll is enabled.
 */
private get _isInfiniteScrollEnabled(): boolean {
  return !!this.loadMore && this._hasMore;
}
```
  </action>
  <verify>
Build with `pnpm --filter @lit-ui/select build` to verify props compile correctly.
  </verify>
  <done>
loadMore prop added. Internal state for _hasMore, _loadingMore, sentinel ref, and observer added.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement IntersectionObserver for scroll detection</name>
  <files>packages/select/src/select.ts</files>
  <action>
Implement IntersectionObserver to detect when user scrolls near the bottom.

1. Add method to set up the IntersectionObserver:
```typescript
/**
 * Set up IntersectionObserver for infinite scroll.
 * Triggers loadMore when sentinel enters 80% threshold.
 */
private setupLoadMoreObserver(): void {
  if (this._loadMoreObserver || !this.loadMore) return;

  const scrollContainer = this._listboxRef.value;
  if (!scrollContainer) return;

  this._loadMoreObserver = new IntersectionObserver(
    (entries) => {
      const [entry] = entries;
      if (entry.isIntersecting && this._hasMore && !this._loadingMore && !this._asyncLoading && !this._searchLoading) {
        this.handleLoadMore();
      }
    },
    {
      root: scrollContainer,
      // Trigger when sentinel is 20% from the bottom (80% scroll)
      rootMargin: '0px 0px 20% 0px',
      threshold: 0,
    }
  );

  // Observe sentinel element
  const sentinel = this._sentinelRef.value;
  if (sentinel) {
    this._loadMoreObserver.observe(sentinel);
  }
}
```

2. Add method to handle loading more options:
```typescript
/**
 * Handle load more trigger.
 * Calls loadMore callback and appends results.
 */
private async handleLoadMore(): Promise<void> {
  if (!this.loadMore || this._loadingMore || !this._hasMore) return;

  this._loadingMore = true;
  this.requestUpdate();

  try {
    const moreOptions = await this.loadMore();

    if (moreOptions.length === 0) {
      // No more data
      this._hasMore = false;
    } else {
      // Append to existing options
      if (this._searchResults !== null) {
        this._searchResults = [...this._searchResults, ...moreOptions];
      } else if (this._loadedAsyncOptions !== null) {
        this._loadedAsyncOptions = [...this._loadedAsyncOptions, ...moreOptions];
      }

      // Update virtualizer count
      this.updateComplete.then(() => {
        if (this._virtualizer) {
          this._virtualizer.getVirtualizer().setOptions({
            count: this.effectiveOptions.length,
          });
        }
      });
    }
  } catch (err) {
    console.error('Failed to load more options:', err);
    // Don't set error state for load-more failures - user can scroll again to retry
  } finally {
    this._loadingMore = false;
    this.requestUpdate();
  }
}
```

3. Add method to clean up observer:
```typescript
/**
 * Clean up the load more IntersectionObserver.
 */
private cleanupLoadMoreObserver(): void {
  if (this._loadMoreObserver) {
    this._loadMoreObserver.disconnect();
    this._loadMoreObserver = undefined;
  }
}
```

4. Update disconnectedCallback to clean up observer:
```typescript
// In disconnectedCallback, add:
// Clean up load more observer
this.cleanupLoadMoreObserver();
```

5. Reset _hasMore when options change:

Add to the Task completion handler (in _optionsTask):
```typescript
// Reset hasMore when options reload
this._hasMore = true;
```

Add to executeAsyncSearch success path:
```typescript
// Reset hasMore for new search
this._hasMore = true;
```

6. Update openDropdown to set up observer:
```typescript
// In openDropdown, after positioning, add:
// Set up infinite scroll observer
this.updateComplete.then(() => {
  if (this._isInfiniteScrollEnabled) {
    this.setupLoadMoreObserver();
  }
});
```

7. Update closeDropdown to clean up observer:
```typescript
// In closeDropdown, add:
// Clean up infinite scroll
this.cleanupLoadMoreObserver();
this._loadingMore = false;
```
  </action>
  <verify>
Build with `pnpm --filter @lit-ui/select build`. Verify observer setup and cleanup compiles correctly.
  </verify>
  <done>
IntersectionObserver created with 80% scroll threshold. Observer set up when dropdown opens. Observer cleaned up on close and disconnect. _hasMore reset on options change.
  </done>
</task>

<task type="auto">
  <name>Task 3: Render sentinel and loading-more skeletons</name>
  <files>packages/select/src/select.ts</files>
  <action>
Add rendering for the sentinel element and loading-more skeleton indicators.

1. Add CSS for sentinel and loading-more container:
```css
/* Infinite scroll sentinel and loading */
.load-more-sentinel {
  height: 1px;
  width: 100%;
}

.loading-more-container {
  padding: 0;
}
```

2. Add method to render the load-more sentinel and loading indicator:
```typescript
/**
 * Render the load-more sentinel and loading indicator.
 * Sentinel triggers IntersectionObserver when visible.
 */
private renderLoadMoreSentinel(): TemplateResult | typeof nothing {
  if (!this.loadMore || !this._hasMore) return nothing;

  return html`
    <div class="loading-more-container">
      ${this._loadingMore ? this.renderSkeletonOptions(3) : nothing}
      <div
        ${ref(this._sentinelRef)}
        class="load-more-sentinel"
        aria-hidden="true"
      ></div>
    </div>
  `;
}
```

3. Update the render method to include the sentinel:

In the listbox rendering, add the sentinel after the options but before the slot:

```typescript
<!-- Dropdown listbox -->
<div
  id=${listboxId}
  class="listbox ${this._isVirtualized ? 'listbox-virtual' : ''}"
  role="listbox"
  aria-labelledby=${this.selectId}
  aria-multiselectable=${this.multiple ? 'true' : nothing}
  ?hidden=${!this.open}
  ${this._isVirtualized ? ref(this._listboxRef) : nothing}
>
  ${this.renderSelectAllActions()}
  ${this._asyncLoading || this._searchLoading
    ? this.renderSkeletonOptions(4)
    : this._asyncError || this._searchError
      ? this.renderErrorState()
      : this._isVirtualized && optionsToRender.length > 0
        ? html`
            ${this.renderVirtualizedOptions()}
            ${this.renderLoadMoreSentinel()}
          `
        : optionsToRender.length > 0
          ? html`
              ${optionsToRender.map((filterMatch, index) =>
                this.renderOption(filterMatch, index)
              )}
              ${this.renderLoadMoreSentinel()}
            `
          : this.searchable && this.filterQuery
            ? this.renderEmptyState()
            : nothing}
  <!-- Always render slot... -->
```

Key change: Add `${this.renderLoadMoreSentinel()}` after both virtualized and non-virtualized option lists.

4. Update renderVirtualizedOptions to account for loading-more height:

When loading more, we need to add height for the skeleton rows at the bottom:

```typescript
/**
 * Render options using virtual scrolling.
 * Accounts for loading-more skeleton height.
 */
private renderVirtualizedOptions(): TemplateResult {
  if (!this._virtualizer) {
    return html``;
  }

  const virtualizer = this._virtualizer.getVirtualizer();
  const virtualItems = virtualizer.getVirtualItems();
  const totalSize = virtualizer.getTotalSize();
  const options = this.effectiveOptions;

  // Add extra height for loading-more skeletons
  const loadingMoreHeight = this._loadingMore ? 3 * Select.OPTION_HEIGHT : 0;

  return html`
    <div
      class="listbox-virtual-content"
      style="height: ${totalSize + loadingMoreHeight}px;"
    >
      ${virtualItems.map((virtualItem) => {
        // ... existing virtualItem rendering
      })}
    </div>
  `;
}
```

5. Ensure observer re-observes sentinel after render:

In the updated lifecycle, re-observe sentinel when it changes:

```typescript
// In updated(), add:
// Re-observe sentinel after render if needed
if (this.loadMore && this._hasMore && this.open && this._loadMoreObserver) {
  const sentinel = this._sentinelRef.value;
  if (sentinel) {
    this._loadMoreObserver.disconnect();
    this._loadMoreObserver.observe(sentinel);
  }
}
```
  </action>
  <verify>
Build with `pnpm --filter @lit-ui/select build`. Test with paginated data:
```html
<lui-select id="infinite-demo"></lui-select>
<script>
  const select = document.querySelector('#infinite-demo');
  let page = 0;
  select.options = new Promise(resolve => {
    const options = Array.from({length: 20}, (_, i) => ({
      value: String(i),
      label: `Option ${i + 1}`
    }));
    resolve(options);
  });
  select.loadMore = async () => {
    page++;
    if (page > 5) return []; // No more after 5 pages
    return Array.from({length: 20}, (_, i) => ({
      value: String(page * 20 + i),
      label: `Option ${page * 20 + i + 1}`
    }));
  };
</script>
```
  </verify>
  <done>
Sentinel element rendered at end of options list. Loading-more skeletons shown when fetching. Observer triggers at 80% scroll. Sentinel re-observed after DOM updates.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @lit-ui/select build` succeeds
2. loadMore callback prop accepts () => Promise<SelectOption[]>
3. IntersectionObserver triggers at 80% scroll (20% from bottom)
4. Loading-more shows 3 skeleton rows
5. New options appended to existing list
6. _hasMore set to false when empty array returned
7. Observer cleaned up on dropdown close and component disconnect
8. Integrates properly with virtual scrolling
</verification>

<success_criteria>
- loadMore prop added for pagination callback
- IntersectionObserver set up with 80% scroll threshold
- Skeleton loading indicators shown during load-more
- Options appended to existing list
- hasMore flag tracks end of data
- Observer properly cleaned up
- Works with both virtualized and non-virtualized rendering
- Package builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/36-async-loading/36-05-SUMMARY.md`
</output>
