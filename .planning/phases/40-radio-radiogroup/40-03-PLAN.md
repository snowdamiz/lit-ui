---
phase: 40-radio-radiogroup
plan: 03
type: execute
wave: 3
depends_on: ["40-02"]
files_modified:
  - packages/radio/src/radio-group.ts
  - packages/radio/src/index.ts
  - packages/radio/src/jsx.d.ts
autonomous: true

must_haves:
  truths:
    - "Only one radio in a group is ever checked at a time (mutual exclusion)"
    - "Clicking a radio selects it and deselects all siblings"
    - "Arrow keys (Up/Down/Left/Right) move focus AND selection with wrapping"
    - "Tab exits the radio group entirely (single tab stop via roving tabindex)"
    - "RadioGroup submits selected value to forms via ElementInternals"
    - "RadioGroup with required prevents form submission when nothing selected"
    - "RadioGroup with disabled makes all child radios non-interactive"
    - "Form reset restores RadioGroup to its initial value"
    - "Screen readers announce role='radiogroup' on group and role='radio' on children"
  artifacts:
    - path: "packages/radio/src/radio-group.ts"
      provides: "RadioGroup web component class (form-associated)"
      exports: ["RadioGroup"]
    - path: "packages/radio/src/index.ts"
      provides: "Safe registration for both lui-radio and lui-radio-group"
      contains: "lui-radio-group"
    - path: "packages/radio/src/jsx.d.ts"
      provides: "JSX types for both lui-radio and lui-radio-group"
      contains: "lui-radio-group"
  key_links:
    - from: "packages/radio/src/radio-group.ts"
      to: "packages/radio/src/radio.ts"
      via: "Import Radio type, discover lui-radio children via slotchange"
      pattern: "import type.*Radio.*from.*radio"
    - from: "packages/radio/src/radio-group.ts"
      to: "ElementInternals"
      via: "static formAssociated = true, attachInternals(), setFormValue()"
      pattern: "formAssociated.*true"
    - from: "packages/radio/src/radio-group.ts"
      to: "roving tabindex"
      via: "updateRovingTabindex() sets tabIndex on lui-radio host elements"
      pattern: "tabIndex.*=.*0|-1"
    - from: "packages/radio/src/index.ts"
      to: "packages/radio/src/radio-group.ts"
      via: "Import and register lui-radio-group element"
      pattern: "customElements.define.*lui-radio-group"
---

<objective>
Implement the lui-radio-group web component with mutual exclusion, roving tabindex keyboard navigation, form participation via ElementInternals, and group-level validation.

Purpose: RadioGroup is the orchestrator that enforces single selection, manages keyboard navigation, submits the selected value to forms, and propagates disabled state. This is the critical plan that delivers the core Radio + RadioGroup user experience.
Output: Working RadioGroup that manages child radios with full W3C APG compliance.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-radio-radiogroup/40-RESEARCH.md
@.planning/phases/40-radio-radiogroup/40-01-SUMMARY.md
@.planning/phases/40-radio-radiogroup/40-02-SUMMARY.md

Reference implementation (adapt from):
@packages/checkbox/src/checkbox-group.ts
@packages/checkbox/src/index.ts
@packages/checkbox/src/jsx.d.ts
@packages/switch/src/switch.ts (form participation pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement lui-radio-group component</name>
  <files>
    packages/radio/src/radio-group.ts
  </files>
  <action>
Create `packages/radio/src/radio-group.ts` combining patterns from CheckboxGroup (slot-based child discovery, disabled propagation, group layout) and Switch (form participation via ElementInternals).

**CRITICAL architectural difference from CheckboxGroup:**
- CheckboxGroup is NOT form-associated (children submit independently)
- RadioGroup IS form-associated (group submits the selected radio's value)
- RadioGroup introduces roving tabindex (new pattern, not in CheckboxGroup)

**Class structure:**
```typescript
import { html, css, nothing, isServer, type PropertyValues } from 'lit';
import { property, state } from 'lit/decorators.js';
import { TailwindElement, tailwindBaseStyles } from '@lit-ui/core';
import { dispatchCustomEvent } from '@lit-ui/core';
import type { Radio } from './radio.js';

export class RadioGroup extends TailwindElement {
  static formAssociated = true;
```

**Properties:**
- `name: string = ''` — Form field name
- `value: string = ''` — Currently selected radio's value
- `required: boolean = false` (reflect: true) — Require selection for form validity
- `disabled: boolean = false` (reflect: true) — Disable all child radios
- `label: string = ''` — Group label text
- `error: string = ''` — Custom error message

**Private/state members:**
- `internals: ElementInternals | null = null` — Form internals (null during SSR)
- `groupId: string` — Unique ID for label association
- `radios: Radio[] = []` — Discovered child radios
- `defaultValue: string = ''` — Initial value for form reset
- `touched: boolean = false` (state) — Whether user has interacted
- `showError: boolean = false` (state) — Whether to show validation error

**Constructor:**
```typescript
constructor() {
  super();
  if (!isServer) {
    this.internals = this.attachInternals();
  }
}
```

**Lifecycle:**
- `connectedCallback()`: Store `defaultValue = this.value`, call `updateFormValue()`
- `updated(changedProperties: PropertyValues)`: Use PropertyValues type (NOT Map — api-extractor bug from Phase 38-02). Watch for `value` and `disabled` changes:
  - If `value` changed: call `syncChildStates()`, `updateRovingTabindex()`, `updateFormValue()`, `validate()`
  - If `disabled` changed: call `syncDisabledState()`, `updateRovingTabindex()`

**Slot-based child discovery (same as CheckboxGroup):**
```typescript
private handleSlotChange(e: Event): void {
  const slot = e.target as HTMLSlotElement;
  const assigned = slot.assignedElements({ flatten: true });
  this.radios = assigned.filter(
    (el) => el.tagName === 'LUI-RADIO'
  ) as Radio[];
  this.syncChildStates();
  this.syncDisabledState();
  this.updateRovingTabindex();
}
```

**Mutual exclusion (syncChildStates):**
```typescript
private syncChildStates(): void {
  for (const radio of this.radios) {
    radio.checked = (radio.value === this.value);
  }
}
```

**Disabled propagation:**
```typescript
private syncDisabledState(): void {
  if (this.disabled) {
    this.radios.forEach(r => r.disabled = true);
  }
}
```

**Roving tabindex (NEW pattern — does not exist in CheckboxGroup):**
```typescript
private updateRovingTabindex(): void {
  const enabledRadios = this.radios.filter(r => !r.disabled);
  if (enabledRadios.length === 0) return;

  const checkedRadio = enabledRadios.find(r => r.checked);
  const focusTarget = checkedRadio || enabledRadios[0];

  for (const radio of this.radios) {
    // Set tabIndex on the HOST element (lui-radio), not inner shadow DOM
    radio.tabIndex = (radio === focusTarget && !radio.disabled) ? 0 : -1;
  }
}
```

**Arrow key navigation (on group container, NOT on individual radios):**
```typescript
private handleKeyDown(e: KeyboardEvent): void {
  const arrowKeys = ['ArrowDown', 'ArrowRight', 'ArrowUp', 'ArrowLeft'];
  if (!arrowKeys.includes(e.key)) return;
  e.preventDefault();

  const enabledRadios = this.radios.filter(r => !r.disabled);
  if (enabledRadios.length === 0) return;

  const currentIndex = enabledRadios.findIndex(r => r.tabIndex === 0);
  const forward = e.key === 'ArrowDown' || e.key === 'ArrowRight';
  const nextIndex = forward
    ? (currentIndex + 1) % enabledRadios.length
    : (currentIndex - 1 + enabledRadios.length) % enabledRadios.length;

  // Arrow keys MOVE FOCUS AND SELECT simultaneously
  const nextRadio = enabledRadios[nextIndex];
  this.value = nextRadio.value;
  this.touched = true;
  this.syncChildStates();
  this.updateRovingTabindex();
  this.updateFormValue();
  this.validate();
  nextRadio.focus();

  dispatchCustomEvent(this, 'ui-change', {
    value: this.value,
  });
}
```

**Internal event handler (Radio -> RadioGroup):**
```typescript
private handleRadioChange(e: CustomEvent): void {
  e.stopPropagation(); // Internal event, don't leak to consumer
  this.value = e.detail.value;
  this.touched = true;
  this.syncChildStates();
  this.updateRovingTabindex();
  this.updateFormValue();
  this.validate();

  // Dispatch consumer-facing event
  dispatchCustomEvent(this, 'ui-change', {
    value: this.value,
  });
}
```

**Form participation:**
```typescript
private updateFormValue(): void {
  this.internals?.setFormValue(this.value || null);
}

private validate(): boolean {
  if (!this.internals) return true;

  if (this.required && !this.value) {
    this.internals.setValidity(
      { valueMissing: true },
      this.error || 'Please select an option.',
      this.radios[0] || (this.shadowRoot?.querySelector('.group-items') as HTMLElement)
    );
    this.showError = this.touched;
    return false;
  }

  this.internals.setValidity({});
  this.showError = false;
  return true;
}

formResetCallback(): void {
  this.value = this.defaultValue;
  this.syncChildStates();
  this.updateRovingTabindex();
  this.updateFormValue();
  this.touched = false;
  this.showError = false;
  this.internals?.setValidity({});
}

formDisabledCallback(disabled: boolean): void {
  this.disabled = disabled;
  this.syncDisabledState();
  this.updateRovingTabindex();
}
```

**Render template (role="radiogroup"):**
```html
<div
  class="group-wrapper"
  role="radiogroup"
  aria-labelledby="${this.groupId}-label"
  aria-required=${this.required ? 'true' : nothing}
  @ui-radio-change=${this.handleRadioChange}
  @keydown=${this.handleKeyDown}
>
  ${label span if this.label exists}
  <div class="group-items">
    <slot @slotchange=${this.handleSlotChange}></slot>
  </div>
  ${error text div with role="alert" if this.showError}
</div>
```

**CSS styles:**
- `:host { display: block; }`
- `:host([disabled]) { opacity: 0.5; }`
- `.group-wrapper` — flex column
- `.group-label` — font-weight: 500, margin-bottom: 0.375rem, font-size: 0.875rem
- `.group-items` — flex column, gap: `var(--ui-radio-group-gap)`
- `.error-text` — font-size: 0.75rem, color: `var(--ui-radio-text-error)`, margin-top: 0.25rem

**JSDoc:** Full JSDoc comment block documenting features, form participation, keyboard navigation, slots, and examples.
  </action>
  <verify>
- File exists: `ls packages/radio/src/radio-group.ts`
- Form-associated: `grep 'formAssociated = true' packages/radio/src/radio-group.ts`
- Roving tabindex: `grep 'tabIndex' packages/radio/src/radio-group.ts`
- Arrow key handler: `grep 'ArrowDown' packages/radio/src/radio-group.ts`
- Role radiogroup: `grep "role=\"radiogroup\"" packages/radio/src/radio-group.ts`
- Form reset: `grep 'formResetCallback' packages/radio/src/radio-group.ts`
- Uses PropertyValues: `grep 'PropertyValues' packages/radio/src/radio-group.ts`
  </verify>
  <done>RadioGroup component enforces mutual exclusion, implements roving tabindex with arrow key navigation + wrapping, participates in forms via ElementInternals (setFormValue, setValidity, formResetCallback), propagates disabled state, and has role="radiogroup" with aria-labelledby.</done>
</task>

<task type="auto">
  <name>Task 2: Update index.ts and jsx.d.ts to include RadioGroup</name>
  <files>
    packages/radio/src/index.ts
    packages/radio/src/jsx.d.ts
  </files>
  <action>
**Update index.ts** — Add RadioGroup registration alongside existing Radio registration (same pattern as checkbox index.ts which registers both lui-checkbox and lui-checkbox-group):

1. Add `export { RadioGroup } from './radio-group.js';`
2. Add `import { RadioGroup } from './radio-group.js';`
3. Add safe registration block for `lui-radio-group` (same pattern as lui-radio block)
4. Add `'lui-radio-group': RadioGroup` to `HTMLElementTagNameMap`

**Update jsx.d.ts** — Add lui-radio-group type declarations:

1. Add `LuiRadioGroupAttributes` interface with: `name?`, `value?`, `required?`, `disabled?`, `label?`, `error?`
2. Add React JSX: `'lui-radio-group': React.DetailedHTMLProps<React.HTMLAttributes<HTMLElement> & LuiRadioGroupAttributes, HTMLElement>`
3. Add Vue: `'lui-radio-group': import('vue').DefineComponent<LuiRadioGroupAttributes>`
4. Add Svelte: `'lui-radio-group': LuiRadioGroupAttributes & { 'on:ui-change'?: (e: CustomEvent) => void }`

Note: Svelte event for radio-group is `on:ui-change` (consumer-facing), not `on:ui-radio-change` (internal).

After updating both files, build the package:
```bash
cd packages/radio && npx vite build
```

Verify the build succeeds and produces dist/index.js and dist/index.d.ts.
  </action>
  <verify>
- Both elements registered: `grep 'lui-radio-group' packages/radio/src/index.ts`
- RadioGroup exported: `grep 'export.*RadioGroup' packages/radio/src/index.ts`
- JSX types: `grep 'lui-radio-group' packages/radio/src/jsx.d.ts`
- Build succeeds: `cd packages/radio && npx vite build`
- Output exists: `ls packages/radio/dist/index.js packages/radio/dist/index.d.ts`
  </verify>
  <done>Both lui-radio and lui-radio-group are safely registered in index.ts, JSX types cover both elements for React/Vue/Svelte, and the full package builds successfully.</done>
</task>

</tasks>

<verification>
1. `packages/radio/src/radio-group.ts` — RadioGroup with formAssociated, roving tabindex, mutual exclusion
2. `packages/radio/src/index.ts` — Both elements registered
3. `packages/radio/src/jsx.d.ts` — Both elements have JSX types
4. `cd packages/radio && npx vite build` succeeds
5. `ls packages/radio/dist/index.js packages/radio/dist/index.d.ts` — outputs exist
</verification>

<success_criteria>
- Mutual exclusion: setting group value checks one radio, unchecks all others
- Roving tabindex: only checked (or first enabled) radio has tabindex="0"
- Arrow keys move focus AND select with wrapping (modular arithmetic)
- Tab exits group entirely (single tab stop)
- Form participation: setFormValue with selected value, required validation, form reset
- Disabled propagation: group disabled -> all children disabled
- Screen reader: role="radiogroup" on group, role="radio" on children
- Package builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/40-radio-radiogroup/40-03-SUMMARY.md`
</output>
