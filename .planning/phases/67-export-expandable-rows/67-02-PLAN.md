---
phase: 67-export-expandable-rows
plan: 02
type: execute
wave: 2
depends_on: ["67-01"]
files_modified:
  - packages/data-table/src/expandable-rows.ts
  - packages/data-table/src/types.ts
  - packages/data-table/src/data-table.ts
  - packages/data-table/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Rows with expand toggle show a chevron button that toggles expansion"
    - "Expanded row displays developer-provided detail content below the data row"
    - "Detail content spans the full width of the table (not confined to a single cell)"
    - "Single-expand mode collapses other rows when a new row expands"
    - "Developer can control expanded state programmatically via the expanded property"
    - "Virtualizer correctly measures dynamic heights when rows expand/collapse"
  artifacts:
    - path: "packages/data-table/src/expandable-rows.ts"
      provides: "createExpandColumn factory, expandColumnStyles CSS, renderDetailPanel helper"
      min_lines: 50
    - path: "packages/data-table/src/types.ts"
      provides: "ExpandedChangeEvent type, DetailContentRenderer type alias"
      contains: "ExpandedChangeEvent"
    - path: "packages/data-table/src/data-table.ts"
      provides: "expanded state, renderDetailContent property, singleExpand property, virtualizer dynamic measurement, detail panel rendering in body"
      contains: "renderDetailContent"
    - path: "packages/data-table/src/index.ts"
      provides: "Re-exports for createExpandColumn and expandColumnStyles"
      contains: "expandable-rows"
  key_links:
    - from: "packages/data-table/src/data-table.ts"
      to: "packages/data-table/src/expandable-rows.ts"
      via: "import createExpandColumn, expandColumnStyles, renderDetailPanel"
      pattern: "expandable-rows"
    - from: "packages/data-table/src/data-table.ts"
      to: "@tanstack/lit-table getExpandedRowModel"
      via: "TanStack Table options enableExpanding + getExpandedRowModel"
      pattern: "getExpandedRowModel"
    - from: "packages/data-table/src/data-table.ts"
      to: "VirtualizerController measureElement"
      via: "Dynamic row height measurement when expanding enabled"
      pattern: "measureElement"
---

<objective>
Add expandable detail rows to the DataTable component with expand/collapse toggle, detail panel rendering, single-expand accordion mode, and controlled state support.

Purpose: Users need to view additional detail content for individual rows without navigating away from the table. This is essential for admin dashboards showing summary rows with expandable details (order items, user activity, audit logs, etc.).

Output: `expandable-rows.ts` module with expand column factory and detail panel helpers, type additions, full DataTable integration with virtualizer dynamic measurement.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/67-export-expandable-rows/67-RESEARCH.md
@.planning/phases/67-export-expandable-rows/67-01-SUMMARY.md
@packages/data-table/src/types.ts
@packages/data-table/src/data-table.ts
@packages/data-table/src/index.ts
@packages/data-table/src/selection-column.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create expandable-rows.ts module and add expand types to types.ts</name>
  <files>
    packages/data-table/src/expandable-rows.ts
    packages/data-table/src/types.ts
  </files>
  <action>
**In `types.ts`**, add a new section at the end headed `// Expandable Rows Types (EXPAND-*)`:

1. `DetailContentRenderer<TData extends RowData = RowData>` type alias:
   ```typescript
   /** Function that renders detail content for an expanded row */
   export type DetailContentRenderer<TData extends RowData = RowData> =
     (rowData: TData, row: import('@tanstack/lit-table').Row<TData>) => TemplateResult | typeof nothing;
   ```
   Note: Use the import type syntax since Row is already available from TanStack. Alternatively import `Row` at the top of types.ts from `@tanstack/lit-table` if cleaner. Check existing imports.

   Actually, `types.ts` currently imports only from `@tanstack/lit-table` for state types, not `Row`. Since adding a `Row` import would create a new dependency, instead define the type alias as:
   ```typescript
   export type DetailContentRenderer<TData extends RowData = RowData> =
     (rowData: TData, row: any) => import('lit').TemplateResult | typeof import('lit').nothing;
   ```
   Better approach: Since TemplateResult and nothing are already imported at the top of types.ts (TemplateResult is imported), and the `Row` type would be used loosely, define it simply as:
   ```typescript
   export type DetailContentRenderer<TData extends RowData = RowData> =
     (rowData: TData, row: any) => TemplateResult;
   ```
   The `row` parameter is typed as `any` for simplicity in the public API. Consumers can import `Row` from TanStack if they need strong typing.

2. `ExpandedChangeEvent` interface:
   ```typescript
   /** Event detail for expanded state change events */
   export interface ExpandedChangeEvent {
     /** Current expanded state (true = all expanded, or record of row IDs) */
     expanded: ExpandedState;
   }
   ```

**Create `expandable-rows.ts`** following the `selection-column.ts` factory pattern:

1. Imports:
   ```typescript
   import { html, css, nothing } from 'lit';
   import type { ColumnDef, RowData } from './types.js';
   import type { Table, Row } from '@tanstack/lit-table';
   ```

2. `createExpandColumn<TData extends RowData>(): ColumnDef<TData, unknown>` factory function:
   - Returns a column definition with `id: '_expand'`
   - `header: () => nothing` (no header content for expand column)
   - `cell: ({ row }: { row: Row<TData> })` renders:
     - If `!row.getCanExpand()` return `nothing`
     - Otherwise render a `<button>` with:
       - `type="button"`, `class="expand-toggle"`
       - `aria-expanded="${row.getIsExpanded()}"`
       - `aria-label="${row.getIsExpanded() ? 'Collapse row' : 'Expand row'}"`
       - `@click` handler: `e.stopPropagation(); row.toggleExpanded();`
       - Inside: SVG chevron-right icon (16x16, viewBox 0 0 24 24, `<polyline points="9 18 15 12 9 6">`, stroke="currentColor", stroke-width="2", fill="none")
       - The SVG has class `expand-icon ${row.getIsExpanded() ? 'expanded' : ''}`
   - `size: 40`, `minSize: 40`, `maxSize: 40`
   - `enableSorting: false`, `enableColumnFilter: false`, `enableResizing: false`

3. `expandColumnStyles` as a `css` tagged template (exported):
   ```css
   .expand-toggle {
     display: inline-flex;
     align-items: center;
     justify-content: center;
     width: 28px;
     height: 28px;
     border: none;
     background: transparent;
     border-radius: var(--ui-radius-sm, 0.25rem);
     cursor: pointer;
     color: var(--ui-data-table-header-text);
     padding: 0;
   }
   .expand-toggle:hover {
     background: var(--ui-data-table-row-hover-bg);
   }
   .expand-toggle:focus-visible {
     outline: 2px solid var(--ui-ring, #2563eb);
     outline-offset: -2px;
   }
   .expand-icon {
     transition: transform 0.15s ease;
   }
   .expand-icon.expanded {
     transform: rotate(90deg);
   }
   .detail-panel {
     padding: 1rem 1rem 1rem calc(1rem + 40px);
     border-top: 1px solid var(--ui-data-table-border-color);
     background: var(--ui-data-table-header-bg);
   }
   ```
   Note: The `padding-left` of `calc(1rem + 40px)` accounts for the expand column width, aligning detail content with data columns. If a selection column is also present, the DataTable rendering will handle additional indentation.

4. `renderDetailPanel<TData extends RowData>(row: Row<TData>, renderFn: (rowData: TData, row: Row<TData>) => any): TemplateResult` helper:
   ```typescript
   export function renderDetailPanel<TData extends RowData>(
     row: Row<TData>,
     renderFn: (rowData: TData, row: any) => any
   ) {
     return html`
       <div
         class="detail-panel"
         role="region"
         aria-label="Row ${row.id} details"
       >
         ${renderFn(row.original, row)}
       </div>
     `;
   }
   ```

5. Export: `createExpandColumn`, `expandColumnStyles`, `renderDetailPanel`.
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/data-table/tsconfig.json` - TypeScript compiles.
Verify `expandable-rows.ts` exports `createExpandColumn`, `expandColumnStyles`, `renderDetailPanel`.
Verify `types.ts` contains `DetailContentRenderer` and `ExpandedChangeEvent`.
  </verify>
  <done>
expandable-rows.ts contains createExpandColumn factory (matching selection-column.ts pattern), expandColumnStyles CSS, and renderDetailPanel helper. types.ts has DetailContentRenderer type alias and ExpandedChangeEvent interface. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate expanding into DataTable with virtualizer dynamic measurement</name>
  <files>
    packages/data-table/src/data-table.ts
    packages/data-table/src/index.ts
  </files>
  <action>
**In `data-table.ts`:**

1. **Add imports:**
   - `import { createExpandColumn, expandColumnStyles, renderDetailPanel } from './expandable-rows.js';`
   - Add `getExpandedRowModel` to the TanStack import: `import { ..., getExpandedRowModel } from '@tanstack/lit-table';`
   - Add `ExpandedState` to the types import (from `./types.js` -- it's already re-exported there from TanStack)
   - Add `DetailContentRenderer, ExpandedChangeEvent` to the types import

2. **Add properties** in a new section `// Expandable Rows (EXPAND-*)` after the bulk actions section:

   ```typescript
   /**
    * Function to render detail content for expanded rows (EXPAND-03).
    * When set, rows become expandable with a toggle button.
    * The function receives the row data and TanStack Row instance.
    */
   @property({ attribute: false })
   renderDetailContent?: DetailContentRenderer<TData>;

   /**
    * Current expanded state (EXPAND-05: controlled/uncontrolled pattern).
    * - `{}`: No rows expanded (default)
    * - `{ 'row-id': true }`: Specific rows expanded
    * - `true`: All rows expanded
    */
   @property({ type: Object })
   expanded: ExpandedState = {};

   /**
    * When true, only one row can be expanded at a time (EXPAND-04).
    * Expanding a new row automatically collapses the previous one.
    * @default false
    */
   @property({ type: Boolean, attribute: 'single-expand' })
   singleExpand = false;
   ```

3. **Update `getEffectiveColumns()`** to prepend expand column when `renderDetailContent` is set:
   ```typescript
   private getEffectiveColumns(): ColumnDef<TData, unknown>[] {
     const cols = [...this.columns];
     // Prepend expand column if expandable rows enabled
     if (this.renderDetailContent) {
       cols.unshift(createExpandColumn<TData>());
     }
     // Prepend selection column if selection enabled
     if (this.enableSelection) {
       cols.unshift(createSelectionColumn<TData>());
     }
     return cols;
   }
   ```
   Note: The expand column goes AFTER selection column (selection is first). Since both use `unshift`, expand is pushed first then selection pushes before it. This results in: [selection, expand, ...data columns]. This is the correct order.

4. **Update `initVirtualizer()`** to use `measureElement` when expanding is enabled:
   ```typescript
   private initVirtualizer(): void {
     if (isServer || this.data.length === 0) {
       this.virtualizer = undefined;
       return;
     }

     this.virtualizer = new VirtualizerController(this, {
       getScrollElement: () => this.scrollRef.value ?? null,
       count: this.data.length,
       estimateSize: () => this.rowHeight,
       overscan: DataTable.VIRTUALIZER_OVERSCAN,
       // Enable dynamic measurement when expandable rows are configured
       ...(this.renderDetailContent ? {
         measureElement: (el: Element) => {
           if (!el) return this.rowHeight;
           return el.getBoundingClientRect().height;
         },
       } : {}),
     });
   }
   ```

5. **Add single-expand enforcement method:**
   ```typescript
   private enforceSingleExpand(nextExpanded: ExpandedState): ExpandedState {
     if (nextExpanded === true) {
       // "Expand all" not meaningful in single-expand mode
       return this.expanded;
     }
     if (typeof nextExpanded !== 'object') return {};

     const prevKeys = this.expanded === true ? [] : Object.keys(this.expanded as Record<string, boolean>).filter(k => (this.expanded as Record<string, boolean>)[k]);
     const nextKeys = Object.keys(nextExpanded).filter(k => nextExpanded[k]);

     // Find the newly expanded row
     const newKey = nextKeys.find(k => !prevKeys.includes(k));
     if (newKey) {
       return { [newKey]: true };
     }
     // If no new key, a row was collapsed
     return nextExpanded;
   }
   ```

6. **Add `dispatchExpandedChange` method:**
   ```typescript
   private dispatchExpandedChange(expanded: ExpandedState): void {
     this.dispatchEvent(
       new CustomEvent<ExpandedChangeEvent>('ui-expanded-change', {
         detail: { expanded },
         bubbles: true,
         composed: true,
       })
     );
   }
   ```

7. **Update table options in `render()`:**
   Add to the `state` object:
   ```typescript
   expanded: this.expanded,
   ```

   Add table options (after the existing options like `manualPagination`):
   ```typescript
   // Expanding options (EXPAND-01 to EXPAND-05)
   ...(this.renderDetailContent ? {
     enableExpanding: true,
     getRowCanExpand: () => true,
     getExpandedRowModel: getExpandedRowModel(),
     onExpandedChange: (updater: any) => {
       const next = typeof updater === 'function' ? updater(this.expanded) : updater;
       this.expanded = this.singleExpand ? this.enforceSingleExpand(next) : next;
       this.dispatchExpandedChange(this.expanded);
     },
   } : {}),
   ```

8. **Update `renderVirtualizedBody()`** to wrap each virtual item in a wrapper div and render detail panels:
   - Change the virtual item rendering to wrap the row div and optional detail panel in a container:

   ```typescript
   // BEFORE (current):
   // <div role="row" ... style="position:absolute; transform:translateY(...)" >
   //   cells...
   //   actions...
   // </div>

   // AFTER (with expand support):
   // <div class="virtual-row-wrapper" data-index="..." style="position:absolute; transform:translateY(...)"
   //      ${this.renderDetailContent ? ref((el) => el && virtualizer.measureElement(el as Element)) : nothing}>
   //   <div role="row" ... style="grid-template-columns:...">
   //     cells...
   //     actions...
   //   </div>
   //   ${isExpanded && this.renderDetailContent ? renderDetailPanel(row, this.renderDetailContent) : nothing}
   // </div>
   ```

   Specifically, in the `virtualItems.map()` callback:
   - Add `const isExpanded = row.getIsExpanded();` (after existing row checks)
   - Wrap the existing `<div role="row" ...>` in a new outer `<div class="virtual-row-wrapper">` that holds the absolute positioning styles (move `position: absolute; top: 0; left: 0; width: 100%; transform: translateY(...)` from the role=row div to the wrapper)
   - The inner `<div role="row">` keeps: `grid-template-columns`, `aria-rowindex`, `aria-selected`, classes, `data-row-id`. Remove `position: absolute`, `top`, `left`, `width`, `transform` from it. Add `height: ${this.rowHeight}px` to the row div to maintain fixed data row height.
   - Remove `height: ${virtualRow.size}px` from the row div (the wrapper handles sizing now)
   - After the role=row div, add: `${isExpanded && this.renderDetailContent ? renderDetailPanel(row, this.renderDetailContent) : nothing}`
   - On the wrapper div, add: `data-index="${virtualRow.index}"` (needed by virtualizer for measurement)
   - When `this.renderDetailContent` is truthy, add a `${ref((el: Element | undefined) => el && virtualizer.measureElement(el))}` directive on the wrapper. When not truthy, omit it (fixed height mode).

9. **Update `renderAllRows()`** (SSR fallback) similarly:
   - Add expanded row support to the non-virtualized path too
   - After the row div, render detail panel if expanded:
   ```typescript
   ${row.getIsExpanded() && this.renderDetailContent
     ? renderDetailPanel(row, this.renderDetailContent)
     : nothing}
   ```
   - Wrap each row + detail in a container div for consistent layout

10. **Update `updated()` lifecycle** to re-initialize virtualizer when `renderDetailContent` changes (it affects the measureElement option):
    ```typescript
    if (changedProperties.has('data') || changedProperties.has('rowHeight') || changedProperties.has('renderDetailContent')) {
      this.initVirtualizer();
    }
    ```

11. **Update `getEffectiveColumns` call in `updated()`** column counting for keyboard navigation -- add `renderDetailContent` to the property watch list and account for expand column:
    ```typescript
    if (this.renderDetailContent) colCount += 1;
    ```
    Also add `changedProperties.has('renderDetailContent')` to the condition.

12. **Update static styles** to include `expandColumnStyles`:
    ```typescript
    static override styles = [
      ...tailwindBaseStyles,
      columnPickerStyles,
      inlineEditingStyles,
      cellRendererStyles,
      rowActionsStyles,
      bulkActionsStyles,
      expandColumnStyles,  // ADD THIS
      css`...`
    ];
    ```

13. **Add `@fires ui-expanded-change` to the class JSDoc** at the top.

**In `index.ts`:**

14. Add re-exports:
    ```typescript
    // Expandable rows (column factory + styles)
    export { createExpandColumn, expandColumnStyles, renderDetailPanel } from './expandable-rows.js';
    ```
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/data-table/tsconfig.json` - TypeScript compiles without errors.
Grep for `renderDetailContent` in data-table.ts (should appear in property, getEffectiveColumns, renderVirtualizedBody, renderAllRows, table options).
Grep for `singleExpand` in data-table.ts (should appear in property and enforceSingleExpand usage).
Grep for `expanded` in the table state object in render().
Grep for `measureElement` in initVirtualizer().
Grep for `expandable-rows` in index.ts.
Grep for `ui-expanded-change` in data-table.ts.
  </verify>
  <done>
DataTable has full expandable rows support:
- EXPAND-01: createExpandColumn factory renders chevron toggle, rows expand/collapse via row.toggleExpanded()
- EXPAND-02: Detail panel renders below data row in same virtual item wrapper, full width
- EXPAND-03: renderDetailContent property accepts template function with row data context
- EXPAND-04: singleExpand mode enforces accordion behavior via enforceSingleExpand interceptor
- EXPAND-05: expanded property enables controlled state, ui-expanded-change event for two-way binding
- Virtualizer uses measureElement for dynamic heights when expanding enabled
- Both virtualized and non-virtualized render paths support expanding
- Package re-exports createExpandColumn, expandColumnStyles, renderDetailPanel
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/data-table/tsconfig.json` passes
2. `expandable-rows.ts` exports `createExpandColumn`, `expandColumnStyles`, `renderDetailPanel`
3. `types.ts` exports `DetailContentRenderer` and `ExpandedChangeEvent`
4. `data-table.ts` has `renderDetailContent`, `expanded`, `singleExpand` properties
5. `data-table.ts` table options include `enableExpanding`, `getRowCanExpand`, `getExpandedRowModel`, `onExpandedChange`
6. `data-table.ts` initVirtualizer uses `measureElement` when `renderDetailContent` is set
7. `data-table.ts` renderVirtualizedBody wraps row+detail in wrapper div with measurement
8. `data-table.ts` enforceSingleExpand handles ExpandedState union type safely (checks `=== true`)
9. `data-table.ts` dispatches `ui-expanded-change` event on expand state changes
10. `index.ts` re-exports expand column utilities
11. Detail panel has full width, padding aligns with data columns
12. Expand toggle has proper ARIA: `aria-expanded`, `aria-label`, detail panel has `role="region"`
</verification>

<success_criteria>
- EXPAND-01: createExpandColumn renders chevron toggle with aria-expanded; clicking toggles row.getIsExpanded()
- EXPAND-02: Expanded row shows detail panel below main row within same virtual item
- EXPAND-03: renderDetailContent property accepts (rowData, row) => TemplateResult function
- EXPAND-04: singleExpand attribute enforces one-row-at-a-time accordion via enforceSingleExpand
- EXPAND-05: expanded property (ExpandedState) enables controlled mode, ui-expanded-change event fires on changes
- Virtualizer dynamically measures expanded rows via measureElement (no overlap/jump)
- Both virtualized and fallback render paths handle expanding
- Clean TypeScript compilation, no new warnings
</success_criteria>

<output>
After completion, create `.planning/phases/67-export-expandable-rows/67-02-SUMMARY.md`
</output>
