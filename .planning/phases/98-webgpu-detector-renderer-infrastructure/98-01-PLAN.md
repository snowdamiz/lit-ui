---
phase: 98-webgpu-detector-renderer-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/charts/package.json
  - packages/charts/src/shared/webgpu-device.ts
autonomous: true
requirements:
  - WEBGPU-03

must_haves:
  truths:
    - "webgpu-device.ts exists and exports acquireGpuDevice, getGpuDevice, releaseGpuDevice, and RendererTier"
    - "The GPUDevice singleton is idempotent — calling acquireGpuDevice twice with different adapters returns the same Promise"
    - "@webgpu/types is installed as a devDependency so GPUAdapter and GPUDevice are typed without TypeScript errors"
  artifacts:
    - path: "packages/charts/src/shared/webgpu-device.ts"
      provides: "GPUDevice singleton module with RendererTier type and HTMLElementEventMap augmentation"
      exports: ["acquireGpuDevice", "getGpuDevice", "releaseGpuDevice", "RendererTier"]
    - path: "packages/charts/package.json"
      provides: "Updated devDependencies with @webgpu/types"
      contains: "@webgpu/types"
  key_links:
    - from: "packages/charts/src/shared/webgpu-device.ts"
      to: "packages/charts/src/base/base-chart-element.ts"
      via: "named import of acquireGpuDevice and RendererTier"
      pattern: "acquireGpuDevice"
---

<objective>
Create the GPUDevice singleton module and install the @webgpu/types devDependency that provides TypeScript types for navigator.gpu, GPUAdapter, and GPUDevice.

Purpose: WEBGPU-03 requires all chart instances to share one GPUDevice. This module is the foundation — BaseChartElement (Plan 02) imports from here. Without it Plan 02 has no types or singleton to call.

Output: packages/charts/src/shared/webgpu-device.ts (new), packages/charts/package.json (updated with @webgpu/types devDep)
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/98-webgpu-detector-renderer-infrastructure/98-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @webgpu/types devDependency</name>
  <files>packages/charts/package.json</files>
  <action>
    Run the following command from the repository root to install @webgpu/types as a devDependency scoped to the charts package:

    ```
    pnpm add -D @webgpu/types@0.1.67 --filter @lit-ui/charts
    ```

    This installs the official W3C-maintained TypeScript ambient type package for navigator.gpu, GPUAdapter, GPUDevice, and GPUAdapterInfo. Install as devDependency only — zero runtime code, types are erased at compile time.

    Do NOT add @webgpu/types to the charts tsconfig.json "types" array. Instead, the webgpu-device.ts module (Task 2) will use a `/// <reference types="@webgpu/types" />` triple-slash directive to scope the types to only that file. This avoids any risk of conflicting with the base tsconfig's type resolution.

    After running pnpm, verify package.json has "@webgpu/types": "0.1.67" under devDependencies.
  </action>
  <verify>
    <automated>grep -r "@webgpu/types" /Users/sn0w/Documents/dev/lit-components/packages/charts/package.json</automated>
  </verify>
  <done>"@webgpu/types" appears in packages/charts/package.json devDependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create webgpu-device.ts GPUDevice singleton module</name>
  <files>packages/charts/src/shared/webgpu-device.ts</files>
  <action>
    Create packages/charts/src/shared/webgpu-device.ts with the following exact content:

    ```typescript
    /// <reference types="@webgpu/types" />
    /**
     * WebGPU Device Singleton — WEBGPU-03
     *
     * All chart instances share one GPUDevice to stay within browser device count limits.
     * Pattern mirrors canvas-core.ts's `let _registered = false` guard.
     *
     * Lifecycle:
     * - acquireGpuDevice(): called from BaseChartElement._detectRenderer() when WebGPU is available
     * - getGpuDevice(): called by Phase 101 renderer to obtain the shared device
     * - releaseGpuDevice(): called by Phase 101 disconnectedCallback() cleanup (stub in Phase 98)
     *
     * CRITICAL: Do NOT call requestDevice() more than once on the same GPUAdapter.
     * The WebGPU spec marks an adapter as "consumed" after its first requestDevice() call.
     * This module caches the Promise<GPUDevice> — not the adapter — so subsequent
     * acquireGpuDevice() calls with different adapters safely return the cached promise.
     */

    /** Active renderer tier — set on BaseChartElement.renderer after detection. */
    export type RendererTier = 'webgpu' | 'webgl' | 'canvas';

    declare global {
      interface HTMLElementEventMap {
        /**
         * WEBGPU-01: Fired by every chart instance during firstUpdated() once the
         * renderer tier has been determined. detail.renderer is one of RendererTier.
         * Always read renderer from this event — do not poll .renderer synchronously
         * before the event fires (the async GPU probe may not have resolved yet).
         */
        'renderer-selected': CustomEvent<{ renderer: RendererTier }>;
        /** Existing event — redeclared here for completeness alongside renderer-selected. */
        'webgl-unavailable': CustomEvent<{ reason: string }>;
      }
    }

    let _devicePromise: Promise<GPUDevice> | null = null;

    /**
     * WEBGPU-03: Acquire or reuse the page-scoped GPUDevice singleton.
     *
     * First call: calls adapter.requestDevice() and caches the Promise.
     * Subsequent calls: ignore the adapter argument and return the cached Promise.
     *
     * The adapter argument is only used on the first call. This means:
     * - Multiple chart instances each pass their own adapter
     * - Only the first adapter is ever used to create the device
     * - Subsequent adapters are discarded (they are NOT consumed by requestDevice)
     *
     * @param adapter - GPUAdapter obtained from navigator.gpu.requestAdapter()
     */
    export async function acquireGpuDevice(adapter: GPUAdapter): Promise<GPUDevice> {
      if (_devicePromise) return _devicePromise;
      // First call only — do NOT call requestDevice() again on any adapter
      _devicePromise = adapter.requestDevice();
      return _devicePromise;
    }

    /**
     * Returns the cached GPUDevice promise without creating one.
     * Returns null if acquireGpuDevice() has not been called yet.
     * Used by Phase 101 to access the shared device for WebGPU rendering.
     */
    export function getGpuDevice(): Promise<GPUDevice> | null {
      return _devicePromise;
    }

    /**
     * Resets the singleton so a new GPUDevice can be acquired on the next call.
     * Called by Phase 101's disconnectedCallback() cleanup when the last chart
     * instance is removed from the DOM (device.destroy() is Phase 101's responsibility).
     * Phase 98 exposes this stub — Phase 101 wires the actual teardown.
     */
    export function releaseGpuDevice(): void {
      _devicePromise = null;
    }
    ```

    Key implementation notes:
    - The `/// <reference types="@webgpu/types" />` directive scopes WebGPU types to this file only — no tsconfig.json modification needed
    - `_devicePromise` is module-level (not class field) — this is what makes it a true singleton shared across all imports
    - The `declare global` block augments HTMLElementEventMap so TypeScript knows the shape of `renderer-selected` events
    - `releaseGpuDevice()` is a stub for Phase 98; Phase 101 calls `device.destroy()` before calling this
    - Do NOT reference `navigator`, `window`, or any browser global at module top level — this file must be safe to import in Node.js/SSR (the globals are only used inside `acquireGpuDevice()` which is called from inside `firstUpdated()`)
  </action>
  <verify>
    <automated>cd /Users/sn0w/Documents/dev/lit-components && pnpm --filter @lit-ui/charts exec tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>webgpu-device.ts exists, exports RendererTier type and three functions (acquireGpuDevice, getGpuDevice, releaseGpuDevice), TypeScript compilation passes with no errors on the new file</done>
</task>

</tasks>

<verification>
1. `grep "@webgpu/types" packages/charts/package.json` — confirms devDependency installed
2. `ls packages/charts/src/shared/webgpu-device.ts` — file exists
3. `pnpm --filter @lit-ui/charts exec tsc --noEmit` — no TypeScript errors
4. The module exports: RendererTier (type), acquireGpuDevice (function), getGpuDevice (function), releaseGpuDevice (function)
5. No `navigator` or `window` references at module top level (only inside function bodies)
</verification>

<success_criteria>
- @webgpu/types installed as devDependency in packages/charts/package.json
- packages/charts/src/shared/webgpu-device.ts exists with all four exports
- TypeScript compiles without errors
- Module-level singleton variable (_devicePromise) ensures WEBGPU-03: all chart instances that call acquireGpuDevice() share one GPUDevice
</success_criteria>

<output>
After completion, create `.planning/phases/98-webgpu-detector-renderer-infrastructure/98-01-SUMMARY.md`
</output>
