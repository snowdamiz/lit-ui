---
phase: 98-webgpu-detector-renderer-infrastructure
plan: 02
type: execute
wave: 2
depends_on:
  - 98-01
files_modified:
  - packages/charts/src/base/base-chart-element.ts
  - packages/charts/src/index.ts
autonomous: true
requirements:
  - WEBGPU-01
  - WEBGPU-03

must_haves:
  truths:
    - "document.querySelector('lui-line-chart').renderer returns 'webgpu', 'webgl', or 'canvas' depending on browser capability with no exceptions thrown"
    - "The renderer-selected custom event fires on every chart instance during firstUpdated() with the correct renderer string in event.detail.renderer"
    - "A browser without WebGPU silently uses Canvas without console errors or visual breakage"
    - "A Next.js App Router SSR build with chart components imported completes without navigator is not defined or gpu is not defined errors"
    - "All chart instances on a page that support WebGPU share a single GPUDevice via the module-level singleton in webgpu-device.ts"
  artifacts:
    - path: "packages/charts/src/base/base-chart-element.ts"
      provides: "enableWebGpu property, renderer property, _detectRenderer() method, updated firstUpdated()"
      contains: "_detectRenderer"
    - path: "packages/charts/src/index.ts"
      provides: "RendererTier type export"
      contains: "RendererTier"
  key_links:
    - from: "packages/charts/src/base/base-chart-element.ts"
      to: "packages/charts/src/shared/webgpu-device.ts"
      via: "import of acquireGpuDevice and RendererTier"
      pattern: "acquireGpuDevice"
    - from: "packages/charts/src/base/base-chart-element.ts"
      to: "renderer-selected event"
      via: "dispatchCustomEvent(this, 'renderer-selected', { renderer: this.renderer })"
      pattern: "renderer-selected"
---

<objective>
Add WebGPU detection capability to BaseChartElement: the `enableWebGpu` opt-in attribute, the `renderer` readable property, and the `_detectRenderer()` async method that runs inside `firstUpdated()`. Export `RendererTier` from the package index.

Purpose: WEBGPU-01 requires every chart type to auto-detect WebGPU and expose the active renderer tier. Since all 8 concrete chart classes extend BaseChartElement, adding detection there propagates to all of them without touching individual chart files.

Output: Modified base-chart-element.ts with new WebGPU detection capability; updated index.ts exporting RendererTier
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/98-webgpu-detector-renderer-infrastructure/98-RESEARCH.md
@.planning/phases/98-webgpu-detector-renderer-infrastructure/98-01-SUMMARY.md

<interfaces>
<!-- Key contracts from Plan 01 output. Use these directly — no exploration needed. -->

From packages/charts/src/shared/webgpu-device.ts:
```typescript
/// <reference types="@webgpu/types" />

export type RendererTier = 'webgpu' | 'webgl' | 'canvas';

export async function acquireGpuDevice(adapter: GPUAdapter): Promise<GPUDevice>;
export function getGpuDevice(): Promise<GPUDevice> | null;
export function releaseGpuDevice(): void;
```

From packages/charts/src/base/base-chart-element.ts (EXISTING — relevant portions):
```typescript
import { html, css, isServer, type PropertyValues } from 'lit';
import { property } from 'lit/decorators.js';
import { TailwindElement, tailwindBaseStyles, dispatchCustomEvent } from '@lit-ui/core';

// Existing property:
@property({ type: Boolean, attribute: 'enable-gl' }) enableGl = false;
protected _webglUnavailable = false;

// Existing firstUpdated():
override async firstUpdated(_changed: PropertyValues): Promise<void> {
  if (isServer) return;
  await this.updateComplete;
  await this._maybeLoadGl();
  requestAnimationFrame(() => this._initChart());
}

// Existing WebGL probe:
private _isWebGLSupported(): boolean {
  if (typeof window === 'undefined') return false;
  try {
    const canvas = document.createElement('canvas');
    return !!(canvas.getContext('webgl2') || ...);
  } catch { return false; }
}

// Existing event dispatch:
dispatchCustomEvent(this, 'webgl-unavailable', { reason: '...' });
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WebGPU detection to BaseChartElement</name>
  <files>packages/charts/src/base/base-chart-element.ts</files>
  <action>
    Modify packages/charts/src/base/base-chart-element.ts to add the WebGPU detection capability. Make the following precise changes:

    **1. Add import at the top of the file (after existing imports):**
    ```typescript
    import { acquireGpuDevice, type RendererTier } from '../shared/webgpu-device.js';
    ```

    **2. Add two new public reactive properties after the existing `enableGl` property (around line 82):**
    ```typescript
    /**
     * WEBGPU-01: Opt-in attribute for WebGPU rendering.
     * When set, _detectRenderer() probes navigator.gpu during firstUpdated().
     * Without this attribute, detection fast-paths to WebGL/Canvas with no async GPU probe.
     * Mirrors the enable-gl opt-in pattern for echarts-gl.
     */
    @property({ type: Boolean, attribute: 'enable-webgpu' }) enableWebGpu = false;

    /**
     * WEBGPU-01: Active renderer tier — readable after the 'renderer-selected' event fires.
     * Defaults to 'canvas' (safe fallback). Async detection updates this value during
     * firstUpdated() after the GPU probe resolves. Do NOT read synchronously before the
     * 'renderer-selected' event — the value may still be the default 'canvas'.
     */
    renderer: RendererTier = 'canvas';
    ```

    Note: `renderer` does NOT use @property() — it is not a reactive Lit property, just a plain class field. Reading it after `renderer-selected` event is the documented contract.

    **3. Update `firstUpdated()` to call `_detectRenderer()` before `_maybeLoadGl()`:**
    ```typescript
    override async firstUpdated(_changed: PropertyValues): Promise<void> {
      if (isServer) return;

      await this.updateComplete;
      await this._detectRenderer();   // WEBGPU-01 + WEBGPU-03 — runs before GL load
      await this._maybeLoadGl();      // existing WebGL path unchanged

      // RAF ensures :host has been painted and has non-zero dimensions
      requestAnimationFrame(() => this._initChart());
    }
    ```

    **4. Add the `_detectRenderer()` protected method.** Place it immediately before the existing `_maybeLoadGl()` private method:
    ```typescript
    /**
     * WEBGPU-01 + WEBGPU-03: Detect the active renderer tier and fire 'renderer-selected'.
     *
     * Detection order:
     * 1. If isServer or navigator unavailable → canvas/webgl fallback (SSR safety)
     * 2. If enable-webgpu is NOT set → skip async GPU probe, use WebGL if available
     * 3. If navigator.gpu is available AND enable-webgpu is set → probe adapter
     * 4. If adapter acquired → call acquireGpuDevice() (WEBGPU-03 singleton) → renderer = 'webgpu'
     * 5. If adapter null → WebGL/Canvas fallback
     *
     * Always dispatches 'renderer-selected' at the end regardless of the tier selected.
     * Called from firstUpdated() before _maybeLoadGl().
     */
    protected async _detectRenderer(): Promise<void> {
      // Belt-and-suspenders: isServer covers Lit SSR; typeof navigator covers other Node environments.
      // Must check both because isServer is a compile-time Lit flag; typeof is a runtime guard.
      if (isServer || typeof navigator === 'undefined' || !navigator.gpu) {
        this.renderer = this._isWebGLSupported() ? 'webgl' : 'canvas';
        dispatchCustomEvent(this, 'renderer-selected', { renderer: this.renderer });
        return;
      }

      if (!this.enableWebGpu) {
        // WebGPU not requested — skip the async adapter probe entirely.
        // This avoids ~10-50ms async GPU startup overhead on charts that won't use WebGPU.
        this.renderer = this._isWebGLSupported() ? 'webgl' : 'canvas';
        dispatchCustomEvent(this, 'renderer-selected', { renderer: this.renderer });
        return;
      }

      // requestAdapter() resolves to null when no GPU adapter is available.
      // It NEVER rejects — null means no WebGPU, not an error. Always check for null.
      const adapter = await navigator.gpu.requestAdapter();
      if (!adapter) {
        this.renderer = this._isWebGLSupported() ? 'webgl' : 'canvas';
        dispatchCustomEvent(this, 'renderer-selected', { renderer: this.renderer });
        return;
      }

      // WEBGPU-03: Acquire (or reuse) the page-scoped singleton GPUDevice.
      // Multiple chart instances safely call this — only the first adapter is used.
      await acquireGpuDevice(adapter);
      this.renderer = 'webgpu';
      dispatchCustomEvent(this, 'renderer-selected', { renderer: this.renderer });
    }
    ```

    **Critical notes for this task:**
    - `_detectRenderer()` is `protected` (not private) so Phase 101's subclasses can override it if needed
    - `_isWebGLSupported()` already exists as a private method — call it directly, do NOT duplicate it
    - `dispatchCustomEvent` is already imported from `@lit-ui/core` — do NOT re-import it
    - `isServer` is already imported from `lit` — do NOT re-import it
    - Do NOT add `@property()` decorator to `renderer` — it should NOT trigger Lit reactive updates
    - The `typeof navigator === 'undefined'` check is belt-and-suspenders alongside `isServer`; keep both
    - Preserve ALL existing code unchanged — only add the new import, two new properties, and the new method; update `firstUpdated()` to add `await this._detectRenderer()` as the first await
  </action>
  <verify>
    <automated>cd /Users/sn0w/Documents/dev/lit-components && pnpm --filter @lit-ui/charts exec tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>base-chart-element.ts has enableWebGpu property, renderer field (RendererTier), and _detectRenderer() method; TypeScript compiles without errors; firstUpdated() calls _detectRenderer() before _maybeLoadGl()</done>
</task>

<task type="auto">
  <name>Task 2: Export RendererTier from package index</name>
  <files>packages/charts/src/index.ts</files>
  <action>
    Add a Phase 98 export block to packages/charts/src/index.ts. Append the following after the existing Phase 95 exports:

    ```typescript
    // Phase 98: WebGPU Detector + Renderer Infrastructure
    export type { RendererTier } from './shared/webgpu-device.js';
    ```

    This makes `RendererTier` available as a named type export from `@lit-ui/charts` so consumers can type their event listeners:

    ```typescript
    import type { RendererTier } from '@lit-ui/charts';

    chart.addEventListener('renderer-selected', (e: CustomEvent<{ renderer: RendererTier }>) => {
      console.log(e.detail.renderer); // 'webgpu' | 'webgl' | 'canvas'
    });
    ```

    Do NOT export `acquireGpuDevice`, `getGpuDevice`, or `releaseGpuDevice` from index.ts — those are internal infrastructure consumed by Phase 101. Only `RendererTier` is a public consumer-facing type.

    After adding the export, build the package to confirm the type is accessible:
    ```
    pnpm --filter @lit-ui/charts build
    ```

    If build fails, check that the import path uses `.js` extension (`.js` in TypeScript source = correct for ESM projects, even for `.ts` files).
  </action>
  <verify>
    <automated>cd /Users/sn0w/Documents/dev/lit-components && pnpm --filter @lit-ui/charts build 2>&1 | tail -20</automated>
  </verify>
  <done>index.ts exports RendererTier type; pnpm build completes without errors; dist/index.d.ts contains RendererTier type declaration</done>
</task>

</tasks>

<verification>
1. `grep "renderer" packages/charts/src/base/base-chart-element.ts` — confirms enableWebGpu property, renderer field, _detectRenderer method present
2. `grep "renderer-selected" packages/charts/src/base/base-chart-element.ts` — confirms event dispatch exists
3. `grep "acquireGpuDevice" packages/charts/src/base/base-chart-element.ts` — confirms import and usage in _detectRenderer
4. `grep "RendererTier" packages/charts/src/index.ts` — confirms type is re-exported
5. `pnpm --filter @lit-ui/charts exec tsc --noEmit` — zero TypeScript errors
6. `pnpm --filter @lit-ui/charts build` — dist/ built successfully
7. `grep "RendererTier" packages/charts/dist/index.d.ts` — confirms type appears in compiled output
</verification>

<success_criteria>
- BaseChartElement has `enableWebGpu` (Boolean attribute, defaults false) and `renderer` (RendererTier field, defaults 'canvas')
- `_detectRenderer()` is protected, async, SSR-safe (isServer + typeof navigator guard), dispatches renderer-selected event in every code path
- `firstUpdated()` calls `await this._detectRenderer()` before `await this._maybeLoadGl()`
- Without enable-webgpu attribute: renderer-selected fires immediately with 'webgl' or 'canvas' — no async GPU probe
- With enable-webgpu on WebGPU browser: renderer-selected fires with 'webgpu', acquireGpuDevice() called once
- With enable-webgpu on non-WebGPU browser: renderer-selected fires with 'webgl' or 'canvas', no errors
- Package build succeeds; RendererTier exported from @lit-ui/charts
</success_criteria>

<output>
After completion, create `.planning/phases/98-webgpu-detector-renderer-infrastructure/98-02-SUMMARY.md`
</output>
