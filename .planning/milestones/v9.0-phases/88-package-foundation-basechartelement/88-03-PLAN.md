---
phase: 88-package-foundation-basechartelement
plan: 03
type: execute
wave: 3
depends_on:
  - "88-01"
  - "88-02"
files_modified:
  - packages/charts/src/base/base-chart-element.ts
  - packages/charts/src/index.ts
autonomous: true
requirements:
  - INFRA-02
  - INFRA-03
  - CHART-01
  - CHART-02
  - CHART-03
  - CHART-04
  - CHART-05
  - STRM-01
  - STRM-02
  - STRM-03
  - STRM-04

must_haves:
  truths:
    - "BaseChartElement can be imported in a Next.js/Astro SSR context without window is not defined crash"
    - "Chart initializes ECharts after browser layout is complete (container has non-zero dimensions)"
    - "enable-gl attribute causes dynamic echarts-gl import; WebGL unavailable fires webgl-unavailable event and falls back to Canvas"
    - "Dark mode toggle on document.documentElement updates chart colors without page reload via MutationObserver"
    - "pushData(point) accumulates data and flushes exactly once per animation frame via requestAnimationFrame"
    - "Multiple pushData() calls within same animation frame batch into one ECharts update"
    - "Charts resize automatically when container dimensions change via ResizeObserver"
    - "disconnectedCallback() runs full disposal: loseContext → dispose → null → observers disconnected"
  artifacts:
    - path: "packages/charts/src/base/base-chart-element.ts"
      provides: "Abstract Lit base class for all chart components"
      exports: ["BaseChartElement"]
    - path: "packages/charts/src/index.ts"
      provides: "Package public API re-exports"
      exports: ["BaseChartElement", "ThemeBridge", "registerCanvasCore"]
  key_links:
    - from: "packages/charts/src/base/base-chart-element.ts"
      to: "packages/charts/src/base/theme-bridge.ts"
      via: "import ThemeBridge"
      pattern: "import.*ThemeBridge"
    - from: "packages/charts/src/base/base-chart-element.ts"
      to: "echarts/core"
      via: "dynamic import inside firstUpdated/initChart"
      pattern: "await import\\('echarts/core'\\)"
    - from: "packages/charts/src/base/base-chart-element.ts"
      to: "@lit-ui/core"
      via: "extends TailwindElement"
      pattern: "extends TailwindElement"
    - from: "packages/charts/src/base/base-chart-element.ts"
      to: "packages/charts/src/registry/canvas-core.ts"
      via: "_registerModules abstract method fulfilled by concrete charts"
      pattern: "abstract _registerModules"
---

<objective>
Implement BaseChartElement — the abstract Lit base class that all chart components in Phases 89-95 will extend. This class encapsulates every cross-cutting concern: SSR safety, ECharts lifecycle, ThemeBridge, dark mode MutationObserver, ResizeObserver, WebGL guard, streaming (pushData/RAF/circular buffer), loading state, and full disposal. Update index.ts to export the complete public API.

Purpose: All 5 critical pitfalls and all 14 Phase 88 requirements are resolved in this single abstract class. Phases 89-95 will extend this class — they never need to re-solve SSR, WebGL, theming, streaming, or disposal.
Output: packages/charts/src/base/base-chart-element.ts (production-ready abstract class) + packages/charts/src/index.ts (package exports).
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/88-package-foundation-basechartelement/88-RESEARCH.md
@.planning/phases/88-package-foundation-basechartelement/88-02-SUMMARY.md

<interfaces>
<!-- From @lit-ui/core/src/index.ts — imports available to BaseChartElement: -->
```typescript
export { TailwindElement, tailwindBaseStyles } from './tailwind-element.js';
export { isServer } from 'lit';
export { dispatchCustomEvent } from './utils/index.js';
```

<!-- TailwindElement base class — what BaseChartElement extends: -->
```typescript
export class TailwindElement extends LitElement {
  static override styles: CSSResultGroup = tailwindBaseStyles; // empty on client, inline CSS on SSR
  override connectedCallback(): void { /* adopts Tailwind sheets */ }
}
export const tailwindBaseStyles: CSSResultGroup[];  // isServer ? [css, hostDefaults] : []
```

<!-- From packages/charts/src/base/theme-bridge.ts (Plan 02 output): -->
```typescript
export class ThemeBridge {
  constructor(host: Element) {}
  readToken(name: string): string { /* getComputedStyle resolution */ }
  buildThemeObject(): object { /* full ECharts theme */ }
  buildColorUpdate(): { color: string[] } { /* incremental color-only update */ }
}
```

<!-- From packages/charts/src/registry/canvas-core.ts (Plan 02 output): -->
```typescript
export async function registerCanvasCore(): Promise<void> { /* registers CanvasRenderer + shared components */ }
```

<!-- ECharts type-only imports (safe for SSR — erased at compile time): -->
```typescript
import type { EChartsType, EChartsOption } from 'echarts/core';
// Do NOT use: import type * as EChartsTypes from 'echarts/core'
// Prefer named type imports for isolatedModules compatibility
```

<!-- CRITICAL PITFALL SUMMARY — all must be addressed in BaseChartElement: -->
// CRITICAL-01: echarts.init() must run inside requestAnimationFrame() after await updateComplete
// CRITICAL-02: loseContext() via WEBGL_lose_context extension BEFORE dispose() in disconnectedCallback
// CRITICAL-03: appendData and setOption are STRICTLY SEPARATE paths — setOption after appendData wipes all data
// CRITICAL-04: NEVER static import echarts — dynamic import inside firstUpdated() only
// CRITICAL-05: NEVER pass var(--token) to ECharts — ThemeBridge resolves all tokens via getComputedStyle
// MEDIUM-02: Check getInstanceByDom before echarts.init() to handle Chrome moveBefore() double-init
// MEDIUM-04: MutationObserver on document.documentElement watching class attribute for dark mode
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement BaseChartElement</name>
  <files>packages/charts/src/base/base-chart-element.ts</files>
  <action>
    Create `packages/charts/src/base/base-chart-element.ts`. This is the core deliverable of Phase 88.

    Implementation requirements by section:

    **Imports:**
    - `import { html, css, isServer, type PropertyValues } from 'lit';` — value import
    - `import { property } from 'lit/decorators.js';`
    - `import { TailwindElement, tailwindBaseStyles, dispatchCustomEvent } from '@lit-ui/core';`
    - `import { ThemeBridge } from './theme-bridge.js';`
    - `import type { EChartsType, EChartsOption } from 'echarts/core';` — TYPE ONLY, erased at compile time
    - NO `import * from 'echarts/core'` at the top level — this crashes SSR

    **Static styles (CRITICAL-05 + CRITICAL-01 fix):**
    ```typescript
    static override styles = [
      ...tailwindBaseStyles,
      css`
        :host {
          display: block;
          position: relative;
          width: 100%;
          height: var(--ui-chart-height, 300px);
        }
        #chart {
          position: absolute;
          inset: 0;
          width: 100%;
          height: 100%;
        }
      `,
    ];
    ```
    `:host { display: block; height: ... }` ensures non-zero dimensions before init (CRITICAL-01).

    **Properties:**
    - `@property({ attribute: false }) option?: EChartsOption` — CHART-02: raw ECharts option passthrough. attribute: false required — JSON.parse on large datasets is lossy.
    - `@property({ attribute: false }) data?: unknown` — CHART-01: data property. Typed as unknown; concrete classes narrow the type.
    - `@property({ type: Boolean }) loading = false` — CHART-04: loading skeleton toggle
    - `@property({ type: Boolean, attribute: 'enable-gl' }) enableGl = false` — INFRA-03: WebGL opt-in
    - `@property({ type: Number }) maxPoints = 1000` — STRM-02: circular buffer capacity

    **Protected and private fields:**
    - `protected _chart: EChartsType | null = null` — protected so concrete classes can call setOption
    - `protected _streamingMode: 'appendData' | 'buffer' = 'buffer'` — STRM-04: set by concrete chart class
    - `private _themeBridge = new ThemeBridge(this)`
    - `private _resizeObserver?: ResizeObserver`
    - `private _colorSchemeObserver?: MutationObserver`
    - `private _pendingData: unknown[] = []` — STRM-03: RAF batch accumulator
    - `private _circularBuffer: unknown[] = []` — STRM-04: rolling buffer for non-appendData charts
    - `private _rafId?: number` — STRM-03: pending RAF handle
    - `private _webglUnavailable = false`

    **Public methods:**
    ```typescript
    // CHART-03: Escape hatch for event binding and advanced use
    getChart(): EChartsType | undefined {
      return this._chart ?? undefined;
    }

    // STRM-01 + STRM-03: Public streaming API with RAF coalescing
    pushData(point: unknown): void {
      this._pendingData.push(point);
      if (this._rafId === undefined) {
        this._rafId = requestAnimationFrame(() => {
          this._flushPendingData();
          this._rafId = undefined;
        });
      }
    }
    ```

    **Abstract method:**
    ```typescript
    // Concrete chart classes register their ECharts chart modules here.
    // They call registerCanvasCore() plus their specific chart type module.
    // e.g., LineChart class imports and registers LineChart from echarts/charts
    protected abstract _registerModules(): Promise<void>;
    ```

    **render():**
    ```typescript
    override render() {
      return html`<div id="chart" part="chart"></div>`;
    }
    ```

    **firstUpdated() — SSR guard + init orchestration (CRITICAL-04):**
    ```typescript
    override async firstUpdated(_changed: PropertyValues): Promise<void> {
      // CRITICAL-04: firstUpdated() never fires during SSR.
      // isServer guard is belt-and-suspenders defense.
      if (isServer) return;

      await this.updateComplete;
      await this._maybeLoadGl();

      // CRITICAL-01: requestAnimationFrame ensures browser layout is complete
      // before echarts.init() reads container dimensions
      requestAnimationFrame(() => this._initChart());
    }
    ```

    **updated() — reactive property handling:**
    ```typescript
    override updated(changed: PropertyValues): void {
      if (!this._chart) return;

      if (changed.has('option') && this.option) {
        // CRITICAL-03: Only call setOption if NOT in appendData streaming mode
        // or if this is the initial configuration setOption (before streaming starts)
        this._chart.setOption(this.option);
      }

      if (changed.has('loading')) {
        this.loading ? this._chart.showLoading() : this._chart.hideLoading();
      }
    }
    ```

    **disconnectedCallback() — full disposal chain (CRITICAL-02):**
    ```typescript
    override disconnectedCallback(): void {
      super.disconnectedCallback();

      // 1. Cancel pending RAF
      if (this._rafId !== undefined) {
        cancelAnimationFrame(this._rafId);
        this._rafId = undefined;
      }

      // 2. Disconnect observers
      this._resizeObserver?.disconnect();
      this._resizeObserver = undefined;
      this._colorSchemeObserver?.disconnect();
      this._colorSchemeObserver = undefined;

      if (this._chart) {
        // 3. CRITICAL-02: Release WebGL GPU context BEFORE dispose()
        // dispose() alone does not release the GPU context promptly.
        // Browser limit: ~16 concurrent WebGL contexts.
        const dom = this._chart.getDom();
        if (dom) {
          const canvases = dom.getElementsByTagName('canvas');
          for (const canvas of Array.from(canvases)) {
            const gl =
              canvas.getContext('webgl2') ||
              (canvas.getContext as (ctx: string) => WebGLRenderingContext | null)('webgl');
            gl?.getExtension('WEBGL_lose_context')?.loseContext();
          }
        }

        // 4. Dispose + null — null prevents GC-retained JS reference
        this._chart.dispose();
        this._chart = null;
      }
    }
    ```

    **Private _initChart():**
    ```typescript
    private async _initChart(): Promise<void> {
      // Register chart type modules (implemented by concrete subclass)
      await this._registerModules();

      // Dynamic import — value import for init, getInstanceByDom
      const { init, getInstanceByDom } = await import('echarts/core');

      const container = this.shadowRoot?.querySelector<HTMLDivElement>('#chart');
      if (!container) return;

      // MEDIUM-02: Handle Chrome moveBefore() double-init scenario
      const existing = getInstanceByDom(container);
      if (existing) existing.dispose();

      const theme = this._themeBridge.buildThemeObject();
      this._chart = init(container, theme, { renderer: 'canvas' });

      // CHART-05: ResizeObserver on the inner container, not window.resize
      this._resizeObserver = new ResizeObserver(() => this._chart?.resize());
      this._resizeObserver.observe(container);

      // INFRA-04: Watch .dark class changes on <html> for dark mode updates
      this._colorSchemeObserver = new MutationObserver(() => this._applyThemeUpdate());
      this._colorSchemeObserver.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class'],
      });

      // Apply initial state
      if (this.option) this._chart.setOption(this.option);
      if (this.loading) this._chart.showLoading();
    }
    ```

    **Private _applyThemeUpdate() — incremental dark mode update:**
    ```typescript
    private _applyThemeUpdate(): void {
      if (!this._chart) return;
      // Incremental setOption with resolved color arrays — no dispose+reinit flicker
      // CRITICAL-03 note: This setOption call updates only colors, not series data.
      // For appendData charts: this must not touch series data or it wipes streamed data.
      const update = this._themeBridge.buildColorUpdate();
      this._chart.setOption(update);
    }
    ```

    **Private _flushPendingData() — STRM-03 + STRM-04:**
    ```typescript
    private _flushPendingData(): void {
      if (!this._chart || this._pendingData.length === 0) return;

      const points = this._pendingData.splice(0); // consume all pending

      if (this._streamingMode === 'appendData') {
        // STRM-04: appendData path for Line/Area charts
        // CRITICAL-03: NEVER call setOption after appendData has run on this series
        this._chart.appendData({ seriesIndex: 0, data: points });
      } else {
        // STRM-04: Circular buffer path for all other chart types
        this._circularBuffer.push(...points);
        if (this._circularBuffer.length > this.maxPoints) {
          this._circularBuffer = this._circularBuffer.slice(-this.maxPoints);
        }
        // lazyUpdate: true batches the render with other pending updates
        this._chart.setOption(
          { series: [{ data: this._circularBuffer }] },
          { lazyUpdate: true } as object
        );
      }
    }
    ```

    **Private _maybeLoadGl() — INFRA-03:**
    ```typescript
    private async _maybeLoadGl(): Promise<void> {
      if (!this.enableGl) return;

      if (!this._isWebGLSupported()) {
        this._webglUnavailable = true;
        // Dispatch event so host app can handle graceful degradation
        dispatchCustomEvent(this, 'webgl-unavailable', {
          reason: 'WebGL context unavailable in this environment',
        });
        // Fall through — chart will init without GL (Canvas renderer)
        return;
      }

      // Dynamic side-effect import — echarts-gl registers itself globally
      // Creates a separate bundle chunk; never in the main chart bundle
      await import('echarts-gl');
    }

    private _isWebGLSupported(): boolean {
      if (typeof window === 'undefined') return false;
      try {
        const canvas = document.createElement('canvas');
        return !!(
          canvas.getContext('webgl2') ||
          (canvas.getContext as (ctx: string) => WebGLRenderingContext | null)('webgl')
        );
      } catch {
        return false;
      }
    }
    ```

    **TypeScript open question resolution:** The research flags that `import type { EChartsType, EChartsOption }` from 'echarts/core' may require a static type import for IDE support with `isolatedModules: true`. Use named type imports (`import type { EChartsType, EChartsOption }`) rather than namespace imports (`import type * as EChartsTypes`). If TypeScript reports errors about types not available from named imports, check if `EChartsType` is the correct exported name — it may be `ECharts` (the instance type) and `EChartsOption`. Look at what `init()` returns from the dynamic import to determine the correct type name at implementation time.

    The `{ lazyUpdate: true } as object` cast is required because the ECharts setOption overload types may not include the option bag as a second argument. Use `as object` rather than `as any`.
  </action>
  <verify>
    <automated>ls /Users/sn0w/Documents/dev/lit-components/packages/charts/src/base/base-chart-element.ts && grep -c "abstract _registerModules" /Users/sn0w/Documents/dev/lit-components/packages/charts/src/base/base-chart-element.ts</automated>
  </verify>
  <done>packages/charts/src/base/base-chart-element.ts exists. Contains abstract class BaseChartElement extending TailwindElement. Has all required properties (option, data, loading, enableGl, maxPoints), public methods (getChart, pushData), abstract _registerModules(), and full lifecycle (firstUpdated, updated, disconnectedCallback). _streamingMode defaults to 'buffer'. RAF batching in pushData/_flushPendingData. Full disposal chain with loseContext in disconnectedCallback.</done>
</task>

<task type="auto">
  <name>Task 2: Wire index.ts exports and verify build</name>
  <files>packages/charts/src/index.ts</files>
  <action>
    Update `packages/charts/src/index.ts` to export the complete Phase 88 public API.

    Replace the placeholder comment from Plan 01 with:

    ```typescript
    // @lit-ui/charts — High-performance chart components with WebGL rendering,
    // real-time streaming, and CSS token theming built with Lit and ECharts

    export { BaseChartElement } from './base/base-chart-element.js';
    export { ThemeBridge } from './base/theme-bridge.js';
    export { registerCanvasCore } from './registry/canvas-core.js';

    // Re-export ECharts option type for consumers who need to type their option objects
    export type { EChartsOption } from 'echarts/core';
    ```

    Note: `.js` extensions required in ESM imports even for `.ts` source files — this is the existing project convention (see data-table/src/index.ts pattern).

    After updating index.ts, run the build to verify everything compiles:

    ```bash
    cd /Users/sn0w/Documents/dev/lit-components/packages/charts && pnpm build
    ```

    Expected output: `dist/index.js` and `dist/index.d.ts` produced without TypeScript errors.

    Common issues to fix:
    1. `EChartsType` may not exist as a named export — check what `echarts/core` exports. The instance type may be `ECharts` (interface) or accessed as `ReturnType<typeof init>`. Use `ReturnType<typeof import('echarts/core').init>` style if needed.
    2. `dispatchCustomEvent` signature — check what @lit-ui/core's dispatchCustomEvent accepts. It likely accepts `(element, eventName, detail?)`. Match the call signature in _maybeLoadGl().
    3. If `import('echarts-gl')` causes a TypeScript error about missing types — add `// @ts-ignore` on that line only. Do not suppress other errors. Defer type investigation to Phase 92 as per research recommendation.
    4. If `{ lazyUpdate: true }` second arg to setOption causes type errors — cast as `object` (already specified above).

    After build succeeds, verify the dist output:
    ```bash
    ls /Users/sn0w/Documents/dev/lit-components/packages/charts/dist/
    ```
  </action>
  <verify>
    <automated>cd /Users/sn0w/Documents/dev/lit-components/packages/charts && pnpm build 2>&1 | tail -5 && ls dist/index.js dist/index.d.ts</automated>
  </verify>
  <done>packages/charts/src/index.ts exports BaseChartElement, ThemeBridge, registerCanvasCore, and EChartsOption type. `pnpm build` in packages/charts/ succeeds with no TypeScript errors. dist/index.js and dist/index.d.ts exist and are non-empty.</done>
</task>

</tasks>

<verification>
1. `packages/charts/src/base/base-chart-element.ts` contains abstract class `BaseChartElement extends TailwindElement`
2. No static top-level `import ... from 'echarts'` or `import ... from 'echarts/core'` (only `import type` and dynamic `await import()`)
3. `firstUpdated()` has `if (isServer) return` guard
4. `firstUpdated()` wraps `_initChart()` in `requestAnimationFrame()`
5. `disconnectedCallback()` calls `loseContext()` before `dispose()` and nulls `_chart`
6. `pushData()` accumulates to `_pendingData` and schedules RAF — not immediate ECharts call
7. `_flushPendingData()` routes to `appendData` or circular buffer based on `_streamingMode`
8. `_streamingMode` is `protected` so concrete chart classes can set it to `'appendData'` or `'buffer'`
9. `packages/charts/src/index.ts` exports `BaseChartElement`, `ThemeBridge`, `registerCanvasCore`
10. `pnpm build` in `packages/charts/` produces `dist/index.js` and `dist/index.d.ts`
</verification>

<success_criteria>
Phase 88 is complete when:
- Developer can `import { BaseChartElement } from '@lit-ui/charts'` in a TypeScript project
- A concrete class `class MyChart extends BaseChartElement { protected async _registerModules() { ... } }` compiles cleanly
- The package builds to dist/ with no TypeScript errors
- All 14 requirements (INFRA-01 through STRM-04) are implemented in the base class — Phases 89-95 can extend without re-solving any cross-cutting concern
</success_criteria>

<output>
After completion, create `.planning/phases/88-package-foundation-basechartelement/88-03-SUMMARY.md`
</output>
