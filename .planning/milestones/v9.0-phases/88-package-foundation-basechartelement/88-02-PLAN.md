---
phase: 88-package-foundation-basechartelement
plan: 02
type: execute
wave: 2
depends_on:
  - "88-01"
files_modified:
  - packages/charts/src/base/theme-bridge.ts
  - packages/charts/src/registry/canvas-core.ts
autonomous: true
requirements:
  - INFRA-04
  - INFRA-05

must_haves:
  truths:
    - "ThemeBridge reads all 16 --ui-chart-* CSS tokens via getComputedStyle and returns resolved string values (never var() strings)"
    - "ThemeBridge buildThemeObject() returns a complete ECharts theme with color array, axis, tooltip, and legend objects"
    - "registerCanvasCore() registers CanvasRenderer and shared ECharts components exactly once (guarded by _registered flag)"
  artifacts:
    - path: "packages/charts/src/base/theme-bridge.ts"
      provides: "CSS token → ECharts theme object bridge"
      exports: ["ThemeBridge"]
    - path: "packages/charts/src/registry/canvas-core.ts"
      provides: "ECharts module registration for canvas rendering"
      exports: ["registerCanvasCore"]
  key_links:
    - from: "packages/charts/src/base/theme-bridge.ts"
      to: "getComputedStyle(host).getPropertyValue()"
      via: "CSS token resolution"
      pattern: "getComputedStyle.*getPropertyValue"
    - from: "packages/charts/src/registry/canvas-core.ts"
      to: "echarts/core"
      via: "dynamic import inside async function"
      pattern: "await import\\('echarts/core'\\)"
---

<objective>
Create two utility files: ThemeBridge (CSS token → ECharts theme resolution) and registerCanvasCore (ECharts module registration). These are pure utilities with no cross-dependency — they can be written and verified independently.

Purpose: ThemeBridge solves CRITICAL-05 (Canvas cannot evaluate CSS var()). canvas-core.ts solves tree-shaking — only the modules registered here are bundled per chart type.
Output: Two source files ready to be imported by BaseChartElement in Plan 03.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/88-package-foundation-basechartelement/88-RESEARCH.md

<interfaces>
<!-- From @lit-ui/core/src/index.ts: -->
```typescript
export { TailwindElement, tailwindBaseStyles } from './tailwind-element.js';
export { isServer } from 'lit';
export { dispatchCustomEvent, hasConstructableStylesheets } from './utils/index.js';
```

<!-- The full --ui-chart-* CSS token set for INFRA-05: -->
Token names and their fallback values:
- --ui-chart-color-1: '#3b82f6'
- --ui-chart-color-2: '#8b5cf6'
- --ui-chart-color-3: '#10b981'
- --ui-chart-color-4: '#f59e0b'
- --ui-chart-color-5: '#ef4444'
- --ui-chart-color-6: '#06b6d4'
- --ui-chart-color-7: '#f97316'
- --ui-chart-color-8: '#84cc16'
- --ui-chart-grid-line: '#e5e7eb'
- --ui-chart-axis-label: '#6b7280'
- --ui-chart-axis-line: '#d1d5db'
- --ui-chart-tooltip-bg: '#ffffff'
- --ui-chart-tooltip-border: '#e5e7eb'
- --ui-chart-tooltip-text: '#111827'
- --ui-chart-legend-text: '#374151'
- --ui-chart-font-family: 'system-ui, sans-serif'
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ThemeBridge</name>
  <files>packages/charts/src/base/theme-bridge.ts</files>
  <action>
    Create `packages/charts/src/base/theme-bridge.ts` with the ThemeBridge class.

    The ThemeBridge takes an Element reference (the chart host element) and uses `getComputedStyle` to resolve CSS custom properties. This is the ONLY correct approach — ECharts Canvas 2D API does not evaluate `var()` strings (see CRITICAL-05 in research).

    ```typescript
    /**
     * ThemeBridge — resolves CSS custom properties into ECharts-compatible theme objects.
     *
     * ECharts Canvas 2D API does not evaluate CSS custom properties (var()).
     * All token values must be pre-resolved via getComputedStyle before being
     * passed to ECharts option objects. This class centralizes that resolution.
     *
     * INFRA-04: Rebuilding theme on .dark class toggle updates chart colors.
     * INFRA-05: All --ui-chart-* tokens are read and fallbacks applied.
     */
    export class ThemeBridge {
      private readonly _tokenDefaults: Record<string, string> = {
        '--ui-chart-color-1': '#3b82f6',
        '--ui-chart-color-2': '#8b5cf6',
        '--ui-chart-color-3': '#10b981',
        '--ui-chart-color-4': '#f59e0b',
        '--ui-chart-color-5': '#ef4444',
        '--ui-chart-color-6': '#06b6d4',
        '--ui-chart-color-7': '#f97316',
        '--ui-chart-color-8': '#84cc16',
        '--ui-chart-grid-line': '#e5e7eb',
        '--ui-chart-axis-label': '#6b7280',
        '--ui-chart-axis-line': '#d1d5db',
        '--ui-chart-tooltip-bg': '#ffffff',
        '--ui-chart-tooltip-border': '#e5e7eb',
        '--ui-chart-tooltip-text': '#111827',
        '--ui-chart-legend-text': '#374151',
        '--ui-chart-font-family': 'system-ui, sans-serif',
      };

      constructor(private readonly host: Element) {}

      /**
       * Read a single CSS token, falling back to the default if unset.
       * CRITICAL: Never pass the token name itself to ECharts — always resolve it here.
       */
      readToken(name: string): string {
        const fallback = this._tokenDefaults[name] ?? '';
        return getComputedStyle(this.host).getPropertyValue(name).trim() || fallback;
      }

      /**
       * Build a complete ECharts theme object with all resolved token values.
       * Called at chart init and again whenever .dark class toggles on <html>.
       */
      buildThemeObject(): object {
        return {
          color: Array.from({ length: 8 }, (_, i) =>
            this.readToken(`--ui-chart-color-${i + 1}`)
          ),
          backgroundColor: 'transparent',
          textStyle: {
            fontFamily: this.readToken('--ui-chart-font-family'),
            color: this.readToken('--ui-chart-axis-label'),
          },
          grid: {
            borderColor: this.readToken('--ui-chart-grid-line'),
          },
          categoryAxis: {
            axisLine: { lineStyle: { color: this.readToken('--ui-chart-axis-line') } },
            axisLabel: { color: this.readToken('--ui-chart-axis-label') },
          },
          valueAxis: {
            axisLine: { lineStyle: { color: this.readToken('--ui-chart-axis-line') } },
            axisLabel: { color: this.readToken('--ui-chart-axis-label') },
            splitLine: { lineStyle: { color: this.readToken('--ui-chart-grid-line') } },
          },
          tooltip: {
            backgroundColor: this.readToken('--ui-chart-tooltip-bg'),
            borderColor: this.readToken('--ui-chart-tooltip-border'),
            textStyle: { color: this.readToken('--ui-chart-tooltip-text') },
          },
          legend: {
            textStyle: { color: this.readToken('--ui-chart-legend-text') },
          },
        };
      }

      /**
       * Build only the color update payload — used for incremental dark mode updates.
       * Cheaper than rebuilding the full theme object.
       */
      buildColorUpdate(): { color: string[] } {
        return {
          color: Array.from({ length: 8 }, (_, i) =>
            this.readToken(`--ui-chart-color-${i + 1}`)
          ),
        };
      }
    }
    ```

    Dark mode implementation note: `buildThemeObject()` is called at init and passed to `echarts.init()` as the theme argument. When the `.dark` class is toggled, `buildThemeObject()` is called again and the result passed to `setOption()`. This approach avoids the dispose+reinit flicker (research open question 3 recommendation).
  </action>
  <verify>
    <automated>cd /Users/sn0w/Documents/dev/lit-components && node -e "import('./packages/charts/src/base/theme-bridge.ts').catch(e => console.log('file exists, ts check needed'))" 2>/dev/null; ls packages/charts/src/base/theme-bridge.ts</automated>
  </verify>
  <done>packages/charts/src/base/theme-bridge.ts exists and exports ThemeBridge class. Class has readToken(), buildThemeObject(), and buildColorUpdate() methods. All 16 --ui-chart-* token defaults are defined.</done>
</task>

<task type="auto">
  <name>Task 2: Create canvas-core registry</name>
  <files>packages/charts/src/registry/canvas-core.ts</files>
  <action>
    Create `packages/charts/src/registry/canvas-core.ts` with the `registerCanvasCore()` function.

    This function registers shared ECharts components (CanvasRenderer, Tooltip, Grid, Legend, Label, Transition) exactly once using a `_registered` guard. Each concrete chart component calls this from its `_registerModules()` override before calling `echarts.init()`.

    CRITICAL: All imports inside this function must use dynamic `await import()` — NOT static top-level imports. Static top-level imports from echarts/ crash SSR at module evaluation time (CRITICAL-04).

    ```typescript
    /**
     * Canvas Core Registry — registers shared ECharts components for Canvas rendering.
     *
     * Called by each concrete chart component's _registerModules() before echarts.init().
     * Guard ensures registration runs exactly once across all chart instances.
     *
     * CRITICAL: All echarts imports are dynamic (await import) — static imports crash SSR.
     * Tree-shaking: Only registered components are included in the bundle.
     */

    let _registered = false;

    export async function registerCanvasCore(): Promise<void> {
      if (_registered) return;
      _registered = true;

      // Dynamic imports — required for SSR safety (CRITICAL-04)
      // These run client-side only since registerCanvasCore() is called from firstUpdated()
      const [
        { use },
        { CanvasRenderer },
        {
          TitleComponent,
          TooltipComponent,
          GridComponent,
          LegendComponent,
          DataZoomComponent,
          MarkLineComponent,
          MarkAreaComponent,
          ToolboxComponent,
        },
        { LabelLayout, UniversalTransition },
      ] = await Promise.all([
        import('echarts/core'),
        import('echarts/renderers'),
        import('echarts/components'),
        import('echarts/features'),
      ]);

      use([
        CanvasRenderer,
        TitleComponent,
        TooltipComponent,
        GridComponent,
        LegendComponent,
        DataZoomComponent,
        MarkLineComponent,
        MarkAreaComponent,
        ToolboxComponent,
        LabelLayout,
        UniversalTransition,
      ]);
    }
    ```

    Note: `DataZoomComponent`, `MarkLineComponent`, `MarkAreaComponent`, and `ToolboxComponent` are included in the shared canvas-core because they are used by multiple chart types (Line, Bar, Candlestick). Including them here avoids re-registering per chart type. Individual chart types will register their own chart-specific modules (e.g., `LineChart`, `BarChart`) in their own `_registerModules()` override alongside calling `registerCanvasCore()`.
  </action>
  <verify>
    <automated>ls /Users/sn0w/Documents/dev/lit-components/packages/charts/src/registry/canvas-core.ts && grep -c "registerCanvasCore" /Users/sn0w/Documents/dev/lit-components/packages/charts/src/registry/canvas-core.ts</automated>
  </verify>
  <done>packages/charts/src/registry/canvas-core.ts exists. Exports `registerCanvasCore` async function. All echarts imports are dynamic (no static top-level echarts imports). _registered guard prevents double-registration.</done>
</task>

</tasks>

<verification>
1. `packages/charts/src/base/theme-bridge.ts` exports `ThemeBridge` class
2. `ThemeBridge.readToken()` uses `getComputedStyle(this.host).getPropertyValue(name).trim()` — no `var()` strings passed to ECharts
3. `ThemeBridge.buildThemeObject()` returns object with `color[]` (8 items), `grid`, `tooltip`, `legend`, `categoryAxis`, `valueAxis`
4. `packages/charts/src/registry/canvas-core.ts` exports `registerCanvasCore()` async function
5. All imports inside `registerCanvasCore()` are dynamic `await import()` — no top-level echarts imports
6. `_registered` guard ensures `use()` is called exactly once
</verification>

<success_criteria>
ThemeBridge is ready to be imported by BaseChartElement. registerCanvasCore() is ready to be called from concrete chart component _registerModules() overrides. Both files TypeScript-compile cleanly as part of the package build.
</success_criteria>

<output>
After completion, create `.planning/phases/88-package-foundation-basechartelement/88-02-SUMMARY.md`
</output>
