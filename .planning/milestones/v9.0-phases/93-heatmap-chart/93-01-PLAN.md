---
phase: 93-heatmap-chart
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/charts/src/shared/heatmap-option-builder.ts
  - packages/charts/src/heatmap/heatmap-registry.ts
autonomous: true
requirements:
  - HEAT-01
  - HEAT-02

must_haves:
  truths:
    - "buildHeatmapOption() returns a valid ECharts option with category xAxis/yAxis, visualMap (continuous), and heatmap series"
    - "registerHeatmapModules() registers HeatmapChart + VisualMapContinuousComponent via ECharts use()"
    - "HeatmapCell type is exported as [number, number, number] tuple (xIdx, yIdx, value)"
    - "HeatmapOptionProps type is exported with xCategories, yCategories, colorRange, min, max fields"
  artifacts:
    - path: "packages/charts/src/shared/heatmap-option-builder.ts"
      provides: "HeatmapCell type, HeatmapOptionProps type, buildHeatmapOption() function"
      exports: ["HeatmapCell", "HeatmapOptionProps", "buildHeatmapOption"]
    - path: "packages/charts/src/heatmap/heatmap-registry.ts"
      provides: "registerHeatmapModules() with _heatmapRegistered guard"
      exports: ["registerHeatmapModules"]
  key_links:
    - from: "packages/charts/src/heatmap/heatmap-registry.ts"
      to: "echarts/charts (HeatmapChart)"
      via: "dynamic import + use()"
      pattern: "HeatmapChart.*VisualMapContinuousComponent"
    - from: "packages/charts/src/shared/heatmap-option-builder.ts"
      to: "ECharts visualMap config"
      via: "buildHeatmapOption return value"
      pattern: "type.*continuous.*inRange.*color"
---

<objective>
Create heatmap foundations: the option builder (types + buildHeatmapOption) and the ECharts module registry (registerHeatmapModules).

Purpose: These two files are the contracts and registration layer that LuiHeatmapChart (Plan 02) builds against. Plan 02 cannot proceed until these exist.
Output: heatmap-option-builder.ts (HeatmapCell, HeatmapOptionProps, buildHeatmapOption) + heatmap-registry.ts (registerHeatmapModules with HeatmapChart + VisualMapContinuousComponent).
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/93-heatmap-chart/93-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From packages/charts/src/shared/pie-option-builder.ts (mirror this pattern):
```typescript
export type PieSlice = { name: string; value: number; };
export type PieOptionProps = { minPercent?: number; innerRadius?: string | number; centerLabel?: string; };
export function buildPieOption(slices: PieSlice[], props: PieOptionProps): Record<string, unknown>
```

From packages/charts/src/pie/pie-registry.ts (mirror this pattern):
```typescript
let _pieRegistered = false;
export async function registerPieModules(): Promise<void> {
  if (_pieRegistered) return;
  _pieRegistered = true;
  const { registerCanvasCore } = await import('../registry/canvas-core.js');
  await registerCanvasCore();
  const [{ PieChart }, { use }] = await Promise.all([import('echarts/charts'), import('echarts/core')]);
  use([PieChart]);
}
```

From packages/charts/src/base/base-chart-element.ts:
```typescript
export type { EChartsCoreOption as EChartsOption };
export abstract class BaseChartElement extends TailwindElement {
  protected _chart: EChartsType | null = null;
  protected _streamingMode: 'appendData' | 'buffer' = 'buffer';
  pushData(point: unknown): void;  // public, overridable
  protected abstract _registerModules(): Promise<void>;
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create heatmap-option-builder.ts (HeatmapCell, HeatmapOptionProps, buildHeatmapOption)</name>
  <files>packages/charts/src/shared/heatmap-option-builder.ts</files>
  <action>
Create `packages/charts/src/shared/heatmap-option-builder.ts` with the following exact content:

**Types to export:**
```typescript
export type HeatmapCell = [number, number, number]; // [xIdx, yIdx, value]

export type HeatmapOptionProps = {
  xCategories: string[];
  yCategories: string[];
  // Two-color gradient endpoints [minColor, maxColor]. Defaults: ['#313695', '#d73027'] (blue-to-red).
  colorRange?: [string, string];
  // VisualMap value domain. Defaults: [0, 100]. Pin these to prevent color drift during streaming (Pitfall 6).
  min?: number;
  max?: number;
};
```

**buildHeatmapOption function:**
- Parameters: `data: HeatmapCell[], props: HeatmapOptionProps`
- Return type: `Record<string, unknown>`
- Extract `[minColor, maxColor]` from `props.colorRange ?? ['#313695', '#d73027']`
- Extract `minVal = props.min ?? 0` and `maxVal = props.max ?? 100`
- Return an object with:
  - `grid: { containLabel: true }`
  - `xAxis: { type: 'category', data: props.xCategories, splitArea: { show: true } }`
  - `yAxis: { type: 'category', data: props.yCategories, splitArea: { show: true } }`
  - `visualMap: { type: 'continuous', min: minVal, max: maxVal, calculable: true, orient: 'horizontal', left: 'center', bottom: '5%', inRange: { color: [minColor, maxColor] } }`
  - `tooltip: { trigger: 'item' }`
  - `series: [{ type: 'heatmap', coordinateSystem: 'cartesian2d', data, label: { show: false }, emphasis: { itemStyle: { shadowBlur: 10, shadowColor: 'rgba(0,0,0,0.5)' } } }]`

**Critical notes:**
- `splitArea: { show: true }` on BOTH axes — creates visible cell border grid (omitting causes cells to blend without borders)
- `type: 'category'` on BOTH axes — NOT `type: 'value'` (heatmap indices are integer positions into category arrays)
- `coordinateSystem: 'cartesian2d'` on series — explicitly required for Cartesian heatmap (vs geo/calendar)
- `visualMap.min` and `visualMap.max` MUST be set explicitly — auto-range causes color drift during pushData() streaming (Pitfall 6 from RESEARCH.md)
- `inRange.color` receives `string[]` in practice despite ECharts TS types declaring `ColorString` — `Record<string, unknown>` return avoids type friction
  </action>
  <verify>
    <automated>cd /Users/sn0w/Documents/dev/lit-components && pnpm --filter @lit-ui/charts exec tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>File exists at packages/charts/src/shared/heatmap-option-builder.ts, exports HeatmapCell, HeatmapOptionProps, buildHeatmapOption, TypeScript compiles with zero errors</done>
</task>

<task type="auto">
  <name>Task 2: Create heatmap-registry.ts (registerHeatmapModules with HeatmapChart + VisualMapContinuousComponent)</name>
  <files>packages/charts/src/heatmap/heatmap-registry.ts</files>
  <action>
Create directory `packages/charts/src/heatmap/` if it does not exist.

Create `packages/charts/src/heatmap/heatmap-registry.ts`:

```typescript
/**
 * Heatmap chart ECharts module registry.
 *
 * Called by LuiHeatmapChart._registerModules() during chart initialization.
 * HeatmapChart and VisualMapContinuousComponent are NOT in canvas-core.ts — they must be registered here.
 *
 * CRITICAL: VisualMapContinuousComponent MUST be registered. If omitted, the visualMap key
 * in the ECharts option is silently ignored — no color legend appears, no error thrown.
 *
 * _heatmapRegistered guard prevents double-registration when multiple LuiHeatmapChart
 * instances are on the same page.
 */

let _heatmapRegistered = false;

export async function registerHeatmapModules(): Promise<void> {
  if (_heatmapRegistered) return;
  _heatmapRegistered = true;

  const { registerCanvasCore } = await import('../registry/canvas-core.js');
  await registerCanvasCore();

  const [{ HeatmapChart }, { VisualMapContinuousComponent }, { use }] = await Promise.all([
    import('echarts/charts'),
    import('echarts/components'),
    import('echarts/core'),
  ]);

  use([HeatmapChart, VisualMapContinuousComponent]);
}
```

**Critical notes:**
- Register `VisualMapContinuousComponent` (NOT `VisualMapComponent`) — use the specific continuous component for smaller bundle; heatmap always uses continuous VisualMap
- Do NOT use `VisualMapComponent` (it's a meta-installer registering BOTH continuous AND piecewise, inflating the bundle unnecessarily)
- `registerCanvasCore()` must be called first (before HeatmapChart registration) — it registers GridComponent which is required for Cartesian heatmap coordinate system
- Guard pattern `_heatmapRegistered` mirrors `_pieRegistered` in pie-registry.ts exactly
- Import path uses `.js` extension (required for ESM resolution in this project)
  </action>
  <verify>
    <automated>cd /Users/sn0w/Documents/dev/lit-components && pnpm --filter @lit-ui/charts exec tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>File exists at packages/charts/src/heatmap/heatmap-registry.ts, exports registerHeatmapModules, TypeScript compiles with zero errors</done>
</task>

</tasks>

<verification>
After both tasks:
1. `pnpm --filter @lit-ui/charts exec tsc --noEmit` — zero TypeScript errors
2. `grep -r "HeatmapCell\|HeatmapOptionProps\|buildHeatmapOption" packages/charts/src/shared/heatmap-option-builder.ts` — all three exports present
3. `grep -r "VisualMapContinuousComponent\|HeatmapChart" packages/charts/src/heatmap/heatmap-registry.ts` — both registrations present
4. `grep "splitArea" packages/charts/src/shared/heatmap-option-builder.ts` — splitArea on both axes
</verification>

<success_criteria>
- heatmap-option-builder.ts exports HeatmapCell, HeatmapOptionProps, buildHeatmapOption with correct types
- heatmap-registry.ts exports registerHeatmapModules registering both HeatmapChart AND VisualMapContinuousComponent
- Both axes use type: 'category' with splitArea: { show: true }
- VisualMap min/max defaulting to [0, 100] to prevent streaming color drift
- TypeScript compile passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/93-heatmap-chart/93-01-SUMMARY.md`
</output>
