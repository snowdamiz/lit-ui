/**
 * CSS Generator Tests
 *
 * Tests for generateThemeCSS function that transforms
 * theme configurations into Tailwind v4-compatible CSS.
 */

import { describe, it, expect } from 'vitest';
import { generateThemeCSS } from '../../src/theme/css-generator.js';
import { defaultTheme } from '../../src/theme/defaults.js';

describe('generateThemeCSS', () => {
  describe('output structure', () => {
    it('returns a non-empty string', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(typeof css).toBe('string');
      expect(css.length).toBeGreaterThan(0);
    });

    it('contains :root block', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain(':root');
      expect(css).toMatch(/:root\s*\{/);
    });

    it('contains .dark block', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('.dark');
      expect(css).toMatch(/\.dark\s*\{/);
    });

    it('contains @media (prefers-color-scheme: dark) block', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('@media (prefers-color-scheme: dark)');
      expect(css).toMatch(/@media\s*\(\s*prefers-color-scheme:\s*dark\s*\)/);
    });

    it('contains header comment block', () => {
      const css = generateThemeCSS(defaultTheme);
      // Should have a comment at the start
      expect(css).toMatch(/^\/\*\*/);
      expect(css).toContain('Generated by');
    });
  });

  describe('color variables', () => {
    it('defines --lui-primary variable', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('--lui-primary:');
    });

    it('defines --lui-primary-foreground variable', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('--lui-primary-foreground:');
    });

    it('defines --lui-secondary variable', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('--lui-secondary:');
    });

    it('defines --lui-secondary-foreground variable', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('--lui-secondary-foreground:');
    });

    it('defines --lui-destructive variable', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('--lui-destructive:');
    });

    it('defines --lui-destructive-foreground variable', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('--lui-destructive-foreground:');
    });

    it('defines --lui-background variable', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('--lui-background:');
    });

    it('defines --lui-foreground variable', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('--lui-foreground:');
    });

    it('defines --lui-muted variable', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('--lui-muted:');
    });

    it('defines --lui-muted-foreground variable', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('--lui-muted-foreground:');
    });

    it('all color variables have oklch values', () => {
      const css = generateThemeCSS(defaultTheme);
      // Extract all --lui-* color definitions
      const colorVars = css.match(/--lui-\w+:\s*[^;]+/g) || [];
      const colorOnlyVars = colorVars.filter(v =>
        !v.includes('radius') // Exclude radius vars
      );

      // All color vars should have oklch values
      for (const varDef of colorOnlyVars) {
        expect(varDef).toMatch(/oklch\(/);
      }
    });
  });

  describe('radius variables', () => {
    it('defines --lui-radius-sm variable', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('--lui-radius-sm:');
    });

    it('defines --lui-radius-md variable', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('--lui-radius-md:');
    });

    it('defines --lui-radius-lg variable', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('--lui-radius-lg:');
    });

    it('radius values use rem units', () => {
      const css = generateThemeCSS(defaultTheme);
      // Extract radius definitions
      const radiusMatches = css.match(/--lui-radius-\w+:\s*[\d.]+rem/g) || [];
      expect(radiusMatches.length).toBeGreaterThanOrEqual(3);
    });

    it('uses correct sm radius values', () => {
      const smConfig = { ...defaultTheme, radius: 'sm' as const };
      const css = generateThemeCSS(smConfig);
      expect(css).toContain('--lui-radius-sm: 0.125rem');
      expect(css).toContain('--lui-radius-md: 0.25rem');
      expect(css).toContain('--lui-radius-lg: 0.375rem');
    });

    it('uses correct md radius values', () => {
      const mdConfig = { ...defaultTheme, radius: 'md' as const };
      const css = generateThemeCSS(mdConfig);
      expect(css).toContain('--lui-radius-sm: 0.125rem');
      expect(css).toContain('--lui-radius-md: 0.375rem');
      expect(css).toContain('--lui-radius-lg: 0.5rem');
    });

    it('uses correct lg radius values', () => {
      const lgConfig = { ...defaultTheme, radius: 'lg' as const };
      const css = generateThemeCSS(lgConfig);
      expect(css).toContain('--lui-radius-sm: 0.25rem');
      expect(css).toContain('--lui-radius-md: 0.5rem');
      expect(css).toContain('--lui-radius-lg: 0.75rem');
    });
  });

  describe('dark mode', () => {
    it('.dark block contains color overrides', () => {
      const css = generateThemeCSS(defaultTheme);
      // Extract .dark block
      const darkMatch = css.match(/\.dark\s*\{([^}]+)\}/);
      expect(darkMatch).not.toBeNull();
      const darkBlock = darkMatch![1];
      expect(darkBlock).toContain('--lui-primary:');
      expect(darkBlock).toContain('--lui-background:');
    });

    it('@media block contains :root:not(.light) selector', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain(':root:not(.light)');
    });

    it('dark mode colors are different from light mode', () => {
      const css = generateThemeCSS(defaultTheme);

      // Extract :root block colors
      const rootMatch = css.match(/:root\s*\{([^}]+)\}/);
      expect(rootMatch).not.toBeNull();
      const rootBlock = rootMatch![1];

      // Extract .dark block colors
      const darkMatch = css.match(/\.dark\s*\{([^}]+)\}/);
      expect(darkMatch).not.toBeNull();
      const darkBlock = darkMatch![1];

      // Primary color should be different
      const rootPrimary = rootBlock.match(/--lui-primary:\s*([^;]+)/);
      const darkPrimary = darkBlock.match(/--lui-primary:\s*([^;]+)/);

      expect(rootPrimary).not.toBeNull();
      expect(darkPrimary).not.toBeNull();
      expect(rootPrimary![1].trim()).not.toBe(darkPrimary![1].trim());
    });
  });

  describe('comments', () => {
    it('includes section comments', () => {
      const css = generateThemeCSS(defaultTheme);
      // Should have section dividers/comments
      expect(css).toMatch(/\/\*.*colors.*\*\//i);
      expect(css).toMatch(/\/\*.*radius.*\*\//i);
    });

    it('header includes generation metadata', () => {
      const css = generateThemeCSS(defaultTheme);
      expect(css).toContain('Lit UI');
    });
  });

  describe('CSS validity', () => {
    it('has balanced braces', () => {
      const css = generateThemeCSS(defaultTheme);
      const openBraces = (css.match(/\{/g) || []).length;
      const closeBraces = (css.match(/\}/g) || []).length;
      expect(openBraces).toBe(closeBraces);
    });

    it('has no unclosed comments', () => {
      const css = generateThemeCSS(defaultTheme);
      const openComments = (css.match(/\/\*/g) || []).length;
      const closeComments = (css.match(/\*\//g) || []).length;
      expect(openComments).toBe(closeComments);
    });

    it('all variable definitions end with semicolon', () => {
      const css = generateThemeCSS(defaultTheme);
      // Find all variable definitions
      const varDefs = css.match(/--lui-[\w-]+:\s*[^;]+/g) || [];
      // There should be many variable definitions
      expect(varDefs.length).toBeGreaterThan(10);

      // Check each definition is followed by a semicolon in the original CSS
      for (const varDef of varDefs) {
        // The match should be followed by ; in the css
        const fullPattern = new RegExp(
          varDef.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ';'
        );
        expect(css).toMatch(fullPattern);
      }
    });
  });

  describe('custom config', () => {
    it('uses provided colors instead of defaults', () => {
      const customConfig = {
        ...defaultTheme,
        colors: {
          ...defaultTheme.colors,
          primary: 'oklch(0.70 0.20 150)', // Different primary color
        },
      };
      const css = generateThemeCSS(customConfig);
      // Should contain the custom primary color (or derived value)
      expect(css).toContain('oklch(0.7');
    });
  });
});
